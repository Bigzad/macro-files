<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Macro Calculator & Tracker</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    
    
    <!-- Simple Logger - Must load first to control logging -->

    
    <!-- Initialization Manager - Must load after console manager -->
    
    
    <!-- Supabase Authentication System -->
    
    
    

    
    
    <!-- Security Middleware - Protects API endpoints -->
    
    
    <!-- UUID-based Auth Helper -->
    
    
    <!-- COMPREHENSIVE ERROR HANDLING SYSTEM -->
    
    
    <!-- Subscription Management System -->
    
    
    
    
    
    


    <style>
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .chart-container {
            position: relative;
            height: 120px;
            width: 120px;
        }
        .meal-item {
            transition: all 0.3s ease;
        }
        
        /* Mobile Sidebar Styles */
        .sidebar-open {
            transform: translateX(0) !important;
        }
        
        .sidebar-overlay-visible {
            display: block !important;
        }
        
        /* Prevent body scrolling when sidebar is open */
        .sidebar-no-scroll {
            overflow: hidden;
        }
        
        /* Smooth transitions for sidebar */
        #sidebar-menu {
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #sidebar-overlay {
            transition: opacity 0.3s ease-in-out;
        }
        
        /* Mobile responsive dropdown fixes */
        @media (max-width: 480px) {
            /* Ensure dropdowns are visible on mobile */
            #groceryDropdown, #progressExportDropdown {
                position: absolute !important;
                right: 0 !important;
                left: auto !important;
                top: 100% !important;
                margin-top: 0.25rem !important;
                min-width: 160px !important;
                max-width: calc(100vw - 2rem) !important;
                z-index: 9999 !important;
                background: white !important;
                border: 1px solid #e5e7eb !important;
                border-radius: 0.5rem !important;
                box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04) !important;
            }
            
            /* Make dropdown buttons more touch-friendly on mobile */
            #groceryDropdown button, #progressExportDropdown button {
                min-height: 44px !important;
                padding: 0.75rem 1rem !important;
                font-size: 14px !important;
            }
            
            /* Truncate long text on mobile */
            .truncate {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
        }
        
        /* Extra small screen adjustments */
        @media (max-width: 375px) {
            /* For iPhone SE and similar small screens */
            .relative .absolute {
                right: 0.5rem !important;
                max-width: calc(100vw - 1rem) !important;
            }
        }
        .meal-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        /* Custom Notification Styles */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            min-width: 320px;
            max-width: 400px;
            padding: 16px 20px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.15);
            transform: translateX(100%);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border-left: 4px solid #047857;
        }
        
        .notification.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border-left: 4px solid #b45309;
        }
        
        .notification.error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border-left: 4px solid #b91c1c;
        }
        
        .notification.info {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border-left: 4px solid #1d4ed8;
        }
        
        .notification-icon {
            font-size: 20px;
            margin-right: 12px;
        }
        
        .notification-content {
            display: flex;
            align-items: center;
        }
        
        .notification-text {
            flex: 1;
        }
        
        .notification-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 2px;
        }
        
        .notification-message {
            font-size: 13px;
            opacity: 0.9;
        }
        
        .notification-close {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            margin-left: 12px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        
        .notification-close:hover {
            opacity: 1;
        }
        
        /* Custom Modal Styles */
        .custom-modal {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1001;
            padding: 20px;
            backdrop-filter: blur(5px);
        }
        
        .custom-modal-content {
            background: white;
            border-radius: 16px;
            padding: 24px;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            transform: scale(0.9);
            animation: modalShow 0.2s ease forwards;
        }
        
        @keyframes modalShow {
            to {
                transform: scale(1);
            }
        }
        
        .modal-icon {
            font-size: 48px;
            text-align: center;
            margin-bottom: 16px;
        }
        
        .modal-title {
            font-size: 20px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 8px;
            color: #374151;
        }
        
        .modal-message {
            text-align: center;
            color: #6b7280;
            margin-bottom: 24px;
            line-height: 1.5;
        }
        
        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        
        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .modal-btn-primary {
            background: #ef4444;
            color: white;
        }
        
        .modal-btn-primary:hover {
            background: #dc2626;
        }
        
        .modal-btn-secondary {
            background: #f3f4f6;
            color: #374151;
        }
        
        .modal-btn-secondary:hover {
            background: #e5e7eb;
        }
        
        /* Mobile Responsive Fixes */
        * {
            box-sizing: border-box;
        }
        
        html, body {
            overflow-x: hidden;
            width: 100%;
            max-width: 100vw;
        }
        
        .container {
            width: 100%;
            max-width: 100vw;
            padding-left: 1rem;
            padding-right: 1rem;
            margin: 0 auto;
        }
        
        /* Fix grid overflows on mobile */
        .grid {
            width: 100%;
        }
        
        /* Mobile input fixes */
        input, select, textarea, button {
            max-width: 100%;
            word-wrap: break-word;
        }
        
        /* Notification responsive fixes */
        .notification {
            left: 10px;
            right: 10px;
            width: auto;
            min-width: auto;
            max-width: calc(100vw - 20px);
            transform: translateX(0);
            opacity: 0;
            visibility: hidden;
        }
        
        .notification.show {
            transform: translateX(0);
            opacity: 1;
            visibility: visible;
        }
        
        /* Mobile modal fixes */
        .custom-modal {
            padding: 10px;
        }
        
        .custom-modal-content {
            margin: 0 auto;
            max-width: calc(100vw - 20px);
            width: 100%;
        }
        
        /* Recipe cards mobile fixes */
        .recipe-card {
            width: 100%;
            max-width: 100%;
        }
        
        /* Chart container mobile fixes */
        .chart-container {
            max-width: 100px;
            max-height: 100px;
            margin: 0 auto;
        }
        
        /* Table/grid responsive */
        @media (max-width: 768px) {
            .md\\:grid-cols-2 {
                grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            }
            
            .md\\:grid-cols-3 {
                grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            }
            
            .md\\:grid-cols-4 {
                grid-template-columns: repeat(2, minmax(0, 1fr)) !important;
            }
            
            .md\\:grid-cols-5 {
                grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            }
            
            .md\\:grid-cols-6 {
                grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            }
            
            .lg\\:grid-cols-2 {
                grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            }
            
            .lg\\:grid-cols-3 {
                grid-template-columns: repeat(1, minmax(0, 1fr)) !important;
            }
        }
        
        /* Small mobile fixes */
        @media (max-width: 480px) {
            .text-3xl {
                font-size: 1.5rem !important;
            }
            
            .text-2xl {
                font-size: 1.25rem !important;
            }
            
            .p-6 {
                padding: 1rem !important;
            }
            
            .gap-8 {
                gap: 1rem !important;
            }
            
            .gap-6 {
                gap: 0.75rem !important;
            }
            
            .gap-4 {
                gap: 0.5rem !important;
            }
            
            /* Day selection buttons */
            .day-btn {
                font-size: 0.75rem !important;
                padding: 0.5rem 0.75rem !important;
            }
            
            /* Progress bars mobile */
            .chart-container {
                height: 80px !important;
                width: 80px !important;
            }
        }
        
        /* Extra small devices */
        @media (max-width: 360px) {
            .container {
                padding-left: 0.5rem;
                padding-right: 0.5rem;
            }
            
            .text-lg {
                font-size: 1rem !important;
            }
            
            .p-4 {
                padding: 0.75rem !important;
            }
            
            .px-4 {
                padding-left: 0.75rem !important;
                padding-right: 0.75rem !important;
            }
            
            .py-4 {
                padding-top: 0.75rem !important;
                padding-bottom: 0.75rem !important;
            }
        }

        /* Custom Toggle Switch Styles */
        input[type="checkbox"]:checked + div .toggle-dot {
            transform: translateX(16px);
        }
        
        input[type="checkbox"]:checked + div {
            background-color: #3b82f6;
        }

        /* Custom Section Animation */
        .custom-section-transition {
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    
    <!-- Main Application (Protected - Only shown to authenticated users) -->
    <div id="app-section">
        <div class="container mx-auto p-2 sm:p-4 max-w-6xl w-full">
            

        <!-- Top Navigation Bar -->
        <nav class="bg-white shadow-sm border-b border-gray-200 mb-8">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center h-16">
                    <!-- Left side - Logo and Title -->
                    <div class="flex items-center">
                        <div class="flex-shrink-0 flex items-center">
                            <i class="fas fa-calculator text-purple-600 text-2xl mr-3"></i>
                            <h1 class="text-xl font-bold text-gray-900 hidden sm:block">AI-Powered Macro Calculator</h1>
                            <h1 class="text-lg font-bold text-gray-900 sm:hidden">Macro Calculator</h1>
                        </div>
                    </div>
                    
                    <!-- Right side - Unit Selection, Hamburger Menu -->
                    <div class="flex items-center space-x-4">
                        <!-- Unit Selection (Desktop only) -->
                        <div class="hidden md:block">
                            <select id="unitSystem" onchange="changeUnitSystem()" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:border-transparent">
                                <option value="imperial">Imperial (lbs/in)</option>
                                <option value="metric">Metric (kg/cm)</option>
                            </select>
                        </div>
                        
                        <!-- Desktop User Info (Hidden on Mobile) -->
                        <div id="desktop-user-info" class="hidden md:flex items-center space-x-3">
                            <div class="flex items-center space-x-2">
                                <div class="w-8 h-8 bg-purple-600 rounded-full flex items-center justify-center">
                                    <i class="fas fa-user text-white text-sm"></i>
                                </div>
                                <span id="desktop-user-name" class="text-sm font-medium text-gray-700"></span>
                            </div>
                        </div>
                        
                        <!-- Desktop Logout Button (Hidden on Mobile) -->
                        <button id="desktop-auth-button" onclick="handleAuth()" class="hidden md:inline-flex items-center px-3 py-2 border border-transparent text-sm leading-4 font-medium rounded-md text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors">
                            <i class="fas fa-sign-out-alt mr-2"></i>Logout
                        </button>
                        
                        <!-- Mobile Hamburger Menu Button -->
                        <button id="hamburger-btn" onclick="toggleSidebar()" class="md:hidden p-2 rounded-lg text-gray-600 hover:text-gray-900 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-purple-500">
                            <i class="fas fa-bars text-xl"></i>
                        </button>
                        
                    </div>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Mobile Sidebar Menu -->
        <div id="sidebar-overlay" class="fixed inset-0 bg-black bg-opacity-50 z-40 hidden md:hidden" onclick="closeSidebar()"></div>
        <div id="sidebar-menu" class="fixed top-0 left-0 w-80 h-full bg-white shadow-xl z-50 transform -translate-x-full transition-transform duration-300 ease-in-out md:hidden">
            <!-- Sidebar Header -->
            <div class="flex items-center justify-between p-6 border-b border-gray-200 bg-gradient-to-r from-purple-600 to-blue-600">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-white bg-opacity-20 rounded-full flex items-center justify-center">
                        <i class="fas fa-calculator text-white text-lg"></i>
                    </div>
                    <h2 class="text-lg font-bold text-white">Macro Calculator</h2>
                </div>
                <button onclick="closeSidebar()" class="p-2 rounded-lg text-white hover:bg-white hover:bg-opacity-20 transition-colors">
                    <i class="fas fa-times text-xl"></i>
                </button>
            </div>
            
            <!-- User Profile Section -->
            <div id="sidebar-user-section" class="p-6 border-b border-gray-200 bg-gray-50">
                <div class="flex items-center space-x-3">
                    <div class="w-12 h-12 bg-purple-600 rounded-full flex items-center justify-center">
                        <i class="fas fa-user text-white text-lg"></i>
                    </div>
                    <div>
                        <div id="sidebar-user-name" class="font-medium text-gray-900 text-sm"></div>
                        <div id="sidebar-user-email" class="text-gray-600 text-xs mt-1"></div>
                    </div>
                </div>
            </div>
            
            <!-- Menu Items -->
            <div class="py-4">
                <!-- Unit System Selection -->
                <div class="px-6 py-3 border-b border-gray-100">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Measurement Units</label>
                    <select id="mobile-unit-system" onchange="changeUnitSystemMobile()" class="w-full bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:border-transparent">
                        <option value="imperial">Imperial (lbs/in)</option>
                        <option value="metric">Metric (kg/cm)</option>
                    </select>
                </div>
                
                <!-- App Info -->
                <div class="px-6 py-4 border-b border-gray-100">
                    <div class="flex items-center space-x-3 text-gray-700">
                        <i class="fas fa-info-circle text-purple-600"></i>
                        <div>
                            <div class="font-medium text-sm">Personalized nutrition planning made simple</div>
                            <div class="text-xs text-gray-500 mt-1">AI-powered macro tracking</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Bottom Actions -->
            <div class="absolute bottom-0 left-0 right-0 p-6 border-t border-gray-200 bg-gray-50">
                <button id="mobile-logout-btn" onclick="handleAuthMobile()" class="w-full flex items-center justify-center px-4 py-3 bg-red-600 hover:bg-red-700 text-white font-medium rounded-lg transition-colors">
                    <i class="fas fa-sign-out-alt mr-2"></i>
                    Logout
                </button>
            </div>
        </div>

        <!-- App Description Banner -->
        <div class="gradient-bg text-white p-4 rounded-lg shadow-lg mb-8">
            <div class="text-center">
                <p class="text-lg opacity-90">Personalized nutrition planning made simple</p>
            </div>
        </div>

        <!-- Mobile Unit Selection -->
        <div class="md:hidden mb-6 bg-white p-4 rounded-lg shadow-sm">
            <label class="block text-sm font-medium text-gray-700 mb-2">
                <i class="fas fa-globe mr-2"></i>Measurement Units
            </label>
            <select id="unitSystemMobile" onchange="changeUnitSystem()" class="w-full bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg px-3 py-2 focus:ring-2 focus:ring-purple-500 focus:border-transparent">
                <option value="imperial">Imperial (lbs / inches)</option>
                <option value="metric">Metric (kg / cm)</option>
            </select>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4 lg:gap-8">
            <!-- Calculator Section -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-2xl font-bold mb-6 text-gray-800">Personal Information</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Age</label>
                        <input type="number" id="age" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="25" min="10" max="100">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">Gender</label>
                        <select id="gender" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="male">Male</option>
                            <option value="female">Female</option>
                        </select>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="weight" class="block text-sm font-medium text-gray-700 mb-2">Weight (lbs)</label>
                        <input type="number" id="weight" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="152.19" min="50" max="500" step="0.1">
                    </div>
                    <div>
                        <label for="height" class="block text-sm font-medium text-gray-700 mb-2">Height (inches)</label>
                        <input type="number" id="height" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent" placeholder="66.9291" min="48" max="84" step="0.1">
                    </div>
                </div>

                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Activity Level</label>
                    <select id="activity" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <option value="1.2">Sedentary (little or no exercise)</option>
                        <option value="1.375">Lightly active (light exercise 1-3 days/week)</option>
                        <option value="1.55" selected>Moderately active (moderate exercise 3-5 days/week)</option>
                        <option value="1.725">Very active (hard exercise 6-7 days/week)</option>
                        <option value="1.9">Extremely active (very hard exercise, physical job)</option>
                    </select>
                </div>

                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Goal</label>
                    <select id="goal" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                        <option value="-500">Weight Loss (-500 cal/day)</option>
                        <option value="0">Maintain Weight</option>
                        <option value="300">Muscle Gain (+300 cal/day)</option>
                    </select>
                </div>

                <!-- Authentication Status -->
                <div id="auth-status" class="mb-4 text-sm text-gray-600 hidden">
                    <i class="fas fa-info-circle mr-1"></i>
                    <span id="auth-status-text">Checking sync status...</span>
                </div>

                <!-- Load Previous Details Button -->
                <div class="mb-4">
                    <button onclick="loadAndPopulatePersonalInfo(true)" class="w-full bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded-lg transition duration-200 border border-gray-300">
                        <i class="fas fa-history mr-2"></i>Load My Previous Details
                    </button>
                </div>

                <button onclick="calculateMacros()" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 transform hover:scale-105">
                    <i class="fas fa-calculator mr-2"></i>Calculate My Macros
                </button>
            </div>

            <!-- Results Section -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h2 class="text-2xl font-bold mb-6 text-gray-800">Your Personalized Results</h2>
                
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                    <div class="text-center">
                        <div class="chart-container mx-auto mb-2">
                            <canvas id="caloriesChart"></canvas>
                        </div>
                        <div class="font-bold text-lg text-blue-600" id="dailyCalories">2,000</div>
                        <div class="text-sm text-gray-600">Calories</div>
                    </div>
                    <div class="text-center">
                        <div class="chart-container mx-auto mb-2">
                            <canvas id="proteinChart"></canvas>
                        </div>
                        <div class="font-bold text-lg text-red-500" id="proteinAmount">150g</div>
                        <div class="text-sm text-gray-600">Protein</div>
                    </div>
                    <div class="text-center">
                        <div class="chart-container mx-auto mb-2">
                            <canvas id="carbsChart"></canvas>
                        </div>
                        <div class="font-bold text-lg text-green-500" id="carbsAmount">250g</div>
                        <div class="text-sm text-gray-600">Carbs</div>
                    </div>
                    <div class="text-center">
                        <div class="chart-container mx-auto mb-2">
                            <canvas id="fatChart"></canvas>
                        </div>
                        <div class="font-bold text-lg text-yellow-500" id="fatAmount">67g</div>
                        <div class="text-sm text-gray-600">Fat</div>
                    </div>
                </div>

                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded">
                    <h3 class="font-bold text-yellow-800 mb-2">
                        <i class="fas fa-brain mr-2"></i>AI Recommendations:
                    </h3>
                    <ul class="text-sm text-yellow-700 space-y-1" id="recommendations">
                        <li>• Eat protein within 30 minutes post-workout</li>
                        <li>• Spread protein intake evenly throughout the day</li>
                        <li>• Focus on complex carbs around workouts</li>
                        <li>• Include healthy fats with each meal</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Macro Tracker Section -->
        <div class="mt-8 bg-white rounded-lg shadow-lg p-6">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-gray-800">
                    <i class="fas fa-chart-line mr-2"></i>Daily Macro Tracker
                </h2>
                <div class="flex gap-2">
                    <button onclick="loadTodayMeals()" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg text-sm">
                        <i class="fas fa-history mr-1"></i>Load Meals
                    </button>
                    <button onclick="resetTracker()" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm">
                        <i class="fas fa-redo mr-1"></i>Reset Day
                    </button>
                </div>
            </div>

            <!-- Daily Achievement Label -->
            <div class="flex justify-center mb-4">
                <div class="bg-blue-50 border border-blue-200 rounded-full px-4 py-2">
                    <span class="text-blue-700 font-medium text-sm">
                        <i class="fas fa-target mr-1"></i>Daily Progress: 
                        <span id="dailyProgress" class="font-bold">0%</span>
                    </span>
                </div>
            </div>

            <!-- Progress Bars -->
            <div class="grid grid-cols-1 gap-3 md:grid-cols-2 lg:grid-cols-4 md:gap-4 mb-6">
                <!-- Calories Bar -->
                <div class="bg-blue-50 p-3 sm:p-4 rounded-lg">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-medium text-blue-700">Calories</span>
                        <span class="text-sm text-blue-600" id="caloriesProgress">0 / 2000</span>
                    </div>
                    <div class="w-full bg-blue-200 rounded-full h-3">
                        <div class="bg-blue-500 h-3 rounded-full transition-all duration-300" id="caloriesBar" style="width: 0%"></div>
                    </div>
                </div>
                
                <div class="bg-red-50 p-3 sm:p-4 rounded-lg">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-medium text-red-700">Protein</span>
                        <span class="text-sm text-red-600" id="proteinProgress">0g / 150g</span>
                    </div>
                    <div class="w-full bg-red-200 rounded-full h-3">
                        <div class="bg-red-500 h-3 rounded-full transition-all duration-300" id="proteinBar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="bg-green-50 p-3 sm:p-4 rounded-lg">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-medium text-green-700">Carbs</span>
                        <span class="text-sm text-green-600" id="carbsProgress">0g / 250g</span>
                    </div>
                    <div class="w-full bg-green-200 rounded-full h-3">
                        <div class="bg-green-500 h-3 rounded-full transition-all duration-300" id="carbsBar" style="width: 0%"></div>
                    </div>
                </div>
                <div class="bg-yellow-50 p-3 sm:p-4 rounded-lg">
                    <div class="flex justify-between items-center mb-2">
                        <span class="font-medium text-yellow-700">Fat</span>
                        <span class="text-sm text-yellow-600" id="fatProgress">0g / 67g</span>
                    </div>
                    <div class="w-full bg-yellow-200 rounded-full h-3">
                        <div class="bg-yellow-500 h-3 rounded-full transition-all duration-300" id="fatBar" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <!-- Add Meal Form -->
            <div class="bg-gray-50 p-4 rounded-lg mb-6">
                <h3 class="font-bold text-gray-800 mb-4">Add Meal</h3>
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-6 gap-2 sm:gap-4">
                    <input type="text" id="mealName" placeholder="Meal name" class="p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500">
                    <input type="number" id="mealCalories" placeholder="Calories" class="p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" step="1">
                    <input type="number" id="mealProtein" placeholder="Protein (g)" class="p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" step="0.1">
                    <input type="number" id="mealCarbs" placeholder="Carbs (g)" class="p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" step="0.1">
                    <input type="number" id="mealFat" placeholder="Fat (g)" class="p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" step="0.1">
                    <button onclick="addMeal()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-medium">
                        <i class="fas fa-plus mr-1"></i>Add
                    </button>
                </div>
            </div>

            <!-- Meals List -->
            <div id="mealsList" class="space-y-3">
                <!-- Meals will be added here dynamically -->
            </div>
        </div>

        <!-- Meal Planning Section -->
        <div class="mt-8 bg-white rounded-lg shadow-lg p-6">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
                <h2 class="text-2xl font-bold text-gray-800">
                    <i class="fas fa-calendar-alt mr-2"></i>Weekly Meal Planner
                </h2>
                <div class="flex flex-wrap gap-2">
                    <button onclick="exportMealPlanPDF()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm">
                        <i class="fas fa-file-pdf mr-1"></i><span class="hidden xs:inline">Export </span>PDF
                    </button>
                    <button onclick="exportMealPlanCSV()" class="bg-green-500 hover:bg-green-600 text-white px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm">
                        <i class="fas fa-file-csv mr-1"></i><span class="hidden xs:inline">Export </span>CSV
                    </button>
                    <!-- Grocery List Export Dropdown -->
                    <div class="relative inline-block">
                        <button onclick="toggleGroceryDropdown()" class="bg-purple-500 hover:bg-purple-600 text-white px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm flex items-center">
                            <i class="fas fa-shopping-cart mr-1"></i>Grocery List <i class="fas fa-chevron-down ml-1"></i>
                        </button>
                        <div id="groceryDropdown" class="hidden absolute right-0 sm:right-0 mt-1 w-40 sm:w-48 bg-white border border-gray-200 rounded-lg shadow-lg z-50 max-w-xs">
                            <button onclick="exportGroceryList('pdf')" class="w-full text-left px-3 sm:px-4 py-2 hover:bg-gray-100 flex items-center text-xs sm:text-sm">
                                <i class="fas fa-file-pdf mr-2 text-red-600 text-sm"></i>
                                <span class="truncate">Professional PDF</span>
                            </button>
                            <button onclick="exportGroceryList('html')" class="w-full text-left px-3 sm:px-4 py-2 hover:bg-gray-100 flex items-center text-xs sm:text-sm">
                                <i class="fas fa-globe mr-2 text-blue-600 text-sm"></i>
                                <span class="truncate">Web Format</span>
                            </button>
                        </div>
                    </div>
                    <button onclick="clearMealPlan()" class="bg-red-500 hover:bg-red-600 text-white px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm">
                        <i class="fas fa-trash mr-1"></i><span class="hidden xs:inline">Clear </span>Plan
                    </button>
                </div>
            </div>

            <!-- Day Selection -->
            <div class="flex flex-wrap gap-1 sm:gap-2 mb-6 justify-center sm:justify-start">
                <button onclick="selectDay('monday')" id="btn-monday" class="day-btn bg-blue-100 hover:bg-blue-200 text-blue-800 px-4 py-2 rounded-lg font-medium transition-colors">Monday</button>
                <button onclick="selectDay('tuesday')" id="btn-tuesday" class="day-btn bg-blue-100 hover:bg-blue-200 text-blue-800 px-4 py-2 rounded-lg font-medium transition-colors">Tuesday</button>
                <button onclick="selectDay('wednesday')" id="btn-wednesday" class="day-btn bg-blue-100 hover:bg-blue-200 text-blue-800 px-4 py-2 rounded-lg font-medium transition-colors">Wednesday</button>
                <button onclick="selectDay('thursday')" id="btn-thursday" class="day-btn bg-blue-100 hover:bg-blue-200 text-blue-800 px-4 py-2 rounded-lg font-medium transition-colors">Thursday</button>
                <button onclick="selectDay('friday')" id="btn-friday" class="day-btn bg-blue-100 hover:bg-blue-200 text-blue-800 px-4 py-2 rounded-lg font-medium transition-colors">Friday</button>
                <button onclick="selectDay('saturday')" id="btn-saturday" class="day-btn bg-blue-100 hover:bg-blue-200 text-blue-800 px-4 py-2 rounded-lg font-medium transition-colors">Saturday</button>
                <button onclick="selectDay('sunday')" id="btn-sunday" class="day-btn bg-blue-100 hover:bg-blue-200 text-blue-800 px-4 py-2 rounded-lg font-medium transition-colors">Sunday</button>
            </div>

            <!-- Current Day Display -->
            <div class="bg-gradient-to-r from-purple-50 to-blue-50 p-4 rounded-lg mb-6">
                <h3 class="text-lg font-bold text-gray-800 mb-2">Planning for: <span id="currentDay" class="text-blue-600">Monday</span></h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- Breakfast -->
                    <div class="bg-white p-4 rounded-lg border">
                        <h4 class="font-bold text-orange-600 mb-3"><i class="fas fa-sun mr-2"></i>Breakfast</h4>
                        <div class="space-y-2 mb-3">
                            <input type="text" id="breakfast-meal" placeholder="Meal name" class="w-full p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-orange-500">
                            <div class="grid grid-cols-2 gap-2">
                                <input type="number" id="breakfast-calories" placeholder="Calories" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-orange-500" step="1">
                                <input type="number" id="breakfast-protein" placeholder="Protein (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-orange-500" step="0.1">
                                <input type="number" id="breakfast-carbs" placeholder="Carbs (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-orange-500" step="0.1">
                                <input type="number" id="breakfast-fat" placeholder="Fat (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-orange-500" step="0.1">
                            </div>
                        </div>
                        <button onclick="addPlannedMeal('breakfast')" class="w-full py-2 px-3 rounded text-sm font-medium" style="background-color: #f97316 !important; color: white !important; border: none;">
                            <i class="fas fa-plus mr-1"></i>Add
                        </button>
                        <div id="breakfast-list" class="mt-3 space-y-1"></div>
                    </div>

                    <!-- Lunch -->
                    <div class="bg-white p-4 rounded-lg border">
                        <h4 class="font-bold text-green-600 mb-3"><i class="fas fa-sun mr-2"></i>Lunch</h4>
                        <div class="space-y-2 mb-3">
                            <input type="text" id="lunch-meal" placeholder="Meal name" class="w-full p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-green-500">
                            <div class="grid grid-cols-2 gap-2">
                                <input type="number" id="lunch-calories" placeholder="Calories" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-green-500" step="1">
                                <input type="number" id="lunch-protein" placeholder="Protein (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-green-500" step="0.1">
                                <input type="number" id="lunch-carbs" placeholder="Carbs (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-green-500" step="0.1">
                                <input type="number" id="lunch-fat" placeholder="Fat (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-green-500" step="0.1">
                            </div>
                        </div>
                        <button onclick="addPlannedMeal('lunch')" class="w-full bg-green-500 hover:bg-green-600 text-white py-2 px-3 rounded text-sm font-medium">
                            <i class="fas fa-plus mr-1"></i>Add
                        </button>
                        <div id="lunch-list" class="mt-3 space-y-1"></div>
                    </div>

                    <!-- Dinner -->
                    <div class="bg-white p-4 rounded-lg border">
                        <h4 class="font-bold text-purple-600 mb-3"><i class="fas fa-moon mr-2"></i>Dinner</h4>
                        <div class="space-y-2 mb-3">
                            <input type="text" id="dinner-meal" placeholder="Meal name" class="w-full p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-purple-500">
                            <div class="grid grid-cols-2 gap-2">
                                <input type="number" id="dinner-calories" placeholder="Calories" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-purple-500" step="1">
                                <input type="number" id="dinner-protein" placeholder="Protein (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-purple-500" step="0.1">
                                <input type="number" id="dinner-carbs" placeholder="Carbs (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-purple-500" step="0.1">
                                <input type="number" id="dinner-fat" placeholder="Fat (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-purple-500" step="0.1">
                            </div>
                        </div>
                        <button onclick="addPlannedMeal('dinner')" class="w-full bg-purple-500 hover:bg-purple-600 text-white py-2 px-3 rounded text-sm font-medium">
                            <i class="fas fa-plus mr-1"></i>Add
                        </button>
                        <div id="dinner-list" class="mt-3 space-y-1"></div>
                    </div>

                    <!-- Dynamic Custom Sections Container -->
                    <div id="customSectionsContainer"></div>

                    <!-- Add Custom Section Bar (appears below existing custom sections) -->
                    <div id="addCustomSectionBar" class="bg-white p-4 rounded-lg border">
                        <div class="flex items-center justify-between mb-3">
                            <h4 class="font-bold text-gray-800"><i class="fas fa-plus-circle mr-2"></i>Add Custom Section</h4>
                            <button id="toggleAddCustomBtn" onclick="toggleAddCustomSection()" class="bg-blue-500 hover:bg-blue-600 text-white py-1 px-3 rounded text-sm">
                                <i class="fas fa-plus mr-1"></i>Add
                            </button>
                        </div>
                        
                        <!-- Custom Section Name Input -->
                        <div id="customSectionConfig" class="hidden">
                            <div class="mb-3">
                                <input type="text" id="customSectionName" placeholder="Section name (e.g., Snacks, Drinks, Supplements)" class="w-full p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" maxlength="20">
                            </div>
                            <div class="flex gap-2">
                                <button onclick="createCustomSection()" class="flex-1 bg-green-500 hover:bg-green-600 text-white py-2 px-3 rounded text-sm font-medium">
                                    <i class="fas fa-check mr-1"></i>Create Section
                                </button>
                                <button onclick="cancelAddCustomSection()" class="bg-gray-500 hover:bg-gray-600 text-white py-2 px-3 rounded text-sm font-medium">
                                    <i class="fas fa-times mr-1"></i>Cancel
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Daily Summary for Selected Day -->
                <div class="mt-4 bg-white p-4 rounded-lg border">
                    <h4 class="font-bold text-gray-800 mb-2">Daily Summary</h4>
                    <div class="grid grid-cols-2 md:grid-cols-3 gap-4 text-center mb-3">
                        <div>
                            <div class="text-lg font-bold text-blue-600" id="planned-calories">0</div>
                            <div class="text-sm text-gray-600">Calories</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-red-500" id="planned-protein">0g</div>
                            <div class="text-sm text-gray-600">Protein</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-green-600" id="planned-carbs">0g</div>
                            <div class="text-sm text-gray-600">Carbs</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-yellow-600" id="planned-fat">0g</div>
                            <div class="text-sm text-gray-600">Fat</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-gray-500" id="planned-meals">0</div>
                            <div class="text-sm text-gray-600">Meals</div>
                        </div>
                        <div>
                            <button onclick="copyToTracker()" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm font-medium">
                                <i class="fas fa-copy mr-1"></i>Copy to Tracker
                            </button>
                        </div>
                    </div>
                </div>
            </div>


        </div>

        <!-- Recipe Database Section -->
        <div class="mt-8 bg-white rounded-lg shadow-lg p-6">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-gray-800">
                    <i class="fas fa-book mr-2"></i>Recipe Database
                </h2>
                <div class="flex gap-2">
                    <button onclick="toggleAddRecipeForm()" id="addRecipeToggle" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg text-sm">
                        <i class="fas fa-plus mr-1"></i>Add Recipe
                    </button>
                    <button onclick="clearCustomRecipes()" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg text-sm">
                        <i class="fas fa-trash mr-1"></i>Clear Custom
                    </button>
                </div>
            </div>

            <!-- Search and Filter -->
            <div class="grid grid-cols-1 gap-3 md:grid-cols-3 md:gap-4 mb-6">
                <input type="text" id="recipeSearch" placeholder="Search recipes..." class="p-2 sm:p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 w-full" onkeyup="filterRecipes()">
                <select id="recipeFilter" class="p-2 sm:p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 w-full" onchange="filterRecipes()">
                    <option value="">All Categories</option>
                    <option value="breakfast">Breakfast</option>
                    <option value="lunch">Lunch</option>
                    <option value="dinner">Dinner</option>
                    <option value="snack">Snack</option>
                    <option value="custom">Custom Recipes</option>
                </select>
                <select id="caloryRange" class="p-2 sm:p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 w-full" onchange="filterRecipes()">
                    <option value="">All Calories</option>
                    <option value="0-300">Under 300 cal</option>
                    <option value="300-500">300-500 cal</option>
                    <option value="500-700">500-700 cal</option>
                    <option value="700+">700+ cal</option>
                </select>
            </div>

            <!-- Add Recipe Form (Hidden by default) -->
            <div id="addRecipeForm" class="bg-gray-50 p-6 rounded-lg mb-6 hidden">
                <h3 class="text-lg font-bold text-gray-800 mb-4">Add Your Own Recipe</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <input type="text" id="newRecipeName" placeholder="Recipe Name" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                    <select id="newRecipeCategory" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                        <option value="breakfast">Breakfast</option>
                        <option value="lunch">Lunch</option>
                        <option value="dinner">Dinner</option>
                        <option value="snack">Snack</option>
                    </select>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                    <input type="number" id="newRecipeCalories" placeholder="Calories" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" step="1">
                    <input type="number" id="newRecipeProtein" placeholder="Protein (g)" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" step="0.1">
                    <input type="number" id="newRecipeCarbs" placeholder="Carbs (g)" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" step="0.1">
                    <input type="number" id="newRecipeFat" placeholder="Fat (g)" class="p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500" step="0.1">
                </div>
                <input type="text" id="newRecipeServings" placeholder="Serving Size (e.g., 1 bowl, 2 pieces)" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 mb-4">
                <textarea id="newRecipeIngredients" placeholder="Ingredients (one per line)" rows="4" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 mb-4"></textarea>
                <textarea id="newRecipeInstructions" placeholder="Cooking Instructions" rows="4" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500 mb-4"></textarea>
                <div class="flex gap-2">
                    <button onclick="saveCustomRecipe()" class="bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg font-medium">
                        <i class="fas fa-save mr-2"></i>Save Recipe
                    </button>
                    <button onclick="toggleAddRecipeForm()" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-3 rounded-lg font-medium">
                        Cancel
                    </button>
                </div>
            </div>

            <!-- Recipe Cards Container -->
            <div id="recipesContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Recipes will be populated here -->
            </div>

            <!-- Show More/Less Button -->
            <div id="showMoreContainer" class="text-center mt-6 hidden">
                <button id="showMoreBtn" onclick="toggleRecipeDisplay()" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg font-medium transition-colors">
                    <i class="fas fa-chevron-down mr-2"></i>Show More Recipes (<span id="hiddenCount">0</span> hidden)
                </button>
            </div>

            <!-- No Results Message -->
            <div id="noResults" class="text-center py-8 hidden">
                <i class="fas fa-search text-4xl text-gray-300 mb-4"></i>
                <p class="text-gray-500 text-lg">No recipes found matching your criteria.</p>
            </div>
        </div>

        <!-- Progress Tracker Dashboard -->
        <div class="mt-8 bg-white rounded-lg shadow-lg p-6">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-6 gap-4">
                <h2 class="text-2xl font-bold text-gray-800">
                    <i class="fas fa-chart-line mr-2"></i>Progress Tracker Dashboard
                </h2>
                <div class="flex flex-wrap gap-2">
                    <!-- Direct Export Buttons -->
                    <button onclick="exportProgressPDF()" class="bg-red-500 hover:bg-red-600 text-white px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm flex items-center">
                        <i class="fas fa-file-pdf mr-1"></i>PDF Report
                    </button>
                    <button onclick="exportProgressCSV()" class="bg-green-500 hover:bg-green-600 text-white px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm flex items-center">
                        <i class="fas fa-file-csv mr-1"></i>CSV Data
                    </button>
                    <button onclick="clearAllProgressData()" class="bg-red-500 hover:bg-red-600 text-white px-3 sm:px-4 py-2 rounded-lg text-xs sm:text-sm">
                        <i class="fas fa-trash mr-1"></i>Clear
                    </button>
                </div>
            </div>

            <!-- Quick Stats Overview -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-3 sm:gap-4 mb-6">
                <div class="bg-gradient-to-r from-blue-50 to-blue-100 p-3 sm:p-4 rounded-lg text-center">
                    <div class="text-lg sm:text-2xl font-bold text-blue-600" id="currentWeight">--</div>
                    <div class="text-xs sm:text-sm text-blue-700">Current Weight</div>
                    <div class="text-xs text-blue-600 mt-1" id="weightChange">No data</div>
                </div>
                <div class="bg-gradient-to-r from-green-50 to-green-100 p-3 sm:p-4 rounded-lg text-center">
                    <div class="text-lg sm:text-2xl font-bold text-green-600" id="totalProgressEntries">0</div>
                    <div class="text-xs sm:text-sm text-green-700">Entries</div>
                    <div class="text-xs text-green-600 mt-1" id="daysSinceStart">0 days</div>
                </div>
                <div class="bg-gradient-to-r from-purple-50 to-purple-100 p-3 sm:p-4 rounded-lg text-center">
                    <div class="text-lg sm:text-2xl font-bold text-purple-600" id="goalProgressPercent">0%</div>
                    <div class="text-xs sm:text-sm text-purple-700">Goal Progress</div>
                    <div class="text-xs text-purple-600 mt-1" id="goalStatusText">Set goal</div>
                </div>
                <div class="bg-gradient-to-r from-orange-50 to-orange-100 p-3 sm:p-4 rounded-lg text-center">
                    <div class="text-lg sm:text-2xl font-bold text-orange-600" id="weeklyAverage">--</div>
                    <div class="text-xs sm:text-sm text-orange-700">Weekly Avg</div>
                    <div class="text-xs text-orange-600 mt-1">Change</div>
                </div>
            </div>

            <!-- Add Progress Entry Form -->
            <div class="bg-gray-50 p-4 rounded-lg mb-6">
                <h3 class="text-lg font-bold text-gray-800 mb-4">
                    <i class="fas fa-plus mr-2"></i>Add Progress Entry
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-6 gap-3 sm:gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Date</label>
                        <input type="date" id="progressEntryDate" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <label for="progressEntryWeight" class="block text-sm font-medium text-gray-700 mb-1">Weight (lbs)</label>
                        <input type="number" id="progressEntryWeight" placeholder="150.0" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" step="0.1">
                    </div>
                    <div>
                        <label for="progressEntryWaist" class="block text-sm font-medium text-gray-700 mb-1">Waist (in)</label>
                        <input type="number" id="progressEntryWaist" placeholder="32.0" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" step="0.1">
                    </div>
                    <div>
                        <label for="progressEntryChest" class="block text-sm font-medium text-gray-700 mb-1">Chest (in)</label>
                        <input type="number" id="progressEntryChest" placeholder="38.0" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" step="0.1">
                    </div>
                    <div>
                        <label for="progressEntryHips" class="block text-sm font-medium text-gray-700 mb-1">Hips (in)</label>
                        <input type="number" id="progressEntryHips" placeholder="36.0" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" step="0.1">
                    </div>
                    <div>
                        <label for="progressEntryArms" class="block text-sm font-medium text-gray-700 mb-1">Arms (in)</label>
                        <input type="number" id="progressEntryArms" placeholder="13.0" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" step="0.1">
                    </div>
                </div>
                <div class="mb-4">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Notes (Optional)</label>
                    <textarea id="progressEntryNotes" placeholder="How are you feeling? Any observations..." rows="2" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500"></textarea>
                </div>
                <button onclick="saveProgressEntry()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-medium">
                    <i class="fas fa-save mr-2"></i>Save Entry
                </button>
            </div>

            <!-- Goal Setting -->
            <div class="bg-gradient-to-r from-indigo-50 to-purple-50 p-4 rounded-lg mb-6">
                <h3 class="text-lg font-bold text-gray-800 mb-3">
                    <i class="fas fa-target mr-2"></i>Set Weight Goal
                </h3>
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
                    <div>
                        <label for="targetWeight" class="block text-sm font-medium text-gray-700 mb-1">Target Weight (lbs)</label>
                        <input type="number" id="targetWeight" placeholder="150" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500" step="0.1">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Target Date</label>
                        <input type="date" id="targetDate" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500">
                    </div>
                    <div class="flex items-end">
                        <button onclick="setProgressGoal()" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-medium">
                            <i class="fas fa-bullseye mr-1"></i>Set Goal
                        </button>
                    </div>
                </div>
            </div>

            <!-- Progress Chart -->
            <div class="bg-gray-50 p-4 rounded-lg mb-6">
                <h3 class="text-lg font-bold text-gray-800 mb-4">
                    <i class="fas fa-weight mr-2"></i>Weight Progress Chart
                </h3>
                <div style="height: 300px; position: relative;">
                    <canvas id="progressWeightChart"></canvas>
                </div>
            </div>

            <!-- Macro Nutrition Progress -->
            <div class="bg-gradient-to-r from-green-50 to-blue-50 p-4 rounded-lg mb-6">
                <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center mb-4 gap-3 sm:gap-0">
                    <div class="flex-1">
                        <h3 class="text-lg font-bold text-gray-800">
                            <i class="fas fa-chart-bar mr-2"></i>Macro Nutrition Progress (Last 7 Days)
                        </h3>
                        <p class="text-xs text-gray-600 mt-1">
                            <i class="fas fa-info-circle mr-1"></i>Automatically tracks your daily macro intake from the Daily Macro Tracker above
                        </p>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2 sm:gap-2 w-full sm:w-auto">
                        <button onclick="refreshMacroProgress()" class="bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center justify-center sm:justify-start shadow-sm hover:shadow-md" title="Refresh macro progress data">
                            <i class="fas fa-sync-alt mr-2"></i>Refresh
                        </button>
                        <button onclick="clearMacroProgress()" class="bg-red-500 hover:bg-red-600 active:bg-red-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 flex items-center justify-center sm:justify-start shadow-sm hover:shadow-md" title="Clear all macro progress data">
                            <i class="fas fa-trash-alt mr-2"></i>Clear Data
                        </button>
                    </div>
                </div>
                
                <!-- Macro Stats Overview -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div class="bg-white p-4 rounded-lg text-center shadow-sm">
                        <div class="text-2xl font-bold text-red-600" id="avgProtein">0g</div>
                        <div class="text-sm text-red-700">Avg Protein</div>
                        <div class="text-xs text-red-600 mt-1" id="proteinTrend">No trend</div>
                    </div>
                    <div class="bg-white p-4 rounded-lg text-center shadow-sm">
                        <div class="text-2xl font-bold text-yellow-600" id="avgCarbs">0g</div>
                        <div class="text-sm text-yellow-700">Avg Carbs</div>
                        <div class="text-xs text-yellow-600 mt-1" id="carbsTrend">No trend</div>
                    </div>
                    <div class="bg-white p-4 rounded-lg text-center shadow-sm">
                        <div class="text-2xl font-bold text-green-600" id="avgFat">0g</div>
                        <div class="text-sm text-green-700">Avg Fat</div>
                        <div class="text-xs text-green-600 mt-1" id="fatTrend">No trend</div>
                    </div>
                </div>

                <!-- Macro Trend Charts -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <!-- Daily Macro Totals Chart -->
                    <div class="bg-white p-4 rounded-lg shadow-sm">
                        <h4 class="font-semibold text-gray-800 mb-3">Daily Macro Totals</h4>
                        <div style="height: 200px; position: relative;">
                            <canvas id="macroTotalsChart"></canvas>
                        </div>
                    </div>
                    
                    <!-- Macro Goals Achievement Chart -->
                    <div class="bg-white p-4 rounded-lg shadow-sm">
                        <h4 class="font-semibold text-gray-800 mb-3">Goal Achievement %</h4>
                        <div style="height: 200px; position: relative;">
                            <canvas id="macroGoalsChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- Macro Progress Table -->
                <div class="mt-6 bg-white rounded-lg shadow-sm overflow-hidden">
                    <h4 class="font-semibold text-gray-800 p-4 border-b">Recent Daily Macro Summary</h4>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm">
                            <thead class="bg-gray-50">
                                <tr>
                                    <th class="text-left p-3 font-medium text-gray-700">Date</th>
                                    <th class="text-center p-3 font-medium text-gray-700">Calories</th>
                                    <th class="text-center p-3 font-medium text-red-700">Protein</th>
                                    <th class="text-center p-3 font-medium text-yellow-700">Carbs</th>
                                    <th class="text-center p-3 font-medium text-green-700">Fat</th>
                                    <th class="text-center p-3 font-medium text-gray-700">Goal Met</th>
                                </tr>
                            </thead>
                            <tbody id="macroHistoryTable">
                                <tr>
                                    <td colspan="6" class="text-center py-8 text-gray-500">
                                        <i class="fas fa-chart-line text-2xl mb-2"></i>
                                        <p>Start tracking daily macros to see your progress here!</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Progress Timeline -->
            <div class="bg-gray-50 p-4 rounded-lg mb-6">
                <h3 class="text-lg font-bold text-gray-800 mb-4">
                    <i class="fas fa-history mr-2"></i>Recent Entries
                </h3>
                <div class="max-h-64 overflow-y-auto" id="progressTimeline">
                    <div class="text-center text-gray-500 py-8">
                        <i class="fas fa-chart-line text-4xl mb-4"></i>
                        <p>No progress entries yet. Add your first entry above to start tracking!</p>
                    </div>
                </div>
            </div>

            <!-- Latest Measurements -->
            <div class="bg-gray-50 p-4 rounded-lg">
                <h3 class="text-lg font-bold text-gray-800 mb-4">
                    <i class="fas fa-ruler mr-2"></i>Latest Measurements
                </h3>
                <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
                    <div class="text-center p-3 bg-white rounded-lg">
                        <div class="text-sm font-medium text-gray-600">Waist</div>
                        <div class="text-lg font-bold text-gray-800" id="latestWaist">--</div>
                        <div class="text-xs text-gray-500 unit-label">inches</div>
                    </div>
                    <div class="text-center p-3 bg-white rounded-lg">
                        <div class="text-sm font-medium text-gray-600">Chest</div>
                        <div class="text-lg font-bold text-gray-800" id="latestChest">--</div>
                        <div class="text-xs text-gray-500 unit-label">inches</div>
                    </div>
                    <div class="text-center p-3 bg-white rounded-lg">
                        <div class="text-sm font-medium text-gray-600">Hips</div>
                        <div class="text-lg font-bold text-gray-800" id="latestHips">--</div>
                        <div class="text-xs text-gray-500 unit-label">inches</div>
                    </div>
                    <div class="text-center p-3 bg-white rounded-lg">
                        <div class="text-sm font-medium text-gray-600">Arms</div>
                        <div class="text-lg font-bold text-gray-800" id="latestArms">--</div>
                        <div class="text-xs text-gray-500 unit-label">inches</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- End of App Section -->



    <script>
        // Configuration
        const PRODUCTION_MODE = window.location.hostname !== 'localhost' && !window.location.hostname.includes('127.0.0.1');
        
        // Enhanced logging function
        function debugLog(message, ...args) {
            if (!PRODUCTION_MODE) {
                console.log(message, ...args);
            }
        }
        
        // Manual Data Storage Test Function (for UI button)

        

        
        // Database API Functions for Permanent Storage
        let currentUserEmail = null;
        
        // Custom section variables (declared early to prevent ReferenceErrors)
        let customSectionEnabled = false; // Flag to track if custom section is enabled
        let customSectionName = 'Custom'; // Default name for backward compatibility

        // Get current user email for database operations
        function getCurrentUserEmail() {
            if (currentUserEmail) {
                // Using cached user email
                return currentUserEmail;
            }
            
            // Try to get from Supabase auth
            try {
                if (window.authWrapper && window.authWrapper.currentUser) {
                    currentUserEmail = window.authWrapper.currentUser.email;
                    // Email from Supabase auth
                    return currentUserEmail;
                }
            } catch (error) {
                console.warn('Could not get email from Supabase authWrapper:', error);
            }

            // Try to get from direct Supabase client (sync method)
            try {
                if (window.supabaseClient) {
                    // Note: This is async, but we'll handle it in the calling function
                    // Supabase client available
                }
            } catch (error) {
                console.warn('Could not access Supabase client:', error);
            }
            
            // Fallback to localStorage with enhanced JSON parsing
            const userInfo = localStorage.getItem('user_info');
            if (userInfo) {
                const safeJSON = window.safeGetEnhancedDB ? window.safeGetEnhancedDB() : null;
                const parsed = (safeJSON && safeJSON.enhancedJSONParse) ? 
                    safeJSON.enhancedJSONParse(userInfo, {}) :
                    (() => {
                        try {
                            return JSON.parse(userInfo);
                        } catch (error) {
                            console.warn('Error parsing localStorage user info:', error);
                            return {};
                        }
                    })();
                
                if (parsed.email) {
                    currentUserEmail = parsed.email;
                    // Email from localStorage
                    return currentUserEmail;
                }
            }
            
            console.log('⚠️ Using fallback email for development');
            return 'test@example.com'; // Use our test data email
        }
        
        // Helper function to get current user ID from Supabase Auth
        async function getCurrentUserId() {
            try {
                if (window.supabaseClient) {
                    const { data: { user } } = await window.supabaseClient.auth.getUser();
                    if (user) {
                        // User ID from Supabase auth
                        return user.id;
                    }
                }
            } catch (error) {
                console.warn('Could not get user ID from Supabase:', error);
            }
            
            console.log('⚠️ No user ID available, using fallback');
            return null;
        }
        
        // ====================================================================
        // NEW SCHEMA AUTHENTICATION FUNCTIONS (ADDITIVE - DOESN'T BREAK EXISTING)
        // ====================================================================
        
        // Get current user context for new schema (authenticated user or anonymous profile)
        async function getCurrentUserContext() {
            try {
                if (window.supabaseClient) {
                    const { data: { user }, error } = await window.supabaseClient.auth.getUser();
                    
                    if (user && !error) {
                        // Authenticated user
                        return {
                            type: 'authenticated',
                            user_id: user.id,
                            email: user.email,
                            anon_profile_id: null
                        };
                    }
                    
                    // Try to get anonymous profile from JWT claims
                    const session = await window.supabaseClient.auth.getSession();
                    if (session.data?.session?.access_token) {
                        try {
                            const payload = JSON.parse(atob(session.data.session.access_token.split('.')[1]));
                            const anonProfileId = payload.anon_profile_id;
                            
                            if (anonProfileId) {
                                return {
                                    type: 'anonymous',
                                    user_id: null,
                                    email: null,
                                    anon_profile_id: anonProfileId
                                };
                            }
                        } catch (jwtError) {
                            console.warn('⚠️ Could not parse JWT for anon_profile_id:', jwtError);
                        }
                    }
                }
                
                // Create new anonymous profile if none exists
                return await createAnonymousProfile();
                
            } catch (error) {
                console.error('❌ Error getting user context:', error);
                
                // Fallback to localStorage-based anonymous session
                return getLocalAnonymousProfile();
            }
        }
        
        // Create new anonymous profile in database
        async function createAnonymousProfile() {
            try {
                if (window.supabaseClient) {
                    const { data, error } = await window.supabaseClient
                        .from('anonymous_profiles')
                        .insert({
                            display_name: 'Anonymous User',
                            expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days
                        })
                        .select()
                        .single();
                    
                    if (!error && data) {
                        // Store in localStorage for future sessions
                        localStorage.setItem('anon_profile_context', JSON.stringify({
                            type: 'anonymous',
                            user_id: null,
                            email: null,
                            anon_profile_id: data.id,
                            created_at: new Date().toISOString()
                        }));
                        
                        console.log('✅ Created new anonymous profile:', data.id);
                        return {
                            type: 'anonymous',
                            user_id: null,
                            email: null,
                            anon_profile_id: data.id
                        };
                    }
                }
            } catch (error) {
                console.error('❌ Error creating anonymous profile:', error);
            }
            
            // Fallback to local anonymous session
            return getLocalAnonymousProfile();
        }
        
        // Get or create localStorage-based anonymous profile
        function getLocalAnonymousProfile() {
            let localContext = localStorage.getItem('anon_profile_context');
            
            if (localContext) {
                try {
                    const parsed = JSON.parse(localContext);
                    
                    // Check if context is still valid (not expired)
                    const createdAt = new Date(parsed.created_at);
                    const now = new Date();
                    const daysDiff = (now - createdAt) / (1000 * 60 * 60 * 24);
                    
                    if (daysDiff < 30) { // Valid for 30 days
                        console.log('📱 Using existing local anonymous profile');
                        return parsed;
                    }
                } catch (error) {
                    console.warn('⚠️ Error parsing local anonymous context:', error);
                }
            }
            
            // Create new local anonymous profile
            const newContext = {
                type: 'anonymous',
                user_id: null,
                email: null,
                anon_profile_id: 'local_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                created_at: new Date().toISOString()
            };
            
            localStorage.setItem('anon_profile_context', JSON.stringify(newContext));
            console.log('📱 Created new local anonymous profile:', newContext.anon_profile_id);
            return newContext;
        }
        
        // Get database identifier for current user (user_id or anon_profile_id)
        async function getCurrentDatabaseIdentifier() {
            try {
                const context = await getCurrentUserContext();
                if (context.type === 'authenticated') {
                    return { user_id: context.user_id, anon_profile_id: null };
                } else {
                    return { user_id: null, anon_profile_id: context.anon_profile_id };
                }
            } catch (error) {
                console.error('❌ Error getting database identifier:', error);
                const fallback = getLocalAnonymousProfile();
                return { user_id: null, anon_profile_id: fallback.anon_profile_id };
            }
        }

        // Safe fetch function to avoid security middleware binding issues
        async function safeFetch(url, options = {}) {
            // Always use the original fetch for database API calls from authenticated users
            if (url.includes('tables/')) {
                // Check if user is authenticated
                const isAuthenticated = (window.authWrapper && window.authWrapper.currentUser) || 
                                       localStorage.getItem('authenticated') === 'true';
                if (isAuthenticated) {
                    console.log('🔓 Bypassing security middleware for authenticated user database call:', url);
                    
                    // Temporarily disable security middleware for this call
                    const originalFetch = window.originalFetchStored || fetch;
                    
                    // Make the API call directly
                    try {
                        const result = await originalFetch.call(window, url, options);
                        console.log('📡 Direct API call result:', result.status);
                        return result;
                    } catch (error) {
                        console.error('❌ Direct API call error:', error);
                        throw error;
                    }
                }
            }
            
            // Use the original fetch function stored before security middleware activation
            const fetchFunction = window.originalFetchStored || window.fetch;
            return await fetchFunction.call(window, url, options);
        }

        // Function to check if RESTful API endpoints are available
        let apiEndpointsChecked = false;
        let apiEndpointsAvailable = false;
        
        async function checkApiEndpoints() {
            if (apiEndpointsChecked) {
                return apiEndpointsAvailable;
            }
            
            try {
                // Checking RESTful API availability
                
                // Use apiCall instead of safeFetch to test the endpoint
                // This will use the proper RESTful Table API handling
                const testResponse = await apiCall('tables/user_profiles?limit=1');
                
                if (testResponse && (testResponse.data !== undefined || Array.isArray(testResponse))) {
                    console.log('✅ RESTful API endpoints are available');
                    apiEndpointsAvailable = true;
                } else {
                    console.log('⚠️ RESTful API endpoints not available - invalid response format');
                    apiEndpointsAvailable = false;
                }
            } catch (error) {
                console.log('⚠️ RESTful API endpoints not available (error):', error.message);
                // Check if it's specifically a 404 error with HTML response
                if (error.message && error.message.includes('404') && error.message.includes('<!DOCTYPE html>')) {
                    // RESTful API endpoints not available
                }
                apiEndpointsAvailable = false;
            }
            
            apiEndpointsChecked = true;
            return apiEndpointsAvailable;
        }

        // Supabase-first API helper function
        async function apiCall(endpoint, method = 'GET', data = null) {
            console.log('🌐 API Call:', { endpoint, method, hasData: !!data });
            
            try {
                // Handle table operations with Supabase directly
                if (endpoint.startsWith('tables/')) {
                    return await handleSupabaseTableCall(endpoint, method, data);
                }
                
                // Handle non-table endpoints (fallback to fetch)
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    }
                };
                
                if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
                    options.body = JSON.stringify(data);
                }
                
                const response = await fetch(endpoint, options);
                
                if (!response.ok) {
                    throw new Error(`API call failed: ${response.status}`);
                }
                
                if (method === 'DELETE') {
                    return { success: true };
                }
                
                return await response.json();
                
            } catch (error) {
                console.error('API call error:', error);
                throw error;
            }
        }

        // Handle Supabase table operations
        async function handleSupabaseTableCall(endpoint, method, data) {
            if (!window.supabaseClient) {
                throw new Error('Supabase client not available');
            }

            // Validate data parameter for operations that require it
            if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && (!data || typeof data !== 'object')) {
                console.error('❌ Invalid data parameter for operation:', { method, data, endpoint });
                throw new Error(`Data is required and must be an object for ${method} operations`);
            }

            const parts = endpoint.split('/');
            const tableName = parts[1];
            const recordId = parts[2];
            const queryParams = new URLSearchParams(endpoint.split('?')[1] || '');
            
            console.log('📊 Supabase operation:', { tableName, method, recordId, hasData: !!data });

            try {
                switch (method) {
                    case 'GET':
                        let query = window.supabaseClient.from(tableName).select('*');
                        
                        // Handle search parameter using safe helper
                        const search = queryParams.get('search');
                        if (search) {
                            // Processing search query
                            
                            // ALWAYS use safe fallback logic to prevent PGRST100 errors
                            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
                            
                            if (emailRegex.test(search)) {
                                // Email - use exact match to avoid @ symbol issues
                                console.log(`📧 Email detected: using exact match for '${search}'`);
                                query = query.eq('user_email', search);
                            } else if (uuidRegex.test(search)) {
                                // UUID - use exact match
                                console.log(`🆔 UUID detected: using exact match for '${search}'`);
                                query = query.eq('user_id', search);
                            } else {
                                // Text - use simple ILIKE
                                console.log(`📝 Text detected: using ILIKE for '${search}'`);
                                query = query.ilike('user_email', `%${search}%`);
                            }
                        }
                        
                        // Handle pagination and sorting using safe helpers
                        if (window.SupabaseQueryHelper) {
                            const limit = queryParams.get('limit');
                            const sort = queryParams.get('sort');
                            query = window.SupabaseQueryHelper.applyPagination(query, limit, 0);
                            query = window.SupabaseQueryHelper.applySorting(query, sort);
                        } else {
                            // Fallback to direct methods
                            const limit = queryParams.get('limit');
                            if (limit) {
                                query = query.limit(parseInt(limit));
                            }
                            const sort = queryParams.get('sort');
                            if (sort) {
                                query = query.order(sort, { ascending: false });
                            }
                        }
                        
                        // Get single record by ID
                        if (recordId) {
                            query = query.eq('id', recordId).single();
                            const { data, error } = await query;
                            if (error) throw error;
                            return data;
                        }
                        
                        const { data, error } = await query;
                        if (error) throw error;
                        
                        return { data, total: data.length };

                    case 'POST':
                        const { data: newData, error: postError } = await window.supabaseClient
                            .from(tableName)
                            .insert(data)
                            .select()
                            .single();
                        
                        if (postError) throw postError;
                        return newData;

                    case 'PUT':
                    case 'PATCH':
                        const { data: updatedData, error: updateError } = await window.supabaseClient
                            .from(tableName)
                            .update(data)
                            .eq('id', recordId)
                            .select()
                            .single();
                        
                        if (updateError) throw updateError;
                        return updatedData;

                    case 'DELETE':
                        const { error: deleteError } = await window.supabaseClient
                            .from(tableName)
                            .delete()
                            .eq('id', recordId);
                        
                        if (deleteError) throw deleteError;
                        return { success: true };

                    default:
                        throw new Error(`Unsupported method: ${method}`);
                }
            } catch (error) {
                console.error('Supabase operation error:', error);
                throw error;
            }
        }




        // Manual data refresh function (call from console)
        window.refreshUserData = async function() {
            try {
                console.log('🔄 Manually refreshing user data...');
                await loadUserDataAfterAuth();
                console.log('✅ Manual data refresh completed');
            } catch (error) {
                console.error('❌ Manual data refresh failed:', error);
            }
        };

        // Test Supabase connection (call from console)
        window.testSupabaseConnection = async function() {
            try {
                console.log('🧪 Testing Supabase connection...');
                
                if (!window.supabaseClient) {
                    console.error('❌ Supabase client not available');
                    return false;
                }
                
                // Test basic connection
                const { data, error } = await window.supabaseClient
                    .from('user_profiles')
                    .select('id, user_name, user_email')
                    .limit(1);
                
                if (error) {
                    console.error('❌ Supabase connection test failed:', error);
                    return false;
                }
                
                console.log('✅ Supabase connection successful:', data);
                return true;
            } catch (error) {
                console.error('❌ Supabase connection error:', error);
                return false;
            }
        };



        // Migration function for existing users (call from console)
        window.migrateLocalStorageToDatabase = async function() {
            try {
                console.log('🔄 Starting localStorage to database migration...');
                
                // Check if user is authenticated
                const userEmail = getCurrentUserEmail();
                if (!userEmail || userEmail === 'anonymous@user.local') {
                    console.error('❌ User not authenticated - cannot migrate data');
                    return { error: 'User not authenticated' };
                }
                
                console.log('📧 Migrating data for user:', userEmail);
                
                // Migrate meals from localStorage
                const storedMeals = localStorage.getItem('meals');
                if (storedMeals) {
                    const mealsArray = JSON.parse(storedMeals);
                    console.log('🍽️ Found', mealsArray.length, 'meals in localStorage');
                    
                    if (mealsArray.length > 0) {
                        const result = await saveDailyMeals(mealsArray);
                        console.log('✅ Meals migration result:', result);
                    }
                }
                
                // Migrate user profile from localStorage
                const storedProfile = localStorage.getItem('userProfile');
                if (storedProfile) {
                    const profileData = JSON.parse(storedProfile);
                    console.log('👤 Found user profile in localStorage:', profileData);
                    
                    const profileResult = await saveUserProfile(profileData);
                    console.log('✅ Profile migration result:', profileResult);
                }
                
                // Migrate targets if available
                const storedTargets = localStorage.getItem('dailyTargets');
                if (storedTargets && storedTargets !== 'undefined') {
                    const targets = JSON.parse(storedTargets);
                    console.log('🎯 Found daily targets in localStorage:', targets);
                    
                    const userInfo = localStorage.getItem('user_info');
                    const userName = userInfo ? JSON.parse(userInfo).name : '';
                    
                    const targetResult = await saveUserProfile({
                        name: userName,
                        unitSystem: currentUnitSystem || 'imperial',
                        dailyTargets: targets
                    });
                    console.log('✅ Targets migration result:', targetResult);
                }
                
                console.log('🎉 Migration completed successfully!');
                console.log('🔄 Refreshing user data from database...');
                
                // Reload data from database to verify
                await loadUserDataAfterAuth();
                
                return { 
                    success: true, 
                    message: 'Data migrated successfully from localStorage to database' 
                };
                
            } catch (error) {
                console.error('❌ Migration failed:', error);
                return { error: error.message };
            }
        };

        // Load User Data After Authentication
        async function loadUserDataAfterAuth() {
            console.log('🔄 Loading user data from dedicated tables...');
            
            try {
                // Load user preferences from dedicated table
                const preferences = await loadUserPreferences();
                if (preferences) {
                    console.log('✅ User preferences loaded:', preferences);
                    
                    // Update unit system if available
                    if (preferences.unit_system) {
                        currentUnitSystem = preferences.unit_system;
                        updateUnitLabels();
                        console.log('🔧 Unit system set to:', currentUnitSystem);
                    }
                }
                
                // Load daily targets from dedicated table
                const targets = await loadDailyTargets();
                if (targets) {
                    dailyTargets = {
                        calories: targets.daily_calories,
                        protein: targets.daily_protein,
                        carbs: targets.daily_carbs,
                        fat: targets.daily_fat
                    };
                    console.log('✅ Daily targets loaded from database:', dailyTargets);
                    
                    // Update display
                    if (document.getElementById('dailyCalories')) {
                        document.getElementById('dailyCalories').textContent = targets.daily_calories.toLocaleString();
                        document.getElementById('proteinAmount').textContent = targets.daily_protein + 'g';
                        document.getElementById('carbsAmount').textContent = targets.daily_carbs + 'g';
                        document.getElementById('fatAmount').textContent = targets.daily_fat + 'g';
                    }
                    
                    updateMacroCharts();
                } else {
                    // Fallback to localStorage if database loading failed
                    console.log('📱 Database targets not found, checking localStorage fallback...');
                    const savedTargets = localStorage.getItem('dailyTargets');
                    if (savedTargets && savedTargets !== 'null') {
                        try {
                            const parsed = JSON.parse(savedTargets);
                            // Ensure all required fields are present and valid
                            if (parsed && parsed.calories > 0 && parsed.protein > 0) {
                                dailyTargets = {
                                    calories: parsed.calories,
                                    protein: parsed.protein,
                                    carbs: parsed.carbs,
                                    fat: parsed.fat
                                };
                                console.log('✅ Daily targets loaded from localStorage:', dailyTargets);
                                
                                // Update display
                                if (document.getElementById('dailyCalories')) {
                                    document.getElementById('dailyCalories').textContent = dailyTargets.calories.toLocaleString();
                                    document.getElementById('proteinAmount').textContent = dailyTargets.protein + 'g';
                                    document.getElementById('carbsAmount').textContent = dailyTargets.carbs + 'g';
                                    document.getElementById('fatAmount').textContent = dailyTargets.fat + 'g';
                                }
                                
                                updateMacroCharts();
                            } else {
                                console.log('ℹ️ localStorage targets incomplete, using defaults');
                            }
                        } catch (error) {
                            console.warn('⚠️ Error parsing localStorage targets:', error);
                        }
                    } else {
                        console.log('ℹ️ No saved targets found, using default values');
                    }
                }
                
                // Always ensure display is synchronized with current dailyTargets values
                // This handles cases where defaults are used or saved data doesn't exist
                ensureDisplaySync();
                
                // Load calculation history and auto-populate personal info form
                await loadAndPopulatePersonalInfo();
                
                // Load today's meals from database (overrides localStorage)
                const todayMeals = await loadDailyMeals();
                if (todayMeals && todayMeals.length > 0) {
                    console.log('✅ Today\'s meals loaded from database:', todayMeals.length, 'meals');
                    meals = todayMeals;
                    
                    // Recalculate current intake from loaded meals
                    currentIntake = { protein: 0, carbs: 0, fat: 0 };
                    meals.forEach(meal => {
                        currentIntake.protein += meal.protein || 0;
                        currentIntake.carbs += meal.carbs || 0;
                        currentIntake.fat += meal.fat || 0;
                    });
                    
                    // Update all displays and save to localStorage for offline access
                    updateMealsList();
                    updateProgress();
                    updateMacroCharts();
                    updateCalorieDisplay();
                    
                    // Sync localStorage with database data
                    localStorage.setItem('meals', JSON.stringify(meals));
                    localStorage.setItem('currentIntake', JSON.stringify(currentIntake));
                    localStorage.setItem('lastSaved', new Date().toDateString());
                    
                    console.log('✅ Meals loaded from database, intake calculated:', currentIntake);
                    console.log('💾 Database meals synced to localStorage for offline access');
                } else {
                    console.log('ℹ️ No meals found in database for today');
                    // Check if we have localStorage meals that weren't uploaded yet
                    const localMeals = localStorage.getItem('meals');
                    if (localMeals) {
                        const parsedMeals = JSON.parse(localMeals);
                        if (parsedMeals.length > 0) {
                            console.log('📱 Found localStorage meals not in database:', parsedMeals.length, 'meals');
                            meals = parsedMeals;
                            
                            // Recalculate intake from localStorage meals
                            currentIntake = { protein: 0, carbs: 0, fat: 0 };
                            meals.forEach(meal => {
                                currentIntake.protein += meal.protein || 0;
                                currentIntake.carbs += meal.carbs || 0;
                                currentIntake.fat += meal.fat || 0;
                            });
                            
                            // Update displays
                            updateMealsList();
                            updateProgress();
                            updateMacroCharts();
                            updateCalorieDisplay();
                            
                            console.log('✅ Using localStorage meals, intake calculated:', currentIntake);
                        }
                    }
                }
                
                // Load progress entries for charts
                await loadProgressData();
                
                console.log('🎉 All user data loaded successfully!');
                
            } catch (error) {
                console.error('❌ Error loading user data:', error);
                showNotification('warning', 'Data Loading', 'Some data could not be loaded. You can still use the app normally.');
            }
        }

        // User Profile API - Updated for UUID-based schema
        async function saveUserProfile(profileData) {
            try {
                console.log('💾 Saving user profile with UUID-based authentication...');
                
                // Get user identifier (UUID-based)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    throw new Error('No valid user identifier available');
                }
                
                // Save user preferences to user_preferences table
                const preferencesData = await window.authHelper.createInsertPayload({
                    unit_system: profileData.unitSystem || 'imperial',
                    theme: 'light', // Default theme
                    notifications_enabled: true,
                    show_tutorials: true,
                    custom_preferences: {}
                });
                
                // Save/update user preferences
                const { data: prefsResult, error: prefsError } = await window.supabaseClient
                    .from('user_preferences')
                    .upsert(preferencesData, { 
                        onConflict: identifier.user_id ? 'user_id' : 'anon_profile_id'
                    })
                    .select();
                
                if (prefsError) {
                    console.warn('⚠️ User preferences save failed:', prefsError.message);
                }
                
                // Save daily targets to daily_targets table if provided
                let targetsResult = null;
                if (profileData.dailyTargets) {
                    const targets = typeof profileData.dailyTargets === 'string' 
                        ? (window.JSON?.safeParse ? 
                            window.JSON.safeParse(profileData.dailyTargets, {}) : 
                            (() => {
                                try {
                                    return JSON.parse(profileData.dailyTargets);
                                } catch (error) {
                                    console.warn('Error parsing daily targets:', error);
                                    return {};
                                }
                            })()
                          )
                        : profileData.dailyTargets;
                    
                    const targetsData = await window.authHelper.createInsertPayload({
                        daily_calories: parseInt(targets.calories) || 2000,
                        daily_protein: parseInt(targets.protein) || 150,
                        daily_carbs: parseInt(targets.carbs) || 250,
                        daily_fat: parseInt(targets.fat) || 67
                    });
                    
                    const { data: targetsRes, error: targetsError } = await window.supabaseClient
                        .from('daily_targets')
                        .upsert(targetsData, { 
                            onConflict: identifier.user_id ? 'user_id' : 'anon_profile_id'
                        })
                        .select();
                    
                    if (targetsError) {
                        console.warn('⚠️ Daily targets save failed:', targetsError.message);
                    } else {
                        targetsResult = targetsRes;
                    }
                }
                
                // Also save to localStorage for offline access
                localStorage.setItem('userProfile', JSON.stringify(profileData));
                
                console.log('✅ Profile saved to UUID-based schema successfully');
                return {
                    preferences: prefsResult,
                    dailyTargets: targetsResult,
                    success: true
                };
                
            } catch (error) {
                console.error('❌ Error saving user profile:', error);
                // Fallback to localStorage
                localStorage.setItem('userProfile', JSON.stringify(profileData));
                return { fallback: true, error: error.message };
            }
        }

        async function loadUserProfile() {
            const userEmail = getCurrentUserEmail();
            
            try {
                // Try Supabase first (for cross-device sync)
                if (window.supabaseClient) {
                    console.log('📡 Loading profile from Supabase...');
                    try {
                        // Check authentication status first
                        const { data: { user }, error: authError } = await window.supabaseClient.auth.getUser();
                        let lookupEmail = userEmail;
                        
                        // If user is authenticated, use their email or anonymous ID
                        if (user) {
                            lookupEmail = user.email || `anon_${user.id}`;
                        }
                        
                        const { data, error } = await window.supabaseClient
                            .from('user_profiles')
                            .select('*')
                            .eq('user_email', lookupEmail)
                            .maybeSingle();
                        
                        if (!error && data) {
                            console.log('✅ Profile loaded from Supabase:', data);
                            
                            // Get additional data from localStorage (unitSystem, dailyTargets)
                            const stored = localStorage.getItem('userProfile');
                            const localData = stored ? JSON.parse(stored) : {};
                            
                            return {
                                name: data.name || 'User',
                                unitSystem: localData.unitSystem || 'imperial',
                                dailyTargets: localData.dailyTargets || { calories: 2000, protein: 150, carbs: 250, fat: 67 }
                            };
                        } else if (error) {
                            console.warn('⚠️ Supabase profile load failed:', error.message);
                        }
                    } catch (error) {
                        console.warn('⚠️ Supabase profile load error:', error);
                    }
                }
                
                // Fallback to localStorage
                console.log('📱 Loading profile from localStorage fallback...');
                const stored = localStorage.getItem('userProfile');
                return stored ? JSON.parse(stored) : null;
            } catch (error) {
                console.error('Error loading user profile:', error);
                // Final fallback to localStorage
                const stored = localStorage.getItem('userProfile');
                return stored ? JSON.parse(stored) : null;
            }
        }

        // Daily Meals API - UUID-based with authHelper.js
        async function saveDailyMeals(meals, date = null) {
            const mealDate = date || new Date().toISOString().split('T')[0];
            
            console.log('💾 Saving daily meals to database...', {
                mealDate: mealDate,
                mealCount: meals.length
            });

            try {
                if (!window.supabaseClient) {
                    console.log('ℹ️ No database connection available for daily meals save');
                    localStorage.setItem('meals', JSON.stringify(meals));
                    localStorage.setItem('lastSaved', mealDate);
                    return { fallback: true };
                }

                // Get user identifier (invite-only system - must be authenticated)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.is_authenticated || !identifier.user_id) {
                    console.warn('User not authenticated - redirecting to login');
                    window.authHelper.redirectToLogin();
                    throw new Error('Authentication required to save meals');
                }

                console.info('💾 Saving meals for authenticated user:', identifier.user_id);

                // Clear existing meals for this date (authenticated user only)
                const deleteQuery = window.supabaseClient
                    .from('daily_meals')
                    .delete()
                    .eq('meal_date', mealDate)
                    .eq('user_id', identifier.user_id);

                const { error: deleteError } = await deleteQuery;
                
                if (deleteError) {
                    console.warn('⚠️ Failed to clear existing meals:', deleteError.message);
                }

                // Save new meals to Supabase using UUID-based schema
                const supabaseResults = [];
                for (const meal of meals) {
                    const mealData = await window.authHelper.createInsertPayload({
                        meal_date: mealDate,
                        meal_name: meal.name,
                        calories: Math.round(meal.calories || 0), // INTEGER type
                        protein: Math.round(meal.protein || 0), // INTEGER type
                        carbs: Math.round(meal.carbs || 0), // INTEGER type
                        fat: Math.round(meal.fat || 0), // INTEGER type
                        meal_uuid: meal.id ? meal.id.toString() : crypto.randomUUID(),
                        timestamp: new Date().toISOString()
                    });

                    const { data: inserted, error } = await window.supabaseClient
                        .from('daily_meals')
                        .insert(mealData)
                        .select();

                    if (error) {
                        console.warn('⚠️ Supabase meal insert failed:', error.message);
                        throw error;
                    } else {
                        supabaseResults.push(inserted[0]);
                        console.log('✅ Meal saved to Supabase:', inserted[0]);
                    }
                }

                console.log(`✅ ${supabaseResults.length} meals saved to Supabase successfully`);

                // Also save to localStorage for offline access
                localStorage.setItem('meals', JSON.stringify(meals));
                localStorage.setItem('lastSaved', mealDate);

                return { success: true, count: meals.length, supabase: supabaseResults.length };
                
            } catch (error) {
                console.error('❌ Failed to save daily meals to database:', error);
                
                // Final fallback to localStorage
                localStorage.setItem('meals', JSON.stringify(meals));
                localStorage.setItem('lastSaved', mealDate);
                return { fallback: true, error: error.message };
            }
        }

        async function loadDailyMeals(date = null) {
            if (!window.supabaseClient) {
                console.log('ℹ️ No database connection available, using localStorage for daily meals');
                const stored = localStorage.getItem('meals');
                return stored ? JSON.parse(stored) : [];
            }

            const mealDate = date || new Date().toISOString().split('T')[0];
            console.log('📡 Loading daily meals from database...');
            
            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    console.log('ℹ️ No valid user identifier available, using localStorage');
                    const stored = localStorage.getItem('meals');
                    return stored ? JSON.parse(stored) : [];
                }

                console.log('📡 Using UUID-based authentication to load meals...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Query meals for this user and date
                const query = window.supabaseClient
                    .from('daily_meals')
                    .select('*')
                    .eq('meal_date', mealDate);

                // Apply user filter based on auth status
                if (identifier.user_id) {
                    query.eq('user_id', identifier.user_id);
                } else if (identifier.anon_profile_id) {
                    query.eq('anon_profile_id', identifier.anon_profile_id);
                }

                const { data, error } = await query.order('created_at', { ascending: true });
                
                if (error) {
                    console.warn('⚠️ Supabase daily meals load error:', error.message);
                    throw error;
                }

                if (data && data.length > 0) {
                    console.log(`✅ Loaded ${data.length} daily meals from Supabase for ${mealDate}`);
                    return data.map((meal, index) => ({
                        id: meal.id || Date.now() + index,
                        name: meal.meal_name,
                        calories: meal.calories,
                        protein: meal.protein,
                        carbs: meal.carbs,
                        fat: meal.fat
                    }));
                }

                // No meals found in database
                console.log('📱 No database meals found, falling back to localStorage...');
                const stored = localStorage.getItem('meals');
                return stored ? JSON.parse(stored) : [];
                
            } catch (error) {
                console.error('❌ Failed to load daily meals from database:', error);
                
                // Final fallback to localStorage
                console.log('📱 Falling back to localStorage...');
                const stored = localStorage.getItem('meals');
                return stored ? JSON.parse(stored) : [];
            }
        }

        // Progress Entries API
        // Progress Tracker API with Supabase Integration
        async function saveProgressEntryToDB(entry) {
            if (!window.supabaseClient && !window.apiCall) {
                console.log('ℹ️ No database connection available for progress entry save');
                return { fallback: true };
            }

            console.log('💾 Saving progress entry to database...');
            
            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    throw new Error('No valid user identifier available');
                }

                console.log('💾 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Check if progress entry exists for this date
                const queryFilter = await window.authHelper.getUserQueryFilter();
                const existingQuery = window.supabaseClient
                    .from('progress_entries')
                    .select('*')
                    .eq('date', entry.date);

                // Apply user filter based on auth status
                if (identifier.user_id) {
                    existingQuery.eq('user_id', identifier.user_id);
                } else if (identifier.anon_profile_id) {
                    existingQuery.eq('anon_profile_id', identifier.anon_profile_id);
                }

                const { data: existing, error: selectError } = await existingQuery.maybeSingle();

                // Prepare data using authHelper
                const progressData = await window.authHelper.createInsertPayload({
                    date: entry.date,
                    weight_kg: entry.weight,
                    waist_cm: entry.measurements?.waist || null,
                    chest_cm: entry.measurements?.chest || null,
                    hips_cm: entry.measurements?.hips || null,
                    arms_cm: entry.measurements?.arms || null,
                    notes: entry.notes || '',
                    entry_uuid: entry.id.toString()
                });

                if (existing && !selectError) {
                    // Update existing progress entry using upsert
                    const { data: updateData, error } = await window.supabaseClient
                        .from('progress_entries')
                        .upsert(progressData, { 
                            onConflict: identifier.user_id ? 'user_id,date' : 'anon_profile_id,date'
                        })
                        .select();
                    
                    if (error) {
                        console.warn('⚠️ Supabase progress entry update failed:', error.message);
                        throw error;
                    }
                    console.log('✅ Progress entry updated in Supabase:', updateData);
                    return updateData;
                } else {
                    // Create new progress entry
                    const { data: insertData, error } = await window.supabaseClient
                        .from('progress_entries')
                        .insert(progressData)
                        .select();
                    
                    if (error) {
                        console.warn('⚠️ Supabase progress entry insert failed:', error.message);
                        throw error;
                    }
                    console.log('✅ Progress entry created in Supabase:', insertData);
                    return insertData;
                }
                
            } catch (error) {
                console.warn('⚠️ Supabase save failed, trying RESTful API fallback:', error.message);
                
                // Fallback to RESTful API if Supabase fails
                if (window.apiCall) {
                    try {
                        console.log('📡 Using RESTful API for progress entry save...');
                        
                        // Get user email for RESTful API
                        const userEmail = getCurrentUserEmail();
                        
                        // Prepare data for RESTful API
                        const apiProgressData = {
                            email: userEmail,
                            date: entry.date,
                            weight_kg: entry.weight,
                            waist_cm: entry.measurements?.waist || null,
                            chest_cm: entry.measurements?.chest || null,
                            hips_cm: entry.measurements?.hips || null,
                            arms_cm: entry.measurements?.arms || null,
                            notes: entry.notes || '',
                            entry_uuid: entry.id.toString()
                        };
                        
                        // Check if RESTful API endpoints are available first
                        const apiAvailable = await checkApiEndpoints();
                        if (!apiAvailable) {
                            console.log('⚠️ RESTful API endpoints not available - skipping progress entry RESTful API fallback');
                            return { fallback: true };
                        }
                        
                        // Check if entry exists for this date using direct Supabase query
                        try {
                            // Checking existing progress entries
                            let query = window.supabaseClient.from('progress_entries').select('*');
                            if (window.SupabaseQueryHelper) {
                                query = window.SupabaseQueryHelper.applySearchFilter(query, userEmail, 'progress_entries');
                            } else {
                                query = query.eq('user_email', userEmail);
                            }
                            const { data: existingData, error: existingError } = await query;
                            if (existingError) throw existingError;
                            const existingEntry = existingData?.find(e => e.date === entry.date);
                            
                            if (existingEntry) {
                                // Update existing entry
                                const updateResult = await apiCall(`tables/progress_entries/${existingEntry.id}`, 'PUT', apiProgressData);
                                console.log('✅ Progress entry updated via RESTful API');
                                return updateResult;
                            } else {
                                // Create new entry
                                const createResult = await apiCall('tables/progress_entries', 'POST', apiProgressData);
                                console.log('✅ Progress entry created via RESTful API');
                                return createResult;
                            }
                        } catch (apiError) {
                            console.warn('⚠️ RESTful API save failed:', apiError.message);
                            return { fallback: true, error: `Both Supabase and RESTful API failed: ${error.message}, ${apiError.message}` };
                        }
                    } catch (apiFallbackError) {
                        console.error('❌ RESTful API fallback failed:', apiFallbackError.message);
                        return { fallback: true, error: `Both Supabase and RESTful API failed: ${error.message}, ${apiFallbackError.message}` };
                    }
                } else {
                    console.error('❌ Failed to save progress entry to database:', error);
                    return { fallback: true, error: error.message };
                }
            }
        }

        async function loadProgressEntries() {
            if (!window.supabaseClient && !window.apiCall) {
                console.log('ℹ️ No database connection available, using localStorage for progress entries');
                const stored = localStorage.getItem('progressEntries');
                return stored ? JSON.parse(stored) : [];
            }

            console.log('📡 Loading progress entries from database...');
            
            try {
                // Try Supabase first
                if (window.supabaseClient) {
                    // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                    const identifier = await window.authHelper.getCurrentUserIdentifier();
                    
                    if (!identifier.user_id && !identifier.anon_profile_id) {
                        console.log('ℹ️ No valid user identifier available for progress entries loading, using localStorage');
                        const stored = localStorage.getItem('progressEntries');
                        return stored ? JSON.parse(stored) : [];
                    }

                    console.log('📡 Using UUID-based authentication with Supabase...', {
                        user_id: identifier.user_id ? 'authenticated' : null,
                        anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                    });

                    // Query based on available identifier
                    let query = window.supabaseClient.from('progress_entries').select('*');
                    
                    if (identifier.user_id) {
                        query = query.eq('user_id', identifier.user_id);
                    } else {
                        query = query.eq('anon_profile_id', identifier.anon_profile_id);
                    }
                    
                    const { data, error } = await query.order('date', { ascending: false });

                    if (error) {
                        console.warn('⚠️ Supabase progress entries load error:', error.message);
                        throw error; // Fall through to RESTful API
                    }

                    if (data && data.length > 0) {
                        console.log(`✅ Loaded ${data.length} progress entries from Supabase`);
                        return data.map(entry => ({
                            id: parseInt(entry.entry_uuid) || Date.now(),
                            date: entry.date,
                            weight: entry.weight_kg,
                            measurements: {
                                waist: entry.waist_cm,
                                chest: entry.chest_cm,
                                hips: entry.hips_cm,
                                arms: entry.arms_cm
                            },
                            notes: entry.notes || '',
                            timestamp: new Date(entry.created_at).getTime()
                        }));
                    }
                }

                // Fallback to RESTful API
                if (window.apiCall) {
                    try {
                        console.log('📡 Using RESTful API for progress entries load...');
                        
                        // Check if RESTful API endpoints are available first
                        const apiAvailable = await checkApiEndpoints();
                        if (!apiAvailable) {
                            console.log('⚠️ RESTful API endpoints not available - skipping progress entries RESTful API fallback');
                            const stored = localStorage.getItem('progressEntries');
                            return stored ? JSON.parse(stored) : [];
                        }
                        
                        // Get user identifier using authHelper
                        const identifier = await window.authHelper.getCurrentUserIdentifier();
                        
                        if (!identifier.user_id && !identifier.anon_profile_id) {
                            console.log('ℹ️ No valid user identifier available for RESTful API progress entries, using localStorage');
                            const stored = localStorage.getItem('progressEntries');
                            return stored ? JSON.parse(stored) : [];
                        }

                        // Search for progress entries using UUID
                        const searchField = identifier.user_id ? 'user_id' : 'anon_profile_id';
                        const searchValue = identifier.user_id || identifier.anon_profile_id;
                        
                        // Use direct Supabase query to avoid PGRST100 errors
                        console.log(`🔍 Loading progress entries with safe query for ${searchField}:`, searchValue);
                        let query = window.supabaseClient.from('progress_entries').select('*');
                        if (window.SupabaseQueryHelper) {
                            query = window.SupabaseQueryHelper.applySearchFilter(query, searchValue, 'progress_entries');
                        } else {
                            query = query.eq(searchField, searchValue);
                        }
                        query = query.order('date', { ascending: false });
                        const { data: responseData, error: responseError } = await query;
                        if (responseError) throw responseError;
                        
                        const response = { data: responseData };
                        
                        if (response.data && response.data.length > 0) {
                            console.log(`✅ Loaded ${response.data.length} progress entries from RESTful API`);
                            return response.data
                                .filter(entry => entry[searchField] === searchValue)
                                .map(entry => ({
                                    id: parseInt(entry.entry_uuid) || Date.now(),
                                    date: entry.date,
                                    weight: entry.weight_kg,
                                    measurements: {
                                        waist: entry.waist_cm,
                                        chest: entry.chest_cm,
                                        hips: entry.hips_cm,
                                        arms: entry.arms_cm
                                    },
                                    notes: entry.notes || '',
                                    timestamp: new Date(entry.created_at).getTime()
                                }))
                                .sort((a, b) => new Date(b.date) - new Date(a.date));
                        } else {
                            console.log('📡 No progress entries found in RESTful API');
                            return [];
                        }
                    } catch (apiError) {
                        console.warn('⚠️ RESTful API progress entries load failed:', apiError.message);
                        if (apiError.message && apiError.message.includes('404')) {
                            console.log('📋 Progress entries table not found in RESTful API - this is normal for new users');
                        }
                        return [];
                    }
                }
                
                return [];
                
            } catch (error) {
                console.error('❌ Failed to load progress entries from database:', error);
                
                // Final fallback to localStorage
                console.log('📱 Falling back to localStorage...');
                const stored = localStorage.getItem('progressEntries');
                return stored ? JSON.parse(stored) : [];
            }
        }

        // Progress Goals API with Supabase Integration
        async function saveProgressGoalToDB(goal) {
            if (!window.supabaseClient && !window.apiCall) {
                console.log('ℹ️ No database connection available for progress goal save');
                return { fallback: true };
            }

            console.log('💾 Saving progress goal to database...');
            
            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    throw new Error('No valid user identifier available');
                }

                console.log('💾 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Deactivate existing goals for this user
                const deactivateQuery = window.supabaseClient
                    .from('progress_goals')
                    .update({ is_active: false });

                if (identifier.user_id) {
                    deactivateQuery.eq('user_id', identifier.user_id);
                } else if (identifier.anon_profile_id) {
                    deactivateQuery.eq('anon_profile_id', identifier.anon_profile_id);
                }

                await deactivateQuery;
                
                // Create new active goal using authHelper
                const goalData = await window.authHelper.createInsertPayload({
                    goal_type: 'weight_loss', // Default goal type
                    current_value: goal.currentWeight || 0,
                    target_value: goal.targetWeight,
                    target_date: goal.targetDate,
                    unit: 'kg',
                    is_active: true,
                    notes: goal.notes || ''
                });

                const { data: insertData, error } = await window.supabaseClient
                    .from('progress_goals')
                    .insert(goalData)
                    .select();
                
                if (error) {
                    console.warn('⚠️ Supabase progress goal insert failed:', error.message);
                    throw error;
                }
                console.log('✅ Progress goal created in Supabase:', insertData);
                return insertData;
                
            } catch (error) {
                console.warn('⚠️ Supabase save failed, trying RESTful API fallback:', error.message);
                
                // Fallback to RESTful API if Supabase fails
                if (window.apiCall) {
                    try {
                        console.log('📡 Using RESTful API for progress goal save...');
                        
                        // Check if RESTful API endpoints are available first
                        const apiAvailable = await checkApiEndpoints();
                        if (!apiAvailable) {
                            console.log('⚠️ RESTful API endpoints not available - skipping progress goal RESTful API fallback');
                            return { fallback: true };
                        }
                        
                        // Get user email for RESTful API
                        const userEmail = getCurrentUserEmail();
                        
                        // First, deactivate existing goals
                        try {
                            // Use direct Supabase query to avoid PGRST100 errors
                            console.log('🔍 Loading existing progress goals with safe query for:', userEmail);
                            const { data: existingGoalsData, error: existingGoalsError } = await window.supabaseClient
                                .from('progress_goals')
                                .select('*')
                                .eq('user_email', userEmail);
                            if (existingGoalsError) throw existingGoalsError;
                            
                            const existingGoalsResponse = { data: existingGoalsData };
                            if (existingGoalsResponse.data && existingGoalsResponse.data.length > 0) {
                                const activeGoals = existingGoalsResponse.data.filter(g => g.is_active);
                                for (const activeGoal of activeGoals) {
                                    await apiCall(`tables/progress_goals/${activeGoal.id}`, 'PATCH', { is_active: false });
                                }
                            }
                        } catch (deactivateError) {
                            console.warn('⚠️ Could not deactivate existing goals:', deactivateError.message);
                        }
                        
                        // Prepare data for RESTful API
                        const apiGoalData = {
                            email: userEmail,
                            goal_type: 'weight_loss', // Default goal type
                            current_value: goal.currentWeight || 0,
                            target_value: goal.targetWeight,
                            target_date: goal.targetDate,
                            unit: 'kg',
                            is_active: true,
                            created_date: goal.setDate || new Date().toISOString().split('T')[0],
                            notes: goal.notes || ''
                        };
                        
                        // Create new goal
                        const createResult = await apiCall('tables/progress_goals', 'POST', apiGoalData);
                        console.log('✅ Progress goal created via RESTful API');
                        return createResult;
                        
                    } catch (apiError) {
                        console.error('❌ RESTful API fallback failed:', apiError.message);
                        return { fallback: true, error: `Both Supabase and RESTful API failed: ${error.message}, ${apiError.message}` };
                    }
                } else {
                    console.error('❌ Failed to save progress goal to database:', error);
                    return { fallback: true, error: error.message };
                }
            }
        }

        async function loadProgressGoalFromDB() {
            if (!window.supabaseClient && !window.apiCall) {
                return null;
            }

            const userEmail = getCurrentUserEmail();
            console.log('📡 Loading progress goal from database...');
            
            try {
                // Try Supabase first
                if (window.supabaseClient) {
                    const { data: { user } } = await window.supabaseClient.auth.getUser();
                    if (!user) {
                        console.log('ℹ️ No authenticated user for progress goal loading');
                        return null;
                    }

                    const lookupEmail = user.email || `anon_${user.id}`;
                    
                    // Use safe query to avoid PGRST100 errors
                    console.log('🔍 Loading progress goals from Supabase for:', lookupEmail);
                    const { data, error } = await window.supabaseClient
                        .from('progress_goals')
                        .select('*')
                        .eq('user_email', lookupEmail)  // Changed from 'email' to 'user_email'
                        .eq('is_active', true)
                        .order('created_at', { ascending: false })
                        .limit(1)
                        .maybeSingle();

                    if (error) {
                        console.warn('⚠️ Supabase progress goal load error:', error.message);
                        throw error; // Fall through to RESTful API
                    }

                    if (data) {
                        console.log('✅ Loaded progress goal from Supabase');
                        return {
                            targetWeight: data.target_value,
                            targetDate: data.target_date,
                            setDate: data.created_at,
                            currentWeight: data.current_value,
                            notes: data.notes
                        };
                    }
                }

                // Fallback to RESTful API
                if (window.apiCall) {
                    try {
                        console.log('📡 Using RESTful API for progress goal load...');
                        
                        // Check if RESTful API endpoints are available first
                        const apiAvailable = await checkApiEndpoints();
                        if (!apiAvailable) {
                            console.log('⚠️ RESTful API endpoints not available - skipping progress goal RESTful API fallback');
                            return null;
                        }
                        
                        // Use direct Supabase query to avoid PGRST100 errors
                        console.log('🔍 Loading progress goals with safe query for:', userEmail);
                        const { data: responseData, error: responseError } = await window.supabaseClient
                            .from('progress_goals')
                            .select('*')
                            .eq('user_email', userEmail);
                        if (responseError) throw responseError;
                        
                        const response = { data: responseData };
                        
                        if (response.data && response.data.length > 0) {
                            const activeGoals = response.data
                                .filter(goal => goal.is_active)
                                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                            
                            if (activeGoals.length > 0) {
                                const goal = activeGoals[0];
                                console.log('✅ Loaded progress goal from RESTful API');
                                return {
                                    targetWeight: goal.target_value,
                                    targetDate: goal.target_date,
                                    setDate: goal.created_at,
                                    currentWeight: goal.current_value,
                                    notes: goal.notes
                                };
                            }
                        } else {
                            console.log('📡 No progress goals found in RESTful API');
                        }
                    } catch (apiError) {
                        console.warn('⚠️ RESTful API progress goal load failed:', apiError.message);
                        if (apiError.message && apiError.message.includes('404')) {
                            console.log('📋 Progress goals table not found in RESTful API - this is normal for new users');
                        }
                    }
                }
                
                return null;
                
            } catch (error) {
                console.error('❌ Failed to load progress goal from database:', error);
                return null;
            }
        }

        // Macro History API with Supabase Integration
        async function saveMacroHistoryToDB(macroEntry) {
            if (!window.supabaseClient) {
                console.log('ℹ️ No database connection available for macro history save');
                return { fallback: true };
            }

            console.log('💾 Saving macro history entry to database...');
            
            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    throw new Error('No valid user identifier available');
                }

                console.log('💾 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Prepare data using authHelper
                const macroData = await window.authHelper.createInsertPayload({
                    date: macroEntry.date,
                    calories_consumed: macroEntry.calories,
                    protein_consumed: macroEntry.protein,
                    carbs_consumed: macroEntry.carbs,
                    fat_consumed: macroEntry.fat,
                    calories_goal: macroEntry.caloriesGoal,
                    protein_goal: macroEntry.proteinGoal,
                    carbs_goal: macroEntry.carbsGoal,
                    fat_goal: macroEntry.fatGoal,
                    protein_percent: macroEntry.proteinPercent,
                    carbs_percent: macroEntry.carbsPercent,
                    fat_percent: macroEntry.fatPercent,
                    goals_met: macroEntry.goalsMet
                });

                // Use upsert to handle duplicates (update if exists, insert if not)
                const conflictColumns = identifier.user_id ? 'user_id,date' : 'anon_profile_id,date';
                const { data: upsertData, error } = await window.supabaseClient
                    .from('macro_history')
                    .upsert(macroData, { 
                        onConflict: conflictColumns,
                        ignoreDuplicates: false 
                    })
                    .select();
                
                if (error) {
                    console.warn('⚠️ Supabase macro history upsert failed:', error.message);
                    throw error;
                }
                console.log('✅ Macro history saved to Supabase:', upsertData);
                return upsertData;
                
            } catch (error) {
                console.error('❌ Failed to save macro history to database:', error);
                return { fallback: true, error: error.message };
            }
        }

        async function loadMacroHistoryFromDB() {
            if (!window.supabaseClient && !window.apiCall) {
                return [];
            }

            const userEmail = getCurrentUserEmail();
            console.log('📡 Loading macro history from database...');
            
            try {
                // Try Supabase first
                if (window.supabaseClient) {
                    const { data: { user } } = await window.supabaseClient.auth.getUser();
                    if (!user) {
                        console.log('ℹ️ No authenticated user for macro history loading');
                        return [];
                    }

                    const lookupEmail = user.email || `anon_${user.id}`;
                    
                    const { data, error } = await window.supabaseClient
                        .from('macro_history')
                        .select('*')
                        .eq('user_email', lookupEmail)
                        .order('date', { ascending: false })
                        .limit(30); // Last 30 days

                    if (error) {
                        console.warn('⚠️ Supabase macro history load error:', error.message);
                        throw error; // Fall through to RESTful API
                    }

                    if (data && data.length > 0) {
                        console.log(`✅ Loaded ${data.length} macro history entries from Supabase`);
                        return data.map(entry => ({
                            date: entry.date,
                            calories: entry.calories_consumed,
                            protein: entry.protein_consumed,
                            carbs: entry.carbs_consumed,
                            fat: entry.fat_consumed,
                            caloriesGoal: entry.calories_goal,
                            proteinGoal: entry.protein_goal,
                            carbsGoal: entry.carbs_goal,
                            fatGoal: entry.fat_goal,
                            proteinPercent: entry.protein_percent,
                            carbsPercent: entry.carbs_percent,
                            fatPercent: entry.fat_percent,
                            goalsMet: entry.goals_met
                        }));
                    }
                }

                // Fallback to RESTful API
                if (window.apiCall) {
                    console.log('📡 Using RESTful API for macro history load...');
                    
                    // Check if RESTful API endpoints are available first
                    const apiAvailable = await checkApiEndpoints();
                    if (!apiAvailable) {
                        console.log('⚠️ RESTful API endpoints not available - skipping macro history RESTful API fallback');
                        return [];
                    }
                    
                    // Use direct Supabase query to avoid PGRST100 errors
                    console.log('🔍 Loading macro history with safe query for:', userEmail);
                    let query = window.supabaseClient.from('macro_history').select('*');
                    if (window.SupabaseQueryHelper) {
                        query = window.SupabaseQueryHelper.applySearchFilter(query, userEmail, 'macro_history');
                    } else {
                        query = query.eq('user_email', userEmail);
                    }
                    const { data: responseData, error: responseError } = await query;
                    if (responseError) throw responseError;
                    
                    const response = { data: responseData };
                    
                    if (response.data && response.data.length > 0) {
                        console.log(`✅ Loaded ${response.data.length} macro history entries from RESTful API`);
                        return response.data
                            .map(entry => ({
                                date: entry.date,
                                calories: entry.calories_consumed,
                                protein: entry.protein_consumed,
                                carbs: entry.carbs_consumed,
                                fat: entry.fat_consumed,
                                caloriesGoal: entry.calories_goal,
                                proteinGoal: entry.protein_goal,
                                carbsGoal: entry.carbs_goal,
                                fatGoal: entry.fat_goal,
                                proteinPercent: entry.protein_percent,
                                carbsPercent: entry.carbs_percent,
                                fatPercent: entry.fat_percent,
                                goalsMet: entry.goals_met
                            }))
                            .sort((a, b) => new Date(b.date) - new Date(a.date))
                            .slice(0, 30);
                    }
                }
                
                return [];
                
            } catch (error) {
                console.error('❌ Failed to load macro history from database:', error);
                return [];
            }
        }

        // Custom Recipes API with Supabase Integration
        async function saveCustomRecipeToDB(recipe) {
            if (!window.supabaseClient) {
                console.log('ℹ️ No database connection available for recipe save');
                return { fallback: true };
            }

            console.log('💾 Saving custom recipe to database...');
            
            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    throw new Error('No valid user identifier available');
                }

                console.log('💾 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });
                
                // Generate proper UUID for recipe if not exists
                const recipeUuid = recipe.uuid || 
                                  (recipe.id && typeof recipe.id === 'string' && recipe.id.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i) ? 
                                   recipe.id : 
                                   crypto.randomUUID());

                // Debug: Log the recipe object being processed
                console.log('🔍 Processing recipe for database save:', recipe);
                
                // Prepare recipe data using authHelper
                const recipeData = await window.authHelper.createInsertPayload({
                    recipe_name: recipe.name,
                    category: recipe.category || 'General',
                    calories: Math.round(recipe.calories || 0), // Convert to INTEGER
                    protein: Math.round(recipe.protein || 0),   // Convert to INTEGER
                    carbs: Math.round(recipe.carbs || 0),       // Convert to INTEGER
                    fat: Math.round(recipe.fat || 0),           // Convert to INTEGER
                    servings: parseInt(recipe.servings) || 1,   // Ensure integer
                    ingredients: recipe.ingredients || [],      // Store as JSONB directly
                    instructions: recipe.instructions || '',
                    recipe_uuid: recipeUuid
                });
                
                console.log('🔍 Prepared recipe data for database:', recipeData);
                
                // Validate data types before database operation
                const validationErrors = [];
                if (typeof recipeData.recipe_name !== 'string') {
                    validationErrors.push(`recipe_name should be string, got ${typeof recipeData.recipe_name}`);
                }
                if (typeof recipeData.calories !== 'number' || isNaN(recipeData.calories)) {
                    validationErrors.push(`calories should be number, got ${typeof recipeData.calories} (${recipeData.calories})`);
                }
                if (typeof recipeData.protein !== 'number' || isNaN(recipeData.protein)) {
                    validationErrors.push(`protein should be number, got ${typeof recipeData.protein} (${recipeData.protein})`);
                }
                if (typeof recipeData.carbs !== 'number' || isNaN(recipeData.carbs)) {
                    validationErrors.push(`carbs should be number, got ${typeof recipeData.carbs} (${recipeData.carbs})`);
                }
                if (typeof recipeData.fat !== 'number' || isNaN(recipeData.fat)) {
                    validationErrors.push(`fat should be number, got ${typeof recipeData.fat} (${recipeData.fat})`);
                }
                if (typeof recipeData.servings !== 'number' || isNaN(recipeData.servings)) {
                    validationErrors.push(`servings should be number, got ${typeof recipeData.servings} (${recipeData.servings})`);
                }
                
                if (validationErrors.length > 0) {
                    console.error('🚨 Data validation failed:', validationErrors);
                    throw new Error(`Recipe data validation failed: ${validationErrors.join(', ')}`);
                }

                // Check if recipe already exists for this user
                const existingQuery = window.supabaseClient
                    .from('custom_recipes')
                    .select('*')
                    .eq('recipe_uuid', recipeUuid);

                if (identifier.user_id) {
                    existingQuery.eq('user_id', identifier.user_id);
                } else if (identifier.anon_profile_id) {
                    existingQuery.eq('anon_profile_id', identifier.anon_profile_id);
                }

                const { data: existing, error: selectError } = await existingQuery.maybeSingle();

                if (existing && !selectError) {
                    // Update existing recipe using upsert
                    const conflictColumns = identifier.user_id ? 'user_id,recipe_uuid' : 'anon_profile_id,recipe_uuid';
                    const { data: updateData, error } = await window.supabaseClient
                        .from('custom_recipes')
                        .upsert(recipeData, { 
                            onConflict: conflictColumns,
                            ignoreDuplicates: false 
                        })
                        .select();
                    
                    if (error) {
                        console.error('⚠️ Supabase recipe update failed:', {
                            errorMessage: error.message,
                            errorDetails: error.details,
                            errorHint: error.hint,
                            errorCode: error.code,
                            recipeDataSent: recipeData
                        });
                        
                        // Try to provide more helpful error message
                        if (error.message.includes('invalid input syntax for type integer')) {
                            throw new Error(`Database schema issue: A text value is being sent to an integer field. Please check the database table schema for 'custom_recipes'. Original error: ${error.message}`);
                        }
                        
                        throw error;
                    }
                    console.log('✅ Recipe updated in Supabase:', updateData);
                    return updateData;
                } else {
                    // Create new recipe
                    const { data: insertData, error } = await window.supabaseClient
                        .from('custom_recipes')
                        .insert(recipeData)
                        .select();
                    
                    if (error) {
                        console.error('⚠️ Supabase recipe insert failed:', {
                            errorMessage: error.message,
                            errorDetails: error.details,
                            errorHint: error.hint,
                            errorCode: error.code,
                            recipeDataSent: recipeData
                        });
                        
                        // Try to provide more helpful error message
                        if (error.message.includes('invalid input syntax for type integer')) {
                            throw new Error(`Database schema issue: A text value is being sent to an integer field. Please check the database table schema for 'custom_recipes'. Original error: ${error.message}`);
                        }
                        
                        throw error;
                    }
                    console.log('✅ Recipe created in Supabase:', insertData);
                    return insertData;
                }
                
            } catch (error) {
                console.error('❌ Failed to save recipe to database:', error);
                return { fallback: true, error: error.message };
            }
        }

        async function loadCustomRecipes() {
            if (!window.supabaseClient && !window.apiCall) {
                console.log('ℹ️ No database connection available, using localStorage for recipes');
                const stored = localStorage.getItem('customRecipes');
                return stored ? JSON.parse(stored) : [];
            }

            console.log('📡 Loading custom recipes from database...');
            
            try {
                // Get user context for new schema
                const userContext = await getCurrentUserContext();
                
                // Try Supabase first (NEW SCHEMA)
                if (window.supabaseClient && userContext) {
                    console.log('📡 Using Supabase with secure authentication...');
                    
                    const { data, error } = await window.supabaseClient
                        .from('custom_recipes')
                        .select('*')
                        .eq('user_id', userContext.user_id)
                        .order('created_at', { ascending: false });

                    if (error) {
                        console.warn('⚠️ Supabase custom recipes load error:', error.message);
                        throw error; // Fall through to RESTful API or legacy
                    }

                    if (data && data.length > 0) {
                        console.log(`✅ Loaded ${data.length} custom recipes from Supabase (NEW SCHEMA)`);
                        return data.map(recipe => ({
                            id: recipe.recipe_uuid, // Use UUID instead of integer ID
                            name: recipe.recipe_name,
                            category: recipe.category,
                            calories: recipe.calories,
                            protein: recipe.protein,
                            carbs: recipe.carbs,
                            fat: recipe.fat,
                            servings: recipe.servings,
                            ingredients: recipe.ingredients || [], // JSONB field - no parsing needed
                            instructions: recipe.instructions,
                            source: 'custom'
                        }));
                    }
                }

                // Legacy Supabase fallback (OLD SCHEMA) 
                if (window.supabaseClient) {
                    const { data: { user } } = await window.supabaseClient.auth.getUser();
                    if (user) {
                        const lookupEmail = user.email || `anon_${user.id}`;
                        console.log('📡 Attempting legacy Supabase schema...');
                        
                        const { data, error } = await window.supabaseClient
                            .from('custom_recipes')
                            .select('*')
                            .eq('user_email', lookupEmail)
                            .order('created_at', { ascending: false });

                        if (!error && data && data.length > 0) {
                            console.log(`✅ Loaded ${data.length} custom recipes from Supabase (LEGACY SCHEMA)`);
                            return data.map(recipe => ({
                                id: parseInt(recipe.recipe_id) || Date.now(),
                                name: recipe.recipe_name,
                                category: recipe.category,
                                calories: recipe.calories,
                                protein: recipe.protein,
                                carbs: recipe.carbs,
                                fat: recipe.fat,
                                servings: recipe.servings,
                                ingredients: JSON.parse(recipe.ingredients || '[]'),
                                instructions: recipe.instructions,
                                source: 'custom'
                            }));
                        }
                    }
                }

                // Fallback to RESTful API
                if (window.apiCall) {
                    console.log('📡 Using RESTful API for recipe load...');
                    const userEmail = getCurrentUserEmail();
                    // Use direct Supabase query to avoid PGRST100 errors
                    console.log('🔍 Loading custom recipes with safe query for:', userEmail);
                    const { data: responseData, error: responseError } = await window.supabaseClient
                        .from('custom_recipes')
                        .select('*')
                        .eq('user_email', userEmail);
                    if (responseError) throw responseError;
                    
                    const response = { data: responseData };
                    
                    if (response.data && response.data.length > 0) {
                        console.log(`✅ Loaded ${response.data.length} custom recipes from RESTful API`);
                        return response.data.map(recipe => ({
                            id: parseInt(recipe.recipe_id) || Date.now(),
                            name: recipe.recipe_name,
                            category: recipe.category,
                            calories: recipe.calories,
                            protein: recipe.protein,
                            carbs: recipe.carbs,
                            fat: recipe.fat,
                            servings: recipe.servings,
                            ingredients: JSON.parse(recipe.ingredients || '[]'),
                            instructions: recipe.instructions,
                            source: 'custom'
                        }));
                    }
                }
                
                return [];
                
            } catch (error) {
                console.error('❌ Failed to load custom recipes from database:', error);
                
                // Final fallback to localStorage
                console.log('📱 Falling back to localStorage...');
                const stored = localStorage.getItem('customRecipes');
                return stored ? JSON.parse(stored) : [];
            }
        }

        async function deleteCustomRecipeFromDB(recipeId) {
            if (!window.supabaseClient && !window.apiCall) {
                console.log('ℹ️ No database connection available for recipe delete');
                return { fallback: true };
            }

            console.log('🗑️ Deleting custom recipe from database...');
            
            try {
                // Get user context for new schema
                const userContext = await getCurrentUserContext();
                
                // Try Supabase first (NEW SCHEMA)
                if (window.supabaseClient && userContext) {
                    console.log('🗑️ Using Supabase with secure authentication...');
                    
                    // Delete using user_id and recipe_uuid for new schema
                    const { data, error } = await window.supabaseClient
                        .from('custom_recipes')
                        .delete()
                        .eq('user_id', userContext.user_id)
                        .eq('recipe_uuid', recipeId) // recipeId is already UUID for new schema
                        .select();

                    if (error) {
                        console.warn('⚠️ Supabase recipe delete failed (new schema):', error.message);
                        throw error; // Fall through to legacy method
                    }
                    
                    if (data && data.length > 0) {
                        console.log('✅ Recipe deleted from Supabase (NEW SCHEMA):', data);
                        return { success: true };
                    } else {
                        console.log('ℹ️ Recipe not found in Supabase (new schema)');
                        // Try legacy schema before giving up
                    }
                }

                // Legacy Supabase fallback (OLD SCHEMA)
                if (window.supabaseClient) {
                    const { data: { user } } = await window.supabaseClient.auth.getUser();
                    if (user) {
                        const lookupEmail = user.email || `anon_${user.id}`;
                        console.log('🗑️ Attempting legacy Supabase schema...');
                        
                        // Delete the recipe using email and recipe_id (legacy)
                        const { data, error } = await window.supabaseClient
                            .from('custom_recipes')
                            .delete()
                            .eq('user_email', lookupEmail)
                            .eq('recipe_id', recipeId.toString())
                            .select();

                        if (!error && data && data.length > 0) {
                            console.log('✅ Recipe deleted from Supabase (LEGACY SCHEMA):', data);
                            return { success: true };
                        } else if (!error) {
                            console.log('ℹ️ Recipe not found in Supabase (legacy schema)');
                            return { success: true }; // Consider this success since recipe doesn't exist
                        }
                    }
                }

                // Fallback to RESTful API
                if (window.apiCall) {
                    console.log('📡 Using RESTful API for recipe delete...');
                    const userEmail = getCurrentUserEmail();
                    // Use direct Supabase query to avoid PGRST100 errors
                    console.log('🔍 Loading custom recipes for delete with safe query for:', userEmail);
                    const { data: responseData, error: responseError } = await window.supabaseClient
                        .from('custom_recipes')
                        .select('*')
                        .eq('user_email', userEmail);
                    if (responseError) throw responseError;
                    
                    const response = { data: responseData };
                    
                    if (response.data) {
                        const recipe = response.data.find(r => parseInt(r.recipe_id) === recipeId);
                        if (recipe) {
                            await apiCall(`tables/custom_recipes/${recipe.id}`, 'DELETE');
                            console.log('✅ Recipe deleted via RESTful API');
                        } else {
                            console.log('ℹ️ Recipe not found in RESTful API');
                        }
                    }
                    return { success: true };
                }
                
            } catch (error) {
                console.error('❌ Failed to delete recipe from database:', error);
                
                // Final fallback to RESTful API if Supabase fails
                if (window.supabaseClient && window.apiCall) {
                    try {
                        console.log('🔄 Falling back to RESTful API...');
                        const userEmail = getCurrentUserEmail();
                        // Use direct Supabase query to avoid PGRST100 errors
                        console.log('🔍 Loading custom recipes with safe query for:', userEmail);
                        const { data: responseData, error: responseError } = await window.supabaseClient
                            .from('custom_recipes')
                            .select('*')
                            .eq('user_email', userEmail);
                        if (responseError) throw responseError;
                        
                        const response = { data: responseData };
                        
                        if (response.data) {
                            const recipe = response.data.find(r => parseInt(r.recipe_id) === recipeId);
                            if (recipe) {
                                await apiCall(`tables/custom_recipes/${recipe.id}`, 'DELETE');
                                console.log('✅ Recipe deleted via RESTful API fallback');
                            }
                        }
                        return { success: true };
                    } catch (apiError) {
                        console.error('❌ RESTful API fallback also failed:', apiError);
                    }
                }
                
                return { fallback: true, error: error.message };
            }
        }

        // Supabase Authentication Initialization
        async function initAuthentication() {
            console.log('Initializing Supabase Authentication');
            
            // Check for existing session
            try {
                if (typeof SupabaseAuth !== 'undefined') {
                    const user = await SupabaseAuth.getCurrentUser();
                    if (user) {
                        currentUserEmail = user.email;
                        console.log('User already logged in:', user.email);
                    }
                } else {
                    console.warn('SupabaseAuth not available - authentication may not be initialized');
                }
            } catch (authError) {
                console.warn('Error checking authentication status:', authError.message);
            }
            
            // Continue with existing user setup if we have one
            if (currentUserEmail) {
                
                // Load user data for already logged-in users
                setTimeout(() => {
                    loadUserDataAfterAuth();
                }, 2000);
            }
            
            updateAuthUI();
            
            // Set up auth state listener
            SupabaseAuth.onAuthStateChange((event, session) => {
                if (event === 'SIGNED_IN' && session?.user) {
                    currentUserEmail = session.user.email;
                    updateAuthUI();
                    
                    setTimeout(() => {
                        loadUserDataAfterAuth();
                        

                    }, 1000);
                    
                    showNotification('success', 'Welcome!', `Hello ${session.user.user_metadata?.name || session.user.email}. Access granted to the application.`);
                } else if (event === 'SIGNED_OUT') {
                    console.log('User logged out');
                    localStorage.removeItem('authenticated');
                    localStorage.removeItem('user_info');
                    showNotification('info', 'Signed Out', 'You have been logged out. Redirecting to login page...');
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                }
            });
        }
        
        // Legacy authentication code - updated for Supabase
        // This function is no longer called as we're using Supabase now
        
        // Check authentication status and redirect if needed
        async function checkAuthenticationStatus() {
            // Check for Supabase session
            let user = null;
            try {
                if (typeof SupabaseAuth !== 'undefined') {
                    user = await SupabaseAuth.getCurrentUser();
                }
            } catch (error) {
                console.warn('Error getting current user:', error);
            }
            
            // Also check localStorage for fallback authentication
            const isAuthenticated = localStorage.getItem('authenticated') === 'true';
            const storedUserInfo = localStorage.getItem('user_info');
            
            if (!user && !isAuthenticated) {
                // No authentication found, redirect to login page
                console.log('User not authenticated - redirecting to login...');
                window.location.href = 'index.html';
                return false;
            }
            
            if (user) {
                console.log('✅ User authenticated via Supabase:', user.email);
            } else if (isAuthenticated) {
                console.log('✅ User authenticated via localStorage fallback');
            }
            
            return true;
        }
        
        // Update authentication UI and control app access
        async function updateAuthUI() {
            let user = null;
            try {
                if (typeof SupabaseAuth !== 'undefined') {
                    user = await SupabaseAuth.getCurrentUser();
                }
            } catch (error) {
                console.warn('Error getting user in updateAuthUI:', error);
            }
            const appSection = document.getElementById('app-section');
            const authButton = document.getElementById('auth-button');
            const authText = document.getElementById('auth-text');
            const userInfo = document.getElementById('user-info');
            const userName = document.getElementById('user-name');
            
            // Check localStorage authentication first
            const isAuthenticated = localStorage.getItem('authenticated') === 'true';
            const storedUserInfo = localStorage.getItem('user_info');
            
            if (user || (isAuthenticated && storedUserInfo)) {
                // User is authenticated - show app
                if (appSection) {
                    appSection.classList.remove('hidden');
                }
                
                // Update header auth UI (Desktop)
                const desktopAuthButton = document.getElementById('desktop-auth-button');
                const desktopUserInfo = document.getElementById('desktop-user-info');
                const desktopUserName = document.getElementById('desktop-user-name');

                
                if (desktopUserInfo) {
                    // Ensure responsive behavior: hidden on mobile, flex on desktop
                    desktopUserInfo.className = 'hidden md:flex items-center space-x-3';
                }
                if (desktopUserName) {
                    if (user) {
                        desktopUserName.textContent = user.user_metadata.full_name || user.email;
                    } else if (storedUserInfo) {
                        const parsed = JSON.parse(storedUserInfo);
                        desktopUserName.textContent = parsed.name || parsed.email;
                    }
                }
                
                // Update mobile sidebar user info
                const sidebarUserName = document.getElementById('sidebar-user-name');
                const sidebarUserEmail = document.getElementById('sidebar-user-email');
                const sidebarUserSection = document.getElementById('sidebar-user-section');
                
                if (sidebarUserSection) sidebarUserSection.classList.remove('hidden');
                if (sidebarUserName && sidebarUserEmail) {
                    if (user) {
                        sidebarUserName.textContent = user.user_metadata.full_name || user.email;
                        sidebarUserEmail.textContent = user.email;
                    } else if (storedUserInfo) {
                        const parsed = JSON.parse(storedUserInfo);
                        sidebarUserName.textContent = parsed.name || parsed.email;
                        sidebarUserEmail.textContent = parsed.email;
                    }
                }
                
                // Update footer user name
                const footerUserName = document.getElementById('footer-user-name');
                if (footerUserName) {
                    if (user) {
                        footerUserName.textContent = user.user_metadata.full_name || user.email;
                    } else if (storedUserInfo) {
                        const parsed = JSON.parse(storedUserInfo);
                        footerUserName.textContent = parsed.name || parsed.email;
                    }
                }
                
                console.log('User authenticated');
            } else {
                // User not authenticated - redirect to login
                console.log('User not authenticated - redirecting to login...');
                window.location.href = 'index.html';
            }
        }
        
        // Handle authentication button click (logout)
        async function handleAuth() {
            // Since this page is for authenticated users, this is a logout action
            showConfirmDialog(
                'Confirm Logout',
                'Are you sure you want to log out? You will be redirected to the login page and will need to sign in again to access the application.',
                async () => {
                    // Clear authentication state
                    localStorage.removeItem('authenticated');
                    localStorage.removeItem('user_info');
                    
                    // Logout from Supabase
                    const result = await SupabaseAuth.signOut();
                    if (!result.success) {
                        console.error('Logout error:', result.error);
                    }
                    
                    // Show notification and redirect
                    showNotification('Signed Out', 'You have been logged out successfully.', 'info');
                    
                    setTimeout(() => {
                        window.location.href = 'index.html';
                    }, 1500);
                },
                () => {
                    // User cancelled logout - do nothing
                    console.log('Logout cancelled by user');
                }
            );
        }

        // ====================================================================
        // NEW DATABASE FUNCTIONS FOR ORGANIZED DATA STORAGE
        // ====================================================================

        // Global flag to disable Supabase table operations if they consistently fail
        let supabaseTablesDisabled = false;

        // Save daily macro targets to dedicated table
        async function saveDailyTargets(targetsData) {
            if (!window.supabaseClient && !window.apiCall) {
                console.log('ℹ️ No database connection available for daily targets save');
                return { fallback: true };
            }

            console.log('💾 Saving daily targets to database...');
            
            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    throw new Error('No valid user identifier available');
                }

                console.log('💾 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Prepare targets data using authHelper
                const targetsPayload = await window.authHelper.createInsertPayload({
                    daily_calories: targetsData.calories,
                    daily_protein: targetsData.protein,
                    daily_carbs: targetsData.carbs,
                    daily_fat: targetsData.fat
                });

                // Use upsert to handle updates/inserts
                const conflictColumns = identifier.user_id ? 'user_id' : 'anon_profile_id';
                const { data, error } = await window.supabaseClient
                    .from('daily_targets')
                    .upsert(targetsPayload, { 
                        onConflict: conflictColumns,
                        ignoreDuplicates: false 
                    })
                    .select();
                
                if (error) {
                    console.warn('⚠️ Daily targets upsert failed:', error.message);
                    throw error;
                }
                console.log('✅ Daily targets saved:', data);
                return { success: true };
                
            } catch (error) {
                console.warn('⚠️ Supabase save failed, trying RESTful API fallback:', error.message);
                
                // Fallback to RESTful API if Supabase fails
                if (window.apiCall) {
                    try {
                        console.log('📡 Using RESTful API for daily targets save...');
                        
                        // Get user email for RESTful API
                        const userEmail = getCurrentUserEmail();
                        
                        // Prepare data for RESTful API
                        const apiTargetsData = {
                            email: userEmail,
                            daily_calories: targetsData.calories,
                            daily_protein: targetsData.protein,
                            daily_carbs: targetsData.carbs,
                            daily_fat: targetsData.fat,
                            unit_system: targetsData.unit_system || 'imperial',
                            goal_type: targetsData.goal_type || 'maintenance',
                            activity_level: targetsData.activity_level || 1.55,
                            updated_at: new Date().toISOString()
                        };
                        
                        // Check if targets exist for this user
                        try {
                            // Use direct Supabase query to avoid PGRST100 errors
                            console.log('🔍 Loading existing daily targets with safe query for:', userEmail);
                            const { data: existingData, error: existingError } = await window.supabaseClient
                                .from('daily_targets')
                                .select('*')
                                .eq('user_email', userEmail);
                            if (existingError) throw existingError;
                            
                            const existingResponse = { data: existingData };
                            const existingTarget = existingResponse.data?.find(t => t.email === userEmail);
                            
                            if (existingTarget) {
                                // Update existing targets
                                const updateResult = await apiCall(`tables/daily_targets/${existingTarget.id}`, 'PUT', apiTargetsData);
                                console.log('✅ Daily targets updated via RESTful API');
                                return { success: true };
                            } else {
                                // Create new targets
                                const createResult = await apiCall('tables/daily_targets', 'POST', apiTargetsData);
                                console.log('✅ Daily targets created via RESTful API');
                                return { success: true };
                            }
                        } catch (apiError) {
                            console.warn('⚠️ RESTful API save failed:', apiError.message);
                            return { fallback: true, error: `Both Supabase and RESTful API failed: ${error.message}, ${apiError.message}` };
                        }
                    } catch (apiFallbackError) {
                        console.error('❌ RESTful API fallback failed:', apiFallbackError.message);
                        return { fallback: true, error: `Both Supabase and RESTful API failed: ${error.message}, ${apiFallbackError.message}` };
                    }
                } else {
                    console.error('Error saving daily targets:', error);
                    return { fallback: true };
                }
            }
        }

        // Save user preferences to dedicated table
        async function saveUserPreferences(prefsData) {
            if (!window.supabaseClient) {
                console.log('ℹ️ No database connection available for user preferences save');
                return { fallback: true };
            }

            console.log('💾 Saving user preferences to database...');
            
            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    throw new Error('No valid user identifier available');
                }

                console.log('💾 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Prepare preferences data using authHelper
                const prefsPayload = await window.authHelper.createInsertPayload({
                    unit_system: prefsData.unitSystem || 'imperial',
                    theme: prefsData.theme || 'light',
                    notifications_enabled: prefsData.notifications !== false,
                    show_tutorials: prefsData.showTutorials !== false,
                    custom_preferences: prefsData.custom || {}
                });

                // Use upsert to handle updates/inserts
                const conflictColumns = identifier.user_id ? 'user_id' : 'anon_profile_id';
                const { data, error } = await window.supabaseClient
                    .from('user_preferences')
                    .upsert(prefsPayload, { 
                        onConflict: conflictColumns,
                        ignoreDuplicates: false 
                    })
                    .select();
                
                if (error) {
                    console.warn('⚠️ User preferences upsert failed:', error.message);
                    throw error;
                }
                console.log('✅ User preferences saved:', data);
                return { success: true };
                
            } catch (error) {
                console.error('❌ Supabase user preferences save failed:', error);
                
                // Try RESTful API fallback
                try {
                    console.log('🔄 Attempting RESTful API fallback for user preferences...');
                    
                    // Get user identifier using authHelper
                    const identifier = await window.authHelper.getCurrentUserIdentifier();
                    
                    if (!identifier.user_id && !identifier.anon_profile_id) {
                        throw new Error('No valid user identifier available for RESTful API');
                    }
                    
                    // Search for existing user preferences
                    const searchField = identifier.user_id ? 'user_id' : 'anon_profile_id';
                    const searchValue = identifier.user_id || identifier.anon_profile_id;
                    
                    // Use direct Supabase query to avoid PGRST100 errors
                    console.log('🔍 Loading user preferences with safe query for:', searchValue);
                    let query = window.supabaseClient.from('user_preferences').select('*');
                    if (window.SupabaseQueryHelper) {
                        query = window.SupabaseQueryHelper.applySearchFilter(query, searchValue, 'user_preferences');
                    } else {
                        query = query.eq('user_email', searchValue);
                    }
                    const { data: searchData, error: searchError } = await query;
                    const searchResponse = { data: searchData, error: searchError };
                    let existingPrefs = null;
                    
                    if (searchResponse.ok) {
                        const searchResult = await searchResponse.json();
                        existingPrefs = searchResult.data?.find(pref => 
                            pref[searchField] === searchValue
                        );
                    } else {
                        const errorText = await searchResponse.text();
                        console.warn('⚠️ User preferences search failed:', searchResponse.status, errorText.substring(0, 200));
                    }
                    
                    // Prepare preferences payload for RESTful API
                    const prefsPayload = {
                        [searchField]: searchValue,
                        unit_system: prefsData.unitSystem || 'imperial',
                        theme: prefsData.theme || 'light',
                        notifications_enabled: prefsData.notifications !== false,
                        show_tutorials: prefsData.showTutorials !== false,
                        custom_preferences: prefsData.custom || {}
                    };
                    
                    let response;
                    if (existingPrefs) {
                        // Update existing preferences
                        console.log('🔄 Updating existing user preferences via RESTful API...');
                        response = await safeFetch(`tables/user_preferences/${existingPrefs.id}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(prefsPayload)
                        });
                    } else {
                        // Create new preferences
                        console.log('🔄 Creating new user preferences via RESTful API...');
                        response = await safeFetch('tables/user_preferences', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(prefsPayload)
                        });
                    }
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('✅ User preferences saved via RESTful API:', result);
                        return { success: true, restful_api: true };
                    } else {
                        throw new Error(`RESTful API failed with status ${response.status}`);
                    }
                    
                } catch (restfulError) {
                    console.error('❌ RESTful API fallback also failed:', restfulError);
                    return { fallback: true };
                }
            }
        }

        // Save macro calculation result to dedicated table
        async function saveMacroCalculation(calculationData) {
            if (!window.supabaseClient) {
                console.log('ℹ️ No database connection available for macro calculation save');
                return { fallback: true };
            }

            console.log('💾 Saving macro calculation to database...');
            
            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    throw new Error('No valid user identifier available');
                }

                console.log('💾 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Convert to metric for consistent storage
                let weightKg = calculationData.weight;
                let heightCm = calculationData.height;
                
                if (calculationData.inputUnitSystem === 'imperial') {
                    weightKg = calculationData.weight * 0.453592; // lbs to kg
                    heightCm = calculationData.height * 2.54; // inches to cm
                }

                // Prepare calculation data using authHelper
                const calculationPayload = await window.authHelper.createInsertPayload({
                    age: calculationData.age,
                    gender: calculationData.gender,
                    weight_kg: weightKg,
                    height_cm: heightCm,
                    activity_level: calculationData.activityLevel,
                    goal_calories: calculationData.goalCalories,
                    bmr: calculationData.bmr,
                    tdee: calculationData.tdee,
                    target_calories: calculationData.targetCalories,
                    target_protein: calculationData.targetProtein,
                    target_carbs: calculationData.targetCarbs,
                    target_fat: calculationData.targetFat,
                    input_unit_system: calculationData.inputUnitSystem || 'imperial'
                });

                // Always insert new calculation (for history)
                const { data, error } = await window.supabaseClient
                    .from('macro_calculations')
                    .insert(calculationPayload)
                    .select();
                
                if (error) {
                    console.warn('⚠️ Macro calculation save failed:', error.message);
                    throw error;
                }
                console.log('✅ Macro calculation saved:', data);
                return { success: true, data };
                
            } catch (error) {
                console.error('Error saving macro calculation:', error);
                return { fallback: true };
            }
        }

        // Load functions for the new tables
        async function loadDailyTargets() {
            if (!window.supabaseClient) {
                console.log('ℹ️ No database connection available for daily targets load');
                return null;
            }

            console.log('📊 Loading daily targets from database...');

            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    console.log('⚠️ No valid user identifier available for daily targets');
                    return null;
                }

                console.log('📊 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // First, try to get effective macros (coach-adjusted if available, AI if not)
                console.log('🎯 Attempting to load effective macros (coach-adjusted or AI)...');
                
                const { data: effectiveMacros, error: macrosError } = await window.supabaseClient
                    .rpc('get_effective_client_macros', { 
                        p_client_user_id: identifier.user_id,
                        p_client_email: identifier.email,
                        p_client_anon_profile_id: identifier.anon_profile_id
                    });

                if (!macrosError && effectiveMacros && effectiveMacros.length > 0) {
                    const macroData = effectiveMacros[0];
                    console.log(`✅ Effective macros loaded (source: ${macroData.source}):`, macroData);
                    
                    // Convert to the format expected by the client app
                    return {
                        daily_calories: macroData.calories,
                        daily_protein: macroData.protein,
                        daily_carbs: macroData.carbs,
                        daily_fat: macroData.fat,
                        updated_at: macroData.last_updated,
                        macro_source: macroData.source, // 'coach_adjusted' or 'ai_generated'
                        adjusted_by_coach: macroData.adjusted_by_coach_email,
                        adjustment_reason: macroData.adjustment_reason
                    };
                }
                
                console.log('⚠️ Effective macros function failed, falling back to direct daily_targets query...');
                
                // Fallback to original daily_targets query
                let query = window.supabaseClient.from('daily_targets').select('*');
                
                if (identifier.user_id) {
                    query = query.eq('user_id', identifier.user_id);
                } else {
                    query = query.eq('anon_profile_id', identifier.anon_profile_id);
                }
                
                const { data, error } = await query
                    .order('updated_at', { ascending: false })
                    .limit(1)
                    .maybeSingle();

                if (error) {
                    console.warn('⚠️ Supabase daily targets query failed:', error.message);
                    throw error;
                }

                console.log('✅ Daily targets loaded from Supabase (AI only):', data);
                return data;
                
            } catch (error) {
                console.error('❌ Supabase daily targets load failed:', error);
                
                // Try RESTful API fallback
                try {
                    console.log('🔄 Attempting RESTful API fallback for daily targets...');
                    
                    // Check if RESTful API endpoints are available
                    const apiAvailable = await checkApiEndpoints();
                    if (!apiAvailable) {
                        console.log('⚠️ RESTful API endpoints not available - skipping daily targets fallback');
                        return null;
                    }
                    
                    // Get user identifier using authHelper
                    const identifier = await window.authHelper.getCurrentUserIdentifier();
                    
                    if (!identifier.user_id && !identifier.anon_profile_id) {
                        console.log('⚠️ No valid user identifier available for RESTful API daily targets');
                        return null;
                    }
                    
                    // Search for daily targets
                    const searchField = identifier.user_id ? 'user_id' : 'anon_profile_id';
                    const searchValue = identifier.user_id || identifier.anon_profile_id;
                    
                    // Use direct Supabase query to avoid PGRST100 errors
                    console.log('🔍 Loading daily targets with safe query for:', searchValue);
                    let query = window.supabaseClient.from('daily_targets').select('*');
                    if (window.SupabaseQueryHelper) {
                        query = window.SupabaseQueryHelper.applySearchFilter(query, searchValue, 'daily_targets');
                    } else {
                        query = query.eq('user_email', searchValue);
                    }
                    query = query.order('updated_at', { ascending: false }).limit(1);
                    const { data: responseData, error: responseError } = await query;
                    const response = { ok: !responseError, data: responseData, error: responseError };
                    
                    if (response.ok) {
                        const result = await response.json();
                        const dailyTarget = result.data?.find(target => 
                            target[searchField] === searchValue
                        );
                        
                        console.log('✅ Daily targets loaded via RESTful API:', dailyTarget);
                        return dailyTarget || null;
                    } else {
                        const errorText = await response.text();
                        console.warn('⚠️ RESTful API daily targets query failed:', response.status, errorText.substring(0, 200));
                        return null;
                    }
                    
                } catch (restfulError) {
                    console.error('❌ RESTful API fallback also failed:', restfulError);
                    return null;
                }
            }
        }

        async function loadUserPreferences() {
            if (!window.supabaseClient) {
                console.log('ℹ️ No database connection available for user preferences load');
                return null;
            }

            console.log('⚙️ Loading user preferences from database...');

            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    console.log('⚠️ No valid user identifier available for user preferences');
                    return null;
                }

                console.log('⚙️ Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Query based on available identifier
                let query = window.supabaseClient.from('user_preferences').select('*');
                
                if (identifier.user_id) {
                    query = query.eq('user_id', identifier.user_id);
                } else {
                    query = query.eq('anon_profile_id', identifier.anon_profile_id);
                }
                
                const { data, error } = await query.maybeSingle();

                if (error) {
                    console.warn('⚠️ Supabase user preferences query failed:', error.message);
                    throw error;
                }

                console.log('✅ User preferences loaded from Supabase:', data);
                return data;
                
            } catch (error) {
                console.error('❌ Supabase user preferences load failed:', error);
                
                // Try RESTful API fallback
                try {
                    console.log('🔄 Attempting RESTful API fallback for user preferences...');
                    
                    // Get user identifier using authHelper
                    const identifier = await window.authHelper.getCurrentUserIdentifier();
                    
                    if (!identifier.user_id && !identifier.anon_profile_id) {
                        console.log('⚠️ No valid user identifier available for RESTful API user preferences');
                        return null;
                    }
                    
                    // Search for user preferences
                    const searchField = identifier.user_id ? 'user_id' : 'anon_profile_id';
                    const searchValue = identifier.user_id || identifier.anon_profile_id;
                    
                    // Use direct Supabase query to avoid PGRST100 errors
                    console.log('🔍 Loading user preferences with safe query for:', searchValue);
                    let query = window.supabaseClient.from('user_preferences').select('*');
                    if (window.SupabaseQueryHelper) {
                        query = window.SupabaseQueryHelper.applySearchFilter(query, searchValue, 'user_preferences');
                    } else {
                        query = query.eq('user_email', searchValue);
                    }
                    query = query.limit(1);
                    const { data: responseData, error: responseError } = await query;
                    const response = { ok: !responseError, data: responseData, error: responseError };
                    
                    if (response.ok) {
                        const result = await response.json();
                        const userPrefs = result.data?.find(pref => 
                            pref[searchField] === searchValue
                        );
                        
                        console.log('✅ User preferences loaded via RESTful API:', userPrefs);
                        return userPrefs || null;
                    } else {
                        const errorText = await response.text();
                        console.warn('⚠️ RESTful API user preferences query failed:', response.status, errorText.substring(0, 200));
                        return null;
                    }
                    
                } catch (restfulError) {
                    console.error('❌ RESTful API fallback also failed:', restfulError);
                    return null;
                }
            }
        }

        async function loadMacroCalculationHistory(limit = 10) {
            if (!window.supabaseClient && !window.apiCall) {
                console.log('ℹ️ No database connection available for calculation history');
                return [];
            }

            console.log('📊 Loading macro calculation history from database...');

            try {
                // Get user identifier using authHelper (supports both authenticated users and anonymous profiles)
                const identifier = await window.authHelper.getCurrentUserIdentifier();
                
                if (!identifier.user_id && !identifier.anon_profile_id) {
                    console.log('⚠️ No valid user identifier available for calculation history');
                    return [];
                }

                console.log('📊 Using UUID-based authentication with Supabase...', {
                    user_id: identifier.user_id ? 'authenticated' : null,
                    anon_profile_id: identifier.anon_profile_id ? 'anonymous' : null
                });

                // Query based on available identifier
                let query = window.supabaseClient.from('macro_calculations').select('*');
                
                if (identifier.user_id) {
                    query = query.eq('user_id', identifier.user_id);
                } else {
                    query = query.eq('anon_profile_id', identifier.anon_profile_id);
                }
                
                const { data, error } = await query
                    .order('created_at', { ascending: false })
                    .limit(limit);

                if (error) {
                    console.warn('⚠️ Supabase calculation history query failed:', error.message);
                    throw error;
                }

                console.log('✅ Calculation history loaded from Supabase:', data?.length || 0, 'entries');
                return data || [];
                
            } catch (error) {
                console.error('❌ Supabase calculation history load failed:', error);
                
                // Try RESTful API fallback
                try {
                    console.log('🔄 Attempting RESTful API fallback for calculation history...');
                    
                    // Check if RESTful API endpoints are available
                    const apiAvailable = await checkApiEndpoints();
                    if (!apiAvailable) {
                        console.log('⚠️ RESTful API endpoints not available - skipping calculation history fallback');
                        return [];
                    }
                    
                    const identifier = await window.authHelper.getCurrentUserIdentifier();
                    
                    if (!identifier.user_id && !identifier.anon_profile_id) {
                        console.log('⚠️ No valid user identifier available for RESTful API calculation history');
                        return [];
                    }
                    
                    // Search for calculation history using RESTful API
                    let searchParams = '';
                    if (identifier.user_id) {
                        searchParams = `?user_id=${identifier.user_id}`;
                    } else {
                        searchParams = `?anon_profile_id=${identifier.anon_profile_id}`;
                    }
                    
                    const response = await safeFetch(`tables/macro_calculations${searchParams}&limit=${limit}&sort=created_at`);
                    
                    if (response.status === 404) {
                        console.log('📝 No calculation history found in RESTful API');
                        return [];
                    }
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.warn('⚠️ RESTful API error response:', response.status, errorText.substring(0, 200));
                        throw new Error(`RESTful API error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('✅ Calculation history loaded from RESTful API:', result.data?.length || 0, 'entries');
                    return result.data || [];
                    
                } catch (fallbackError) {
                    console.error('❌ RESTful API calculation history fallback also failed:', fallbackError);
                    return [];
                }
            }
        }

        // Function to populate personal info form from calculation history
        async function loadAndPopulatePersonalInfo(forceOverride = false) {
            try {
                console.log('🔄 Loading personal information from calculation history...');
                
                // Load the most recent calculation
                const history = await loadMacroCalculationHistory(1);
                
                if (!history || history.length === 0) {
                    console.log('ℹ️ No calculation history found - form will remain empty');
                    if (forceOverride) {
                        showNotification('No Previous Data', 'No previous calculations found to load', 'info');
                    }
                    return false;
                }
                
                const mostRecent = history[0];
                console.log('📋 Most recent calculation found:', {
                    age: mostRecent.age,
                    gender: mostRecent.gender,
                    date: mostRecent.created_at
                });
                
                // Get form fields
                const ageField = document.getElementById('age');
                const genderField = document.getElementById('gender');
                const weightField = document.getElementById('weight');
                const heightField = document.getElementById('height');
                const activityField = document.getElementById('activity');
                const goalField = document.getElementById('goal');
                
                let fieldsPopulated = 0;
                
                // Populate fields - either if empty (auto-load) or if forceOverride (manual button)
                if (ageField && (forceOverride || !ageField.value) && mostRecent.age) {
                    ageField.value = mostRecent.age;
                    fieldsPopulated++;
                }
                
                if (genderField && (forceOverride || !genderField.value) && mostRecent.gender) {
                    genderField.value = mostRecent.gender;
                    fieldsPopulated++;
                }
                
                if (weightField && (forceOverride || !weightField.value) && mostRecent.weight_kg) {
                    // Convert weight based on current unit system
                    let displayWeight = mostRecent.weight_kg;
                    if (currentUnitSystem === 'imperial') {
                        displayWeight = (mostRecent.weight_kg * 2.20462).toFixed(1); // kg to lbs
                    }
                    weightField.value = displayWeight;
                    fieldsPopulated++;
                }
                
                if (heightField && (forceOverride || !heightField.value) && mostRecent.height_cm) {
                    // Convert height based on current unit system
                    let displayHeight = mostRecent.height_cm;
                    if (currentUnitSystem === 'imperial') {
                        displayHeight = (mostRecent.height_cm / 2.54).toFixed(1); // cm to inches
                    }
                    heightField.value = displayHeight;
                    fieldsPopulated++;
                }
                
                if (activityField && (forceOverride || !activityField.value) && mostRecent.activity_level) {
                    activityField.value = mostRecent.activity_level;
                    fieldsPopulated++;
                }
                
                if (goalField && (forceOverride || !goalField.value) && mostRecent.goal_calories) {
                    goalField.value = mostRecent.goal_calories;
                    fieldsPopulated++;
                }
                
                if (fieldsPopulated > 0) {
                    const message = forceOverride ? 
                        `Previous details loaded successfully (${fieldsPopulated} fields filled)` :
                        `Your previous details have been restored (${fieldsPopulated} fields filled)`;
                    console.log('✅ Personal information populated from history:', fieldsPopulated, 'fields filled');
                    showNotification('Personal Info Loaded', message, 'success');
                    return true;
                } else {
                    if (forceOverride) {
                        showNotification('No Data to Load', 'No new information found to populate', 'info');
                    } else {
                        console.log('ℹ️ Form fields already have values - no auto-population needed');
                    }
                    return false;
                }
                
            } catch (error) {
                console.error('❌ Error loading personal information:', error);
                if (forceOverride) {
                    showNotification('Load Failed', 'Could not load previous details. Please try again.', 'error');
                }
                return false;
            }
        }

        // Function to manually load today's meals from database
        async function loadTodayMeals() {
            try {
                console.log('🔄 Manually loading today\'s meals from database...');
                
                // Show loading notification
                showNotification('Loading...', 'Loading your meals from database', 'info');
                
                // Load today's meals from database
                const todayMeals = await loadDailyMeals();
                
                if (!todayMeals || todayMeals.length === 0) {
                    console.log('ℹ️ No meals found in database for today');
                    showNotification('No Meals Found', 'No meals found in database for today', 'info');
                    return false;
                }
                
                console.log('✅ Manually loaded meals from database:', todayMeals.length, 'meals');
                
                // Update meals array
                meals = todayMeals;
                
                // Recalculate current intake from loaded meals
                currentIntake = { protein: 0, carbs: 0, fat: 0 };
                meals.forEach(meal => {
                    currentIntake.protein += meal.protein || 0;
                    currentIntake.carbs += meal.carbs || 0;
                    currentIntake.fat += meal.fat || 0;
                });
                
                // Update all displays
                updateMealsList();
                updateProgress();
                updateMacroCharts();
                updateCalorieDisplay();
                
                // Sync to localStorage
                localStorage.setItem('meals', JSON.stringify(meals));
                localStorage.setItem('currentIntake', JSON.stringify(currentIntake));
                localStorage.setItem('lastSaved', new Date().toDateString());
                
                showNotification('Meals Loaded', `Successfully loaded ${todayMeals.length} meals from database`, 'success');
                console.log('✅ Meals manually loaded, intake calculated:', currentIntake);
                return true;
                
            } catch (error) {
                console.error('❌ Error manually loading meals:', error);
                showNotification('Load Failed', 'Could not load meals from database. Please try again.', 'error');
                return false;
            }
        }

        // ====================================================================
        // END NEW DATABASE FUNCTIONS
        // ====================================================================

        // Global error handler for button clicks
        window.addEventListener('error', function(event) {
            if (event.error && event.error.message) {
                const message = event.error.message;
                if (message.includes('is not defined') || message.includes('is not a function')) {
                    console.error('⚠️ Button click error:', message);
                    console.error('📍 Error occurred at:', event.filename, 'line', event.lineno);
                    
                    // Show user-friendly notification
                    if (typeof showNotification === 'function') {
                        showNotification('Action Failed', 'This feature is temporarily unavailable. Please try again.', 'warning');
                    }
                }
            }
        });

        // Function to check and display authentication status
        async function checkAuthStatus() {
            const statusElement = document.getElementById('auth-status');
            const statusText = document.getElementById('auth-status-text');
            
            if (!statusElement || !statusText) return;
            
            statusElement.classList.remove('hidden');
            
            if (window.supabaseClient) {
                try {
                    const { data: { user }, error } = await window.supabaseClient.auth.getUser();
                    
                    if (user) {
                        if (user.email) {
                            statusText.innerHTML = `<i class="fas fa-check-circle text-green-500 mr-1"></i>Synced with ${user.email}`;
                        } else {
                            statusText.innerHTML = `<i class="fas fa-user-secret text-blue-500 mr-1"></i>Anonymous session - data will sync`;
                        }
                    } else {
                        statusText.innerHTML = `<i class="fas fa-exclamation-triangle text-yellow-500 mr-1"></i>Ready to sync anonymously`;
                    }
                } catch (error) {
                    statusText.innerHTML = `<i class="fas fa-wifi-slash text-gray-500 mr-1"></i>Offline mode only`;
                }
            } else {
                statusText.innerHTML = `<i class="fas fa-wifi-slash text-gray-500 mr-1"></i>Offline mode only`;
            }
        }
        
        // Variable safety checks
        function initializeCriticalVariables() {
            // Ensure critical arrays exist
            if (typeof meals === 'undefined') {
                window.meals = [];
            }
            if (typeof customRecipes === 'undefined') {
                window.customRecipes = [];
            }
            if (typeof macroHistory === 'undefined') {
                window.macroHistory = [];
            }
            if (typeof currentIntake === 'undefined') {
                window.currentIntake = { protein: 0, carbs: 0, fat: 0 };
            }
            if (typeof dailyTargets === 'undefined') {
                // Try to load saved targets from localStorage first
                const savedTargets = localStorage.getItem('dailyTargets');
                if (savedTargets && savedTargets !== 'null') {
                    try {
                        const parsed = JSON.parse(savedTargets);
                        if (parsed && parsed.calories > 0 && parsed.protein > 0) {
                            window.dailyTargets = parsed;
                            console.log('✅ Daily targets loaded from localStorage during init:', parsed);
                        } else {
                            window.dailyTargets = { calories: 2000, protein: 150, carbs: 250, fat: 67 };
                        }
                    } catch (error) {
                        console.warn('⚠️ Error parsing saved targets during init:', error);
                        window.dailyTargets = { calories: 2000, protein: 150, carbs: 250, fat: 67 };
                    }
                } else {
                    window.dailyTargets = { calories: 2000, protein: 150, carbs: 250, fat: 67 };
                }
            }
            
            console.log('✅ Critical variables initialized');
        }

        /**
         * Initialize Enhanced Error Handling for All Database Operations
         * Wraps existing functions with comprehensive error handling
         */
        function initializeEnhancedErrorHandling() {
            console.log('🛡️ Initializing enhanced error handling system...');
            
            try {
                // Enhanced JSON operations - Replace global JSON methods
                const originalJSONParse = JSON.parse;
                const originalJSONStringify = JSON.stringify;
                
                // Override global JSON methods with safe versions
                window.JSON.safeParse = window.enhancedDB.enhancedJSONParse;
                window.JSON.safeStringify = window.enhancedDB.enhancedJSONStringify;
                
                // Enhanced localStorage operations
                if (typeof Storage !== 'undefined') {
                    const originalGetItem = localStorage.getItem.bind(localStorage);
                    const originalSetItem = localStorage.setItem.bind(localStorage);
                    const originalRemoveItem = localStorage.removeItem.bind(localStorage);
                    
                    // Override localStorage methods
                    localStorage.safeGetItem = window.enhancedDB.enhancedLocalStorage.getItem;
                    localStorage.safeSetItem = window.enhancedDB.enhancedLocalStorage.setItem;
                    localStorage.safeRemoveItem = window.enhancedDB.enhancedLocalStorage.removeItem;
                }

                // Wrap key database functions with enhanced error handling
                if (typeof saveDailyMeals === 'function') {
                    const originalSaveDailyMeals = saveDailyMeals;
                    window.saveDailyMeals = window.enhancedDB.wrapFunctionWithErrorHandling(
                        originalSaveDailyMeals, 
                        'saveDailyMeals',
                        {
                            critical: false,
                            validateArgs: true,
                            argRules: {
                                required: true,
                                type: 'object'
                            }
                        }
                    );
                }

                if (typeof saveProgressEntryToDB === 'function') {
                    const originalSaveProgress = saveProgressEntryToDB;
                    window.saveProgressEntryToDB = window.enhancedDB.wrapFunctionWithErrorHandling(
                        originalSaveProgress,
                        'saveProgressEntry',
                        {
                            critical: false,
                            validateArgs: true
                        }
                    );
                }

                if (typeof saveCustomRecipeToDB === 'function') {
                    const originalSaveRecipe = saveCustomRecipeToDB;
                    window.saveCustomRecipeToDB = window.enhancedDB.wrapFunctionWithErrorHandling(
                        originalSaveRecipe,
                        'saveCustomRecipe',
                        {
                            critical: false,
                            validateArgs: true
                        }
                    );
                }

                if (typeof saveUserPreferences === 'function') {
                    const originalSavePrefs = saveUserPreferences;
                    window.saveUserPreferences = window.enhancedDB.wrapFunctionWithErrorHandling(
                        originalSavePrefs,
                        'saveUserPreferences',
                        {
                            critical: true,
                            validateArgs: true
                        }
                    );
                }

                if (typeof saveMacroCalculation === 'function') {
                    const originalSaveMacro = saveMacroCalculation;
                    window.saveMacroCalculation = window.enhancedDB.wrapFunctionWithErrorHandling(
                        originalSaveMacro,
                        'saveMacroCalculation',
                        {
                            critical: false,
                            validateArgs: true
                        }
                    );
                }

                // Skip wrapping getCurrentUserIdentifier to avoid circular dependency
                // This function already has internal enhanced error handling
                console.log('⚠️ Skipping getCurrentUserIdentifier wrapping to prevent circular dependency');

                // Enhanced fetch operations for Supabase
                if (window.supabaseClient) {
                    // Wrap Supabase operations with enhanced error handling
                    const originalFrom = window.supabaseClient.from.bind(window.supabaseClient);
                    window.supabaseClient.enhancedFrom = function(tableName) {
                        const table = originalFrom(tableName);
                        
                        // Wrap common operations
                        const originalSelect = table.select.bind(table);
                        const originalInsert = table.insert.bind(table);
                        const originalUpdate = table.update.bind(table);
                        const originalUpsert = table.upsert.bind(table);
                        const originalDelete = table.delete.bind(table);

                        table.safeSelect = function(...args) {
                            return window.enhancedDB.enhancedSupabaseOperation(
                                () => originalSelect(...args),
                                `select from ${tableName}`,
                                { timeout: 10000 }
                            );
                        };

                        table.safeInsert = function(...args) {
                            return window.enhancedDB.enhancedSupabaseOperation(
                                () => originalInsert(...args),
                                `insert into ${tableName}`,
                                { critical: true, timeout: 15000 }
                            );
                        };

                        table.safeUpdate = function(...args) {
                            return window.enhancedDB.enhancedSupabaseOperation(
                                () => originalUpdate(...args),
                                `update ${tableName}`,
                                { critical: true, timeout: 15000 }
                            );
                        };

                        table.safeUpsert = function(...args) {
                            return window.enhancedDB.enhancedSupabaseOperation(
                                () => originalUpsert(...args),
                                `upsert ${tableName}`,
                                { critical: true, timeout: 15000 }
                            );
                        };

                        table.safeDelete = function(...args) {
                            return window.enhancedDB.enhancedSupabaseOperation(
                                () => originalDelete(...args),
                                `delete from ${tableName}`,
                                { critical: true, timeout: 10000 }
                            );
                        };

                        return table;
                    };
                }

                // Global error handling for unhandled promise rejections
                window.addEventListener('unhandledrejection', function(event) {
                    console.error('🚨 Unhandled Promise Rejection:', event.reason);
                    
                    window.handleError(event.reason, {
                        operation: 'unhandled promise',
                        critical: true,
                        background: false
                    });
                    
                    // Prevent the default browser error handling
                    event.preventDefault();
                });

                // Global error handling for uncaught errors
                window.addEventListener('error', function(event) {
                    console.error('🚨 Uncaught Error:', event.error);
                    
                    window.handleError(event.error, {
                        operation: 'uncaught error',
                        critical: true,
                        background: false,
                        filename: event.filename,
                        lineno: event.lineno,
                        colno: event.colno
                    });
                });

                // Enhanced notification system integration
                if (typeof showCustomNotification === 'function') {
                    const originalNotification = showCustomNotification;
                    window.showCustomNotification = function(message, type, duration) {
                        try {
                            return originalNotification(message, type, duration);
                        } catch (error) {
                            console.error('Notification system failed:', error.message);
                            // Fallback to browser alert for critical messages
                            if (type === 'error') {
                                alert(message);
                            }
                        }
                    };
                }

                // Network status monitoring integration with proper availability checking
                if (window.initManager) {
                    window.initManager.waitForComponents(['networkMonitor'], (degraded = false) => {
                        if (!degraded && window.networkMonitor && window.networkMonitor.onStatusChange) {
                            window.networkMonitor.onStatusChange((status, isOnline) => {
                                console.log(`🌐 Network status changed: ${status} (online: ${isOnline})`);
                                
                                if (isOnline) {
                                    // Trigger queue processing when back online
                                    if (window.dbRecovery) {
                                        window.dbRecovery.forceProcessQueue();
                                    }
                                }
                            });
                        } else {
                            console.log('📡 Network monitor not available - using basic connectivity detection');
                            // Fallback: Basic online/offline detection
                            window.addEventListener('online', () => {
                                console.log('🌐 Basic network: Back online');
                                if (window.dbRecovery) {
                                    window.dbRecovery.forceProcessQueue();
                                }
                            });
                        }
                    });
                } else {
                    // Fallback when initialization manager is not available
                    setTimeout(() => {
                        if (window.networkMonitor && window.networkMonitor.onStatusChange) {
                            window.networkMonitor.onStatusChange((status, isOnline) => {
                                console.log(`🌐 Network status changed: ${status} (online: ${isOnline})`);
                                if (isOnline && window.dbRecovery) {
                                    window.dbRecovery.forceProcessQueue();
                                }
                            });
                        }
                    }, 1000);
                }

                // Periodic error report
                setInterval(() => {
                    const errorStats = window.errorReporter.getErrorStats();
                    const performanceStats = window.performanceMonitor.getMetrics();
                    
                    // Only report errors if there are meaningful recent errors (excluding 403s)
                    if (errorStats.recentErrors > 0) {
                        // In development, show all error reports
                        // In production, only show if there are significant errors
                        if (!PRODUCTION_MODE || errorStats.recentErrors > 2) {
                            console.warn('📊 Error Report:', errorStats);
                        }
                    }
                    
                    // Log performance issues
                    Object.entries(performanceStats.averageResponseTimes).forEach(([operation, avgTime]) => {
                        if (avgTime > 3000) { // 3 seconds
                            console.warn(`⚠️ Slow operation detected: ${operation} (avg: ${avgTime.toFixed(0)}ms)`);
                        }
                    });
                }, 300000); // Every 5 minutes

                console.log('✅ Enhanced error handling system initialized successfully');
                
                // Show initialization success
                if (typeof showCustomNotification === 'function') {
                    showCustomNotification(
                        'Enhanced error handling active - your data is protected',
                        'success',
                        3000
                    );
                }

            } catch (error) {
                console.error('❌ Failed to initialize enhanced error handling:', error);
                
                // Even if enhanced error handling fails, log the error
                if (window.errorHandler) {
                    window.errorHandler.logError('ERROR_HANDLING_INIT', error, 'critical');
                }
                
                // Fallback notification
                if (typeof showCustomNotification === 'function') {
                    showCustomNotification(
                        'Error handling initialization failed - basic functionality may be limited',
                        'warning',
                        5000
                    );
                }
            }
        }

        // Initialize app when page loads (Protected main application)
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Main app loading - checking authentication...');
            
            // Initialize critical variables first
            initializeCriticalVariables();
            
            // Initialize enhanced error handling for all database operations with proper dependency waiting
            if (window.initManager) {
                window.initManager.waitForComponents(['errorHandler', 'enhancedDB'], (degraded = false) => {
                    initializeEnhancedErrorHandling();
                    
                    if (degraded) {
                        console.warn('⚠️ Enhanced error handling initialized in degraded mode - some features may be limited');
                    }
                });
            } else {
                // Fallback: Initialize with delay
                setTimeout(() => {
                    initializeEnhancedErrorHandling();
                }, 1000);
            }
            
            // Temporarily disable auth check for testing
            // if (!checkAuthenticationStatus()) {
            //     return; // Will redirect to login page
            // }
            
            // Check if Supabase Auth is available
            if (typeof window.SupabaseAuth === 'undefined' || typeof window.authWrapper === 'undefined') {
                console.log('ℹ️ Standard auth wrapper not available, using core authentication systems');
                
                // Only show error notification if Supabase client is also not working
                if (!window.supabaseClient || !window.enhancedDB) {
                    console.log('❌ Core authentication systems not available - showing configuration notice');
                    setTimeout(() => {
                        showNotification('warning', 'Configuration Notice', 'Please ensure Supabase is properly configured.');
                    }, 2000);
                } else {
                    console.log('✅ Core authentication systems active - continuing without standard auth wrapper');
                }
            } else {
                // Auth is initialized automatically by authWrapper
                console.log('Supabase Auth ready');
            }
            
            // Update UI and continue with app initialization
            updateAuthUI();
            
            // Check and display authentication status
            setTimeout(checkAuthStatus, 1000);
            
            // Load basic data from localStorage first (immediate display)
            loadBasicStoredData();
            
            // Then try to load user data from database if authenticated
            setTimeout(async () => {
                try {
                    // Check if user is authenticated
                    let currentUser = null;
                    try {
                        if (typeof SupabaseAuth !== 'undefined') {
                            currentUser = await SupabaseAuth.getCurrentUser();
                        }
                    } catch (authError) {
                        console.warn('Authentication check failed:', authError);
                    }
                    const isAuthenticated = currentUser || localStorage.getItem('authenticated') === 'true';
                    
                    if (isAuthenticated) {
                        console.log('🔄 User authenticated - loading data from database on page load...');
                        await loadUserDataAfterAuth();
                    } else {
                        console.log('ℹ️ User not authenticated - using localStorage data only');
                    }
                } catch (error) {
                    console.warn('⚠️ Could not load user data from database on page load:', error.message);
                    console.log('📱 Continuing with localStorage data');
                }
            }, 3000); // Wait for Supabase Auth to initialize
        });
        
        // Unit System Variables and Functions
        let currentUnitSystem = 'imperial'; // Default to imperial
        
        // Unit conversion functions
        function lbsToKg(lbs) {
            return lbs * 0.453592;
        }
        
        function kgToLbs(kg) {
            return kg * 2.20462;
        }
        
        function inToCm(inches) {
            return inches * 2.54;
        }
        
        function cmToIn(cm) {
            return cm / 2.54;
        }
        
        function getWeightUnit() {
            return currentUnitSystem === 'imperial' ? 'lbs' : 'kg';
        }
        
        function getHeightUnit() {
            return currentUnitSystem === 'imperial' ? 'inches' : 'cm';
        }
        
        function convertWeight(value, fromSystem, toSystem) {
            if (fromSystem === toSystem) return value;
            if (fromSystem === 'imperial' && toSystem === 'metric') {
                return lbsToKg(value);
            }
            if (fromSystem === 'metric' && toSystem === 'imperial') {
                return kgToLbs(value);
            }
            return value;
        }
        
        function convertHeight(value, fromSystem, toSystem) {
            if (fromSystem === toSystem) return value;
            if (fromSystem === 'imperial' && toSystem === 'metric') {
                return inToCm(value);
            }
            if (fromSystem === 'metric' && toSystem === 'imperial') {
                return cmToIn(value);
            }
            return value;
        }
        
        function changeUnitSystem() {
            // Check which dropdown was changed
            const desktopSelect = document.getElementById('unitSystem');
            const mobileSelect = document.getElementById('unitSystemMobile');
            
            let newSystem;
            if (event && event.target) {
                newSystem = event.target.value;
            } else {
                newSystem = desktopSelect ? desktopSelect.value : 'imperial';
            }
            
            const oldSystem = currentUnitSystem;
            
            if (newSystem === oldSystem) return;
            
            // Sync both dropdowns
            if (desktopSelect) desktopSelect.value = newSystem;
            if (mobileSelect) mobileSelect.value = newSystem;
            
            // Convert existing values
            convertFormValues(oldSystem, newSystem);
            
            // Update current system
            currentUnitSystem = newSystem;
            
            // Update all labels
            updateUnitLabels();
            
            // Save preference
            localStorage.setItem('unitSystem', currentUnitSystem);
            
            // Show notification
            const systemName = newSystem === 'imperial' ? 'Imperial (lbs/inches)' : 'Metric (kg/cm)';
            showNotification('Units Changed', `Switched to ${systemName}`, 'success');
        }
        
        function convertFormValues(fromSystem, toSystem) {
            // Convert Macro Calculator values
            const weightInput = document.getElementById('weight');
            const heightInput = document.getElementById('height');
            
            if (weightInput && weightInput.value) {
                const currentValue = parseFloat(weightInput.value);
                const convertedValue = convertWeight(currentValue, fromSystem, toSystem);
                weightInput.value = convertedValue.toFixed(1);
            }
            
            if (heightInput && heightInput.value) {
                const currentValue = parseFloat(heightInput.value);
                const convertedValue = convertHeight(currentValue, fromSystem, toSystem);
                heightInput.value = convertedValue.toFixed(1);
            }
            
            // Convert Progress Tracker values
            const progressWeight = document.getElementById('progressEntryWeight');
            const progressWaist = document.getElementById('progressEntryWaist');
            const progressChest = document.getElementById('progressEntryChest');
            const progressHips = document.getElementById('progressEntryHips');
            const progressArms = document.getElementById('progressEntryArms');
            const targetWeight = document.getElementById('targetWeight');
            
            if (progressWeight && progressWeight.value) {
                const currentValue = parseFloat(progressWeight.value);
                const convertedValue = convertWeight(currentValue, fromSystem, toSystem);
                progressWeight.value = convertedValue.toFixed(1);
            }
            
            if (targetWeight && targetWeight.value) {
                const currentValue = parseFloat(targetWeight.value);
                const convertedValue = convertWeight(currentValue, fromSystem, toSystem);
                targetWeight.value = convertedValue.toFixed(1);
            }
            
            // Convert body measurements
            const measurementInputs = [progressWaist, progressChest, progressHips, progressArms];
            measurementInputs.forEach(input => {
                if (input && input.value) {
                    const currentValue = parseFloat(input.value);
                    const convertedValue = convertHeight(currentValue, fromSystem, toSystem);
                    input.value = convertedValue.toFixed(1);
                }
            });
        }
        
        // Mobile Sidebar Functions
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar-menu');
            const overlay = document.getElementById('sidebar-overlay');
            const body = document.body;
            
            if (sidebar.classList.contains('sidebar-open')) {
                closeSidebar();
            } else {
                openSidebar();
            }
        }
        
        function openSidebar() {
            const sidebar = document.getElementById('sidebar-menu');
            const overlay = document.getElementById('sidebar-overlay');
            const body = document.body;
            
            sidebar.classList.add('sidebar-open');
            overlay.classList.add('sidebar-overlay-visible');
            body.classList.add('sidebar-no-scroll');
            
            // Sync unit system with desktop
            const desktopSelect = document.getElementById('unitSystem');
            const mobileSelect = document.getElementById('mobile-unit-system');
            if (desktopSelect && mobileSelect) {
                mobileSelect.value = desktopSelect.value;
            }
        }
        
        function closeSidebar() {
            const sidebar = document.getElementById('sidebar-menu');
            const overlay = document.getElementById('sidebar-overlay');
            const body = document.body;
            
            sidebar.classList.remove('sidebar-open');
            overlay.classList.remove('sidebar-overlay-visible');
            body.classList.remove('sidebar-no-scroll');
        }
        
        function changeUnitSystemMobile() {
            // Get the mobile select value and update desktop
            const mobileSelect = document.getElementById('mobile-unit-system');
            const desktopSelect = document.getElementById('unitSystem');
            
            if (mobileSelect && desktopSelect) {
                desktopSelect.value = mobileSelect.value;
                // Trigger the existing changeUnitSystem function
                changeUnitSystem();
            }
        }
        
        function handleAuthMobile() {
            // Close sidebar first, then handle auth
            closeSidebar();
            setTimeout(() => handleAuth(), 300); // Small delay for smooth animation
        }
        
        function updateUnitLabels() {
            const weightUnit = getWeightUnit();
            const heightUnit = getHeightUnit();
            
            // Update Macro Calculator labels
            const weightLabel = document.querySelector('label[for="weight"]');
            const heightLabel = document.querySelector('label[for="height"]');
            
            if (weightLabel) weightLabel.textContent = `Weight (${weightUnit})`;
            if (heightLabel) heightLabel.textContent = `Height (${heightUnit})`;
            
            // Update Progress Tracker labels
            const progressWeightLabel = document.querySelector('label[for="progressEntryWeight"]');
            const progressWaistLabel = document.querySelector('label[for="progressEntryWaist"]');
            const progressChestLabel = document.querySelector('label[for="progressEntryChest"]');
            const progressHipsLabel = document.querySelector('label[for="progressEntryHips"]');
            const progressArmsLabel = document.querySelector('label[for="progressEntryArms"]');
            const targetWeightLabel = document.querySelector('label[for="targetWeight"]');
            
            if (progressWeightLabel) progressWeightLabel.textContent = `Weight (${weightUnit})`;
            if (progressWaistLabel) progressWaistLabel.textContent = `Waist (${heightUnit})`;
            if (progressChestLabel) progressChestLabel.textContent = `Chest (${heightUnit})`;
            if (progressHipsLabel) progressHipsLabel.textContent = `Hips (${heightUnit})`;
            if (progressArmsLabel) progressArmsLabel.textContent = `Arms (${heightUnit})`;
            if (targetWeightLabel) targetWeightLabel.textContent = `Target Weight (${weightUnit})`;
            
            // Update placeholders
            updatePlaceholders();
            
            // Update displayed statistics
            updateDisplayedStats();
            
            // Refresh progress display when units change
            if (typeof refreshProgressDisplay === 'function') {
                refreshProgressDisplay();
            }
        }
        
        function updatePlaceholders() {
            const weightInput = document.getElementById('weight');
            const heightInput = document.getElementById('height');
            const progressWeight = document.getElementById('progressEntryWeight');
            const progressWaist = document.getElementById('progressEntryWaist');
            const progressChest = document.getElementById('progressEntryChest');
            const progressHips = document.getElementById('progressEntryHips');
            const progressArms = document.getElementById('progressEntryArms');
            const targetWeight = document.getElementById('targetWeight');
            
            if (currentUnitSystem === 'imperial') {
                if (weightInput) weightInput.placeholder = '152.19';
                if (heightInput) heightInput.placeholder = '68';
                if (progressWeight) progressWeight.placeholder = '150.0';
                if (progressWaist) progressWaist.placeholder = '32.0';
                if (progressChest) progressChest.placeholder = '38.0';
                if (progressHips) progressHips.placeholder = '36.0';
                if (progressArms) progressArms.placeholder = '13.0';
                if (targetWeight) targetWeight.placeholder = '150';
            } else {
                if (weightInput) weightInput.placeholder = '69.1';
                if (heightInput) heightInput.placeholder = '173';
                if (progressWeight) progressWeight.placeholder = '68.0';
                if (progressWaist) progressWaist.placeholder = '81.3';
                if (progressChest) progressChest.placeholder = '96.5';
                if (progressHips) progressHips.placeholder = '91.4';
                if (progressArms) progressArms.placeholder = '33.0';
                if (targetWeight) targetWeight.placeholder = '68';
            }
        }
        
        function updateDisplayedStats() {
            // Update any displayed statistics that show units
            const currentWeightEl = document.getElementById('currentWeight');
            const latestWaistEl = document.getElementById('latestWaist');
            const latestChestEl = document.getElementById('latestChest');
            const latestHipsEl = document.getElementById('latestHips');
            const latestArmsEl = document.getElementById('latestArms');
            
            // Update unit labels in statistics display
            const unitLabels = document.querySelectorAll('.unit-label');
            unitLabels.forEach(label => {
                if (label.textContent.includes('lbs') || label.textContent.includes('kg')) {
                    label.textContent = getWeightUnit();
                } else if (label.textContent.includes('inches') || label.textContent.includes('cm')) {
                    label.textContent = getHeightUnit();
                }
            });
        }
        
        function initializeUnitSystem() {
            // Load saved unit preference
            const savedUnit = localStorage.getItem('unitSystem');
            if (savedUnit) {
                currentUnitSystem = savedUnit;
                const desktopSelect = document.getElementById('unitSystem');
                const mobileSelect = document.getElementById('unitSystemMobile');
                if (desktopSelect) desktopSelect.value = savedUnit;
                if (mobileSelect) mobileSelect.value = savedUnit;
            }
            
            // Update labels for current system
            updateUnitLabels();
        }

        // Global variables - Initialize with defaults but check for existing values
        let dailyTargets;
        
        // Initialize dailyTargets with proper fallback logic
        function initializeDailyTargets() {
            if (!dailyTargets) {
                // Try to load from localStorage first
                const savedTargets = localStorage.getItem('dailyTargets');
                if (savedTargets && savedTargets !== 'null') {
                    try {
                        const parsed = JSON.parse(savedTargets);
                        if (parsed && parsed.calories > 0 && parsed.protein > 0) {
                            dailyTargets = parsed;
                            console.log('✅ Daily targets initialized from localStorage:', dailyTargets);
                            return;
                        }
                    } catch (error) {
                        console.warn('⚠️ Error parsing saved targets during initialization:', error);
                    }
                }
                
                // Use defaults if no valid saved data
                dailyTargets = {
                    calories: 2000,
                    protein: 150,
                    carbs: 250,
                    fat: 67
                };
                console.log('ℹ️ Daily targets initialized with defaults:', dailyTargets);
            }
        }
        
        // Initialize immediately
        initializeDailyTargets();
        
        // Function to ensure display elements match dailyTargets values
        function ensureDisplaySync() {
            if (document.getElementById('dailyCalories')) {
                const currentCalories = document.getElementById('dailyCalories').textContent;
                const currentProtein = document.getElementById('proteinAmount').textContent;
                const currentCarbs = document.getElementById('carbsAmount').textContent;
                const currentFat = document.getElementById('fatAmount').textContent;
                
                // Update if display shows default placeholders or doesn't match current values
                if (currentCalories === '2,000' || 
                    currentProtein === '150g' || 
                    currentCarbs === '250g' || 
                    currentFat === '67g' ||
                    currentCalories !== dailyTargets.calories.toLocaleString()) {
                    
                    console.log('🔄 Synchronizing display with dailyTargets:', dailyTargets);
                    document.getElementById('dailyCalories').textContent = dailyTargets.calories.toLocaleString();
                    document.getElementById('proteinAmount').textContent = dailyTargets.protein + 'g';
                    document.getElementById('carbsAmount').textContent = dailyTargets.carbs + 'g';
                    document.getElementById('fatAmount').textContent = dailyTargets.fat + 'g';
                }
            }
        }

        let currentIntake = {
            protein: 0,
            carbs: 0,
            fat: 0
        };

        let meals = [];
        let charts = {};

        // Custom Notification System
        function showNotification(title, message, type = 'success', duration = 4000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            
            const icons = {
                success: 'fas fa-check-circle',
                warning: 'fas fa-exclamation-triangle',
                error: 'fas fa-times-circle',
                info: 'fas fa-info-circle'
            };
            
            notification.innerHTML = `
                <div class="notification-content">
                    <i class="${icons[type]} notification-icon"></i>
                    <div class="notification-text">
                        <div class="notification-title">${title}</div>
                        <div class="notification-message">${message}</div>
                    </div>
                    <button class="notification-close" onclick="closeNotification(this.parentElement.parentElement)">&times;</button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Trigger animation with mobile fix
            setTimeout(() => {
                notification.classList.add('show');
                notification.style.opacity = '1';
                notification.style.visibility = 'visible';
            }, 100);
            
            // Auto remove
            setTimeout(() => {
                closeNotification(notification);
            }, duration);
        }
        
        function closeNotification(notification) {
            notification.classList.remove('show');
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.parentElement.removeChild(notification);
                }
            }, 300);
        }
        
        // Custom Confirm Dialog
        function showConfirmDialog(title, message, onConfirm, onCancel = null) {
            const modal = document.createElement('div');
            modal.className = 'custom-modal';
            
            modal.innerHTML = `
                <div class="custom-modal-content">
                    <div class="modal-icon">
                        <i class="fas fa-question-circle text-yellow-500"></i>
                    </div>
                    <div class="modal-title">${title}</div>
                    <div class="modal-message">${message}</div>
                    <div class="modal-buttons">
                        <button class="modal-btn modal-btn-secondary" onclick="closeModal(this)">Cancel</button>
                        <button class="modal-btn modal-btn-primary" onclick="confirmAction(this)">Confirm</button>
                    </div>
                </div>
            `;
            
            modal.querySelector('.modal-btn-primary').addEventListener('click', () => {
                onConfirm();
                closeModal(modal);
            });
            
            modal.querySelector('.modal-btn-secondary').addEventListener('click', () => {
                if (onCancel) onCancel();
                closeModal(modal);
            });
            
            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    if (onCancel) onCancel();
                    closeModal(modal);
                }
            });
            
            document.body.appendChild(modal);
        }
        
        function closeModal(modal) {
            if (typeof modal === 'string' || modal.tagName === 'BUTTON') {
                modal = modal.closest ? modal.closest('.custom-modal') : document.querySelector('.custom-modal');
            }
            if (modal && modal.parentElement) {
                modal.parentElement.removeChild(modal);
            }
        }

        // Function to update calorie display with total from all meals
        function updateCalorieDisplay() {
            try {
                let totalCalories = 0;
                
                // Calculate total calories from all meals
                if (meals && meals.length > 0) {
                    totalCalories = meals.reduce((total, meal) => {
                        return total + (parseFloat(meal.calories) || 0);
                    }, 0);
                }
                
                // Update the planned calories display
                const plannedCaloriesElement = document.getElementById('planned-calories');
                if (plannedCaloriesElement) {
                    plannedCaloriesElement.textContent = Math.round(totalCalories);
                }
                
                logger.debug('📊 Updated calorie display:', totalCalories, 'calories from', meals?.length || 0, 'meals');
            } catch (error) {
                logger.error('❌ Error updating calorie display:', error);
            }
        }

        // Function to refresh all meal-related displays after initialization
        function refreshMealDisplays() {
            try {
                // Only refresh if we have meals loaded
                if (meals && meals.length > 0) {
                    console.log('🔄 Refreshing meal displays after initialization...', meals.length, 'meals');
                    
                    // Update meal list
                    updateMealsList();
                    
                    // Update progress bars and charts
                    updateProgress();
                    
                    // Update macro charts
                    updateMacroCharts();
                    
                    // Update calorie display
                    updateCalorieDisplay();
                    
                    console.log('✅ Meal displays refreshed successfully');
                } else {
                    console.log('ℹ️ No meals to display - skipping meal display refresh');
                }
            } catch (error) {
                console.warn('⚠️ Error refreshing meal displays:', error);
            }
        }
        
        // Make functions available globally for button onclick
        window.loadAndPopulatePersonalInfo = loadAndPopulatePersonalInfo;
        window.loadTodayMeals = loadTodayMeals;
        
        window.confirmAction = function(button) {
            // This will be handled by the event listener
        };
        
        window.closeModal = closeModal;

        // Function to test critical button functionality
        function testAllButtons() {
            const criticalFunctions = [
                'calculateMacros', 'addMeal', 'resetTracker',
                'exportMealPlanPDF', 'exportMealPlanCSV', 'exportGroceryList',
                'selectDay', 'copyToTracker', 'clearMealPlan', 'handleAuth',
                'changeUnitSystem', 'showNotification', 'showConfirmDialog'
            ];
            
            const results = [];
            
            criticalFunctions.forEach(funcName => {
                if (typeof window[funcName] === 'function') {
                    results.push(`✅ ${funcName}: Available`);
                } else {
                    results.push(`❌ ${funcName}: Missing`);
                }
            });
            
            console.log('🧪 Button Function Test Results:');
            results.forEach(result => console.log(result));
            
            return results;
        }
        
        // Make testAllButtons available globally for debugging
        window.testAllButtons = testAllButtons;

        // ====================================================================
        // CUSTOM SECTION FUNCTIONALITY FOR MEAL PLANNER
        // ====================================================================

        // Custom sections state (now supports multiple)
        let customSections = []; // Array to store multiple custom sections
        let customSectionCounter = 0; // Counter for unique IDs

        function toggleAddCustomSection() {
            const config = document.getElementById('customSectionConfig');
            const toggleBtn = document.getElementById('toggleAddCustomBtn');
            
            if (config.classList.contains('hidden')) {
                config.classList.remove('hidden');
                config.classList.add('custom-section-transition');
                toggleBtn.innerHTML = '<i class="fas fa-times mr-1"></i>Cancel';
                toggleBtn.onclick = cancelAddCustomSection;
                // Focus on the input
                document.getElementById('customSectionName').focus();
            } else {
                cancelAddCustomSection();
            }
        }
        
        function cancelAddCustomSection() {
            const config = document.getElementById('customSectionConfig');
            const toggleBtn = document.getElementById('toggleAddCustomBtn');
            const nameInput = document.getElementById('customSectionName');
            
            config.classList.add('hidden');
            toggleBtn.innerHTML = '<i class="fas fa-plus mr-1"></i>Add';
            toggleBtn.onclick = toggleAddCustomSection;
            nameInput.value = '';
        }

        function createCustomSection() {
            const nameInput = document.getElementById('customSectionName');
            const sectionName = nameInput.value.trim();
            
            if (!sectionName) {
                showNotification('Invalid Name', 'Please enter a name for your custom section', 'warning');
                nameInput.focus();
                return;
            }
            
            // Check if section name already exists
            if (customSections.find(section => section.name.toLowerCase() === sectionName.toLowerCase())) {
                showNotification('Duplicate Name', 'A section with this name already exists', 'warning');
                nameInput.focus();
                return;
            }
            
            // Create new custom section
            customSectionCounter++;
            const sectionId = `custom_${customSectionCounter}`;
            const newSection = {
                id: sectionId,
                name: sectionName,
                meals: {}
            };
            
            customSections.push(newSection);
            
            // Enable custom sections flag
            customSectionEnabled = true;
            
            // Add custom section to meal plan data structure
            Object.keys(mealPlan).forEach(day => {
                if (!mealPlan[day][sectionId]) {
                    mealPlan[day][sectionId] = [];
                }
            });
            
            // Create and add the custom section HTML
            createCustomSectionHTML(newSection);
            
            // Reset the form
            cancelAddCustomSection();
            
            // Update display and save
            updateMealPlanDisplay();
            saveMealPlan().catch(error => console.warn('Meal plan save error:', error));
            
            showNotification('Custom Section Created', `"${sectionName}" section has been added to your meal planner!`, 'success');
        }

        function removeCustomSection(sectionId) {
            const section = customSections.find(s => s.id === sectionId);
            if (!section) return;
            
            showConfirmDialog(
                'Remove Custom Section',
                `Are you sure you want to remove the "${section.name}" section? All items in this section will be deleted.`,
                () => {
                    // Remove from customSections array
                    const index = customSections.findIndex(s => s.id === sectionId);
                    if (index > -1) {
                        customSections.splice(index, 1);
                    }
                    
                    // Remove from meal plan data structure
                    Object.keys(mealPlan).forEach(day => {
                        if (mealPlan[day][sectionId]) {
                            delete mealPlan[day][sectionId];
                        }
                    });
                    
                    // Remove the HTML element
                    const sectionElement = document.getElementById(`customSection_${sectionId}`);
                    if (sectionElement) {
                        sectionElement.remove();
                    }
                    
                    // Update custom sections enabled flag
                    customSectionEnabled = customSections.length > 0;
                    
                    // Update display and save
                    updateMealPlanDisplay();
                    saveMealPlan().catch(error => console.warn('Meal plan save error:', error));
                    
                    showNotification('Section Removed', `"${section.name}" section has been removed from your meal planner`, 'success');
                }
            );
        }
        
        // Create HTML for a custom section
        function createCustomSectionHTML(section) {
            const container = document.getElementById('customSectionsContainer');
            
            const sectionHTML = `
                <div id="customSection_${section.id}" class="bg-white p-4 rounded-lg border mb-4">
                    <h4 class="font-bold text-blue-600 mb-3">
                        <i class="fas fa-star mr-2"></i><span>${section.name}</span>
                    </h4>
                    <div class="space-y-2 mb-3">
                        <input type="text" id="${section.id}-meal" placeholder="Item name" class="w-full p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500">
                        <div class="grid grid-cols-2 gap-2">
                            <input type="number" id="${section.id}-calories" placeholder="Calories" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" step="1">
                            <input type="number" id="${section.id}-protein" placeholder="Protein (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" step="0.1">
                            <input type="number" id="${section.id}-carbs" placeholder="Carbs (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" step="0.1">
                            <input type="number" id="${section.id}-fat" placeholder="Fat (g)" class="p-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500" step="0.1">
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="addPlannedMeal('${section.id}')" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-3 rounded text-sm font-medium">
                            <i class="fas fa-plus mr-1"></i>Add
                        </button>
                        <button onclick="removeCustomSection('${section.id}')" class="bg-red-500 hover:bg-red-600 text-white py-2 px-3 rounded text-sm font-medium" title="Remove custom section">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    <div id="${section.id}-list" class="mt-3 space-y-1"></div>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', sectionHTML);
        }

        // ====================================================================
        // END CUSTOM SECTION FUNCTIONALITY
        // ====================================================================

        // Old initialization removed - using new unified initialization below

        function calculateMacros() {
            console.log('Calculating macros...');
            
            const age = parseFloat(document.getElementById('age').value) || 25;
            const gender = document.getElementById('gender').value;
            const weight = parseFloat(document.getElementById('weight').value) || 152.19;
            const height = parseFloat(document.getElementById('height').value) || 66.9291;
            const activity = parseFloat(document.getElementById('activity').value) || 1.55;
            const goal = parseFloat(document.getElementById('goal').value) || -500;

            // Convert to metric for BMR calculation
            let weightKg, heightCm;
            if (currentUnitSystem === 'imperial') {
                weightKg = weight * 0.453592; // lbs to kg
                heightCm = height * 2.54; // inches to cm
            } else {
                weightKg = weight; // already in kg
                heightCm = height; // already in cm
            }

            // Calculate BMR using Harris-Benedict equation
            let bmr;
            if (gender === 'male') {
                bmr = 88.362 + (13.397 * weightKg) + (4.799 * heightCm) - (5.677 * age);
            } else {
                bmr = 447.593 + (9.247 * weightKg) + (3.098 * heightCm) - (4.330 * age);
            }

            // Calculate TDEE and adjust for goal
            const tdee = bmr * activity;
            const dailyCalories = Math.round(tdee + goal);

            // Calculate macros (40% carbs, 30% protein, 30% fat)
            const protein = Math.round((dailyCalories * 0.30) / 4);
            const carbs = Math.round((dailyCalories * 0.40) / 4);
            const fat = Math.round((dailyCalories * 0.30) / 9);

            // Update targets
            dailyTargets = {
                calories: dailyCalories,
                protein: protein,
                carbs: carbs,
                fat: fat
            };

            // Update display
            document.getElementById('dailyCalories').textContent = dailyCalories.toLocaleString();
            document.getElementById('proteinAmount').textContent = protein + 'g';
            document.getElementById('carbsAmount').textContent = carbs + 'g';
            document.getElementById('fatAmount').textContent = fat + 'g';

            // IMPORTANT: Recalculate currentIntake from existing meals to preserve data
            if (meals && meals.length > 0) {
                console.log('Preserving existing meal data...');
                currentIntake = {
                    protein: meals.reduce((sum, meal) => sum + (meal.protein || 0), 0),
                    carbs: meals.reduce((sum, meal) => sum + (meal.carbs || 0), 0),
                    fat: meals.reduce((sum, meal) => sum + (meal.fat || 0), 0)
                };
                console.log('Recalculated currentIntake from existing meals:', currentIntake);
            }
            
            // Update progress will handle chart updates based on actual data
            updateProgress();
            updateRecommendations(goal);

            // Save to localStorage (for offline access)
            localStorage.setItem('dailyTargets', JSON.stringify(dailyTargets));
            localStorage.setItem('unitSystem', currentUnitSystem);
            
            // Save to dedicated Supabase tables (with independent error handling)
            const saveOperations = async () => {
                const results = [];
                
                try {
                    // Save daily targets
                    const targetsResult = await saveDailyTargets({
                        calories: dailyCalories,
                        protein: protein,
                        carbs: carbs,
                        fat: fat
                    });
                    results.push({ targets: targetsResult });
                } catch (error) {
                    console.warn('⚠️ Daily targets save failed:', error.message);
                    results.push({ targets: { error: error.message } });
                }
                
                try {
                    // Save user preferences
                    const prefsResult = await saveUserPreferences({
                        unitSystem: currentUnitSystem
                    });
                    results.push({ preferences: prefsResult });
                } catch (error) {
                    console.warn('⚠️ User preferences save failed:', error.message);
                    results.push({ preferences: { error: error.message } });
                }
                
                try {
                    // Save calculation result for history
                    const calcResult = await saveMacroCalculation({
                        age: age,
                        gender: gender,
                        weight: weight,
                        height: height,
                        activityLevel: activity,
                        goalCalories: goal,
                        bmr: Math.round(bmr),
                        tdee: Math.round(tdee),
                        targetCalories: dailyCalories,
                        targetProtein: protein,
                        targetCarbs: carbs,
                        targetFat: fat,
                        inputUnitSystem: currentUnitSystem
                    });
                    results.push({ calculation: calcResult });
                } catch (error) {
                    console.warn('⚠️ Calculation save failed:', error.message);
                    results.push({ calculation: { error: error.message } });
                }
                
                console.log('💾 Data save operations completed:', results);
                setTimeout(checkAuthStatus, 500);
            };
            
            // Execute save operations without blocking the UI
            saveOperations().catch(error => {
                console.warn('⚠️ Save operations error:', error.message);
                setTimeout(checkAuthStatus, 500);
            });
            
            // Ensure display remains synchronized after calculation
            ensureDisplaySync();
            
            showNotification('Macros Calculated', `Daily targets: ${dailyCalories} calories, ${protein}g protein, ${carbs}g carbs, ${fat}g fat`, 'success');
        }

        function initializeMacroDoughnutCharts() {
            console.log('Initializing macro doughnut charts...');
            
            // Destroy existing doughnut charts first to prevent canvas conflicts
            if (charts.calories) {
                charts.calories.destroy();
                console.log('🗑️ Destroyed existing calories chart');
            }
            if (charts.protein) {
                charts.protein.destroy();
                console.log('🗑️ Destroyed existing protein chart');
            }
            if (charts.carbs) {
                charts.carbs.destroy();
                console.log('🗑️ Destroyed existing carbs chart');
            }
            if (charts.fat) {
                charts.fat.destroy();
                console.log('🗑️ Destroyed existing fat chart');
            }
            
            const chartOptions = {
                type: 'doughnut',
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%',
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    animation: {
                        animateRotate: true,
                        duration: 1000
                    }
                }
            };

            try {
                // Calories chart
                const caloriesCanvas = document.getElementById('caloriesChart');
                if (caloriesCanvas) {
                    charts.calories = new Chart(caloriesCanvas, {
                        ...chartOptions,
                        data: {
                            datasets: [{
                                data: [0, 100],
                                backgroundColor: ['#3b82f6', '#bfdbfe'],
                                borderWidth: 0
                            }]
                        }
                    });
                    console.log('Calories chart created');
                }

                // Protein chart
                const proteinCanvas = document.getElementById('proteinChart');
                if (proteinCanvas) {
                    charts.protein = new Chart(proteinCanvas, {
                        ...chartOptions,
                        data: {
                            datasets: [{
                                data: [0, 100],
                                backgroundColor: ['#ef4444', '#fecaca'],
                                borderWidth: 0
                            }]
                        }
                    });
                    console.log('Protein chart created');
                }

                // Carbs chart
                const carbsCanvas = document.getElementById('carbsChart');
                if (carbsCanvas) {
                    charts.carbs = new Chart(carbsCanvas, {
                        ...chartOptions,
                        data: {
                            datasets: [{
                                data: [0, 100],
                                backgroundColor: ['#22c55e', '#bbf7d0'],
                                borderWidth: 0
                            }]
                        }
                    });
                    console.log('Carbs chart created');
                }

                // Fat chart
                const fatCanvas = document.getElementById('fatChart');
                if (fatCanvas) {
                    charts.fat = new Chart(fatCanvas, {
                        ...chartOptions,
                        data: {
                            datasets: [{
                                data: [0, 100],
                                backgroundColor: ['#eab308', '#fef3c7'],
                                borderWidth: 0
                            }]
                        }
                    });
                    console.log('Fat chart created');
                }
                
            } catch (error) {
                console.error('Error initializing macro doughnut charts:', error);
            }
        }

        function updateCharts() {
            if (!allChartsInitialized) {
                console.log('Charts not yet initialized, skipping update');
                return;
            }
            
            try {
                // Calculate actual progress based on current intake
                const caloriesConsumed = meals.reduce((sum, meal) => sum + (meal.calories || 0), 0);
                const caloriesPercent = dailyTargets.calories > 0 ? Math.min((caloriesConsumed / dailyTargets.calories) * 100, 100) : 0;
                const proteinPercent = dailyTargets.protein > 0 ? Math.min((currentIntake.protein / dailyTargets.protein) * 100, 100) : 0;
                const carbsPercent = dailyTargets.carbs > 0 ? Math.min((currentIntake.carbs / dailyTargets.carbs) * 100, 100) : 0;
                const fatPercent = dailyTargets.fat > 0 ? Math.min((currentIntake.fat / dailyTargets.fat) * 100, 100) : 0;
                
                // Update calories chart with actual progress
                if (charts.calories) {
                    charts.calories.data.datasets[0].data = [caloriesPercent, 100 - caloriesPercent];
                    charts.calories.update('none');
                    console.log('Updated calories chart with actual progress:', caloriesPercent + '%');
                }

                // Update protein chart with actual progress
                if (charts.protein) {
                    charts.protein.data.datasets[0].data = [proteinPercent, 100 - proteinPercent];
                    charts.protein.update('none');
                    console.log('Updated protein chart with actual progress:', proteinPercent + '%');
                }

                // Update carbs chart with actual progress
                if (charts.carbs) {
                    charts.carbs.data.datasets[0].data = [carbsPercent, 100 - carbsPercent];
                    charts.carbs.update('none');
                    console.log('Updated carbs chart with actual progress:', carbsPercent + '%');
                }

                // Update fat chart with actual progress
                if (charts.fat) {
                    charts.fat.data.datasets[0].data = [fatPercent, 100 - fatPercent];
                    charts.fat.update('none');
                    console.log('Updated fat chart with actual progress:', fatPercent + '%');
                }
            } catch (error) {
                console.error('Error updating doughnut charts:', error);
            }
        }

        function addMeal() {
            const name = document.getElementById('mealName').value.trim();
            const calories = parseFloat(document.getElementById('mealCalories').value) || 0;
            const protein = parseFloat(document.getElementById('mealProtein').value) || 0;
            const carbs = parseFloat(document.getElementById('mealCarbs').value) || 0;
            const fat = parseFloat(document.getElementById('mealFat').value) || 0;

            if (!name) {
                showNotification('Missing Information', 'Please enter a meal name', 'warning');
                return;
            }

            const meal = {
                id: Date.now(),
                name: name,
                protein: protein,
                carbs: carbs,
                fat: fat,
                calories: calories || Math.round((protein * 4) + (carbs * 4) + (fat * 9))
            };

            meals.push(meal);
            currentIntake.protein += protein;
            currentIntake.carbs += carbs;
            currentIntake.fat += fat;

            // Clear form
            document.getElementById('mealName').value = '';
            document.getElementById('mealCalories').value = '';
            document.getElementById('mealProtein').value = '';
            document.getElementById('mealCarbs').value = '';
            document.getElementById('mealFat').value = '';

            updateMealsList();
            updateProgress();
            saveData();
            saveDailyMacros().catch(error => console.error('Error saving daily macros:', error)); // Save daily macro progress
            
            showNotification('Meal Added', `${meal.name} has been added to your tracker!`, 'success');
        }

        function deleteMeal(id) {
            const meal = meals.find(m => m.id === id);
            if (meal) {
                currentIntake.protein -= meal.protein;
                currentIntake.carbs -= meal.carbs;
                currentIntake.fat -= meal.fat;
                meals = meals.filter(m => m.id !== id);
                updateMealsList();
                updateProgress();
                saveData();
                saveDailyMacros().catch(error => console.error('Error saving daily macros:', error)); // Save daily macro progress
                
                showNotification('Meal Deleted', 'Meal has been removed from your tracker', 'info');
            }
        }

        function updateMealsList() {
            const mealsList = document.getElementById('mealsList');
            mealsList.innerHTML = '';

            if (meals.length === 0) {
                mealsList.innerHTML = '<p class="text-gray-500 text-center py-4">No meals logged yet. Add your first meal above!</p>';
                return;
            }

            meals.forEach(meal => {
                const mealDiv = document.createElement('div');
                mealDiv.className = 'meal-item bg-white border border-gray-200 rounded-lg p-4 flex justify-between items-center';
                mealDiv.innerHTML = `
                    <div>
                        <h4 class="font-medium text-gray-800">${meal.name}</h4>
                        <div class="text-sm text-gray-600 mt-1">
                            <span class="text-red-600">P: ${meal.protein}g</span> |
                            <span class="text-green-600">C: ${meal.carbs}g</span> |
                            <span class="text-yellow-600">F: ${meal.fat}g</span> |
                            <span class="text-blue-600">${meal.calories} cal</span>
                        </div>
                    </div>
                    <button onclick="deleteMeal(${meal.id})" class="text-red-500 hover:text-red-700 p-2">
                        <i class="fas fa-trash"></i>
                    </button>
                `;
                mealsList.appendChild(mealDiv);
            });
        }

        function updateProgress() {
            // Calculate current calories from meals
            const currentCalories = meals.reduce((sum, meal) => sum + meal.calories, 0);
            
            // Update progress bars
            const caloriesPercent = Math.min((currentCalories / dailyTargets.calories) * 100, 100);
            const proteinPercent = Math.min((currentIntake.protein / dailyTargets.protein) * 100, 100);
            const carbsPercent = Math.min((currentIntake.carbs / dailyTargets.carbs) * 100, 100);
            const fatPercent = Math.min((currentIntake.fat / dailyTargets.fat) * 100, 100);

            // Calculate overall daily progress (average of all macros)
            const overallProgress = Math.round((caloriesPercent + proteinPercent + carbsPercent + fatPercent) / 4);

            // Update bars
            document.getElementById('caloriesBar').style.width = caloriesPercent + '%';
            document.getElementById('proteinBar').style.width = proteinPercent + '%';
            document.getElementById('carbsBar').style.width = carbsPercent + '%';
            document.getElementById('fatBar').style.width = fatPercent + '%';

            // Update text displays
            document.getElementById('caloriesProgress').textContent = `${Math.round(currentCalories)} / ${dailyTargets.calories}`;
            document.getElementById('proteinProgress').textContent = `${Math.round(currentIntake.protein)}g / ${dailyTargets.protein}g`;
            document.getElementById('carbsProgress').textContent = `${Math.round(currentIntake.carbs)}g / ${dailyTargets.carbs}g`;
            document.getElementById('fatProgress').textContent = `${Math.round(currentIntake.fat)}g / ${dailyTargets.fat}g`;

            // Update daily progress percentage with color coding
            const dailyProgressElement = document.getElementById('dailyProgress');
            dailyProgressElement.textContent = `${overallProgress}%`;
            
            // Color coding for progress
            const progressContainer = dailyProgressElement.parentElement;
            if (overallProgress >= 90) {
                progressContainer.className = 'bg-green-50 border border-green-200 rounded-full px-4 py-2';
                dailyProgressElement.className = 'font-bold text-green-700';
            } else if (overallProgress >= 70) {
                progressContainer.className = 'bg-yellow-50 border border-yellow-200 rounded-full px-4 py-2';
                dailyProgressElement.className = 'font-bold text-yellow-700';
            } else if (overallProgress >= 50) {
                progressContainer.className = 'bg-blue-50 border border-blue-200 rounded-full px-4 py-2';
                dailyProgressElement.className = 'font-bold text-blue-700';
            } else {
                progressContainer.className = 'bg-red-50 border border-red-200 rounded-full px-4 py-2';
                dailyProgressElement.className = 'font-bold text-red-700';
            }

            // Update doughnut charts
            if (allChartsInitialized && charts.calories && charts.protein && charts.carbs && charts.fat) {
                try {
                    // Calculate calories progress
                    const currentCalories = meals.reduce((sum, meal) => sum + meal.calories, 0);
                    const caloriesPercent = Math.min((currentCalories / dailyTargets.calories) * 100, 100);
                    
                    charts.calories.data.datasets[0].data = [caloriesPercent, 100 - caloriesPercent];
                    charts.protein.data.datasets[0].data = [proteinPercent, 100 - proteinPercent];
                    charts.carbs.data.datasets[0].data = [carbsPercent, 100 - carbsPercent];
                    charts.fat.data.datasets[0].data = [fatPercent, 100 - fatPercent];

                    charts.calories.update('none');
                    charts.protein.update('none');
                    charts.carbs.update('none');
                    charts.fat.update('none');
                } catch (error) {
                    console.error('Error updating progress charts:', error);
                }
            }
        }

        function resetTracker() {
            showConfirmDialog(
                'Reset Daily Tracker',
                'Are you sure you want to reset today\'s tracking? This will clear all logged meals and cannot be undone.',
                () => {
                    meals = [];
                    currentIntake = { protein: 0, carbs: 0, fat: 0 };
                    updateMealsList();
                    updateProgress();
                    saveData();
                    showNotification('Tracker Reset', 'Daily tracking has been successfully reset', 'success');
                }
            );
        }

        function updateRecommendations(goal) {
            const recommendations = document.getElementById('recommendations');
            let tips = [];

            if (goal < 0) {
                tips = [
                    '• Focus on high-protein foods to maintain muscle mass',
                    '• Eat nutrient-dense, low-calorie foods',
                    '• Stay hydrated and consider intermittent fasting',
                    '• Include fiber-rich vegetables for satiety'
                ];
            } else if (goal > 0) {
                tips = [
                    '• Eat in a slight caloric surplus for lean gains',
                    '• Time carbs around your workouts',
                    '• Focus on compound exercises and progressive overload',
                    '• Get adequate sleep for muscle recovery'
                ];
            } else {
                tips = [
                    '• Maintain balanced macronutrient ratios',
                    '• Focus on whole, unprocessed foods',
                    '• Stay consistent with your eating schedule',
                    '• Monitor body composition over weight'
                ];
            }

            recommendations.innerHTML = tips.map(tip => `<li>${tip}</li>`).join('');
        }

        function saveData() {
            // Always save to localStorage immediately
            localStorage.setItem('meals', JSON.stringify(meals));
            localStorage.setItem('currentIntake', JSON.stringify(currentIntake));
            localStorage.setItem('lastSaved', new Date().toDateString());
            
            // Try to save to database in background
            setTimeout(async () => {
                try {
                    console.log('💾 Attempting to save to database...');
                    console.log('📧 Current user email:', getCurrentUserEmail());
                    console.log('🍽️ Meals to save:', meals.length, 'meals');
                    
                    // Save meals to database
                    const mealSaveResult = await saveDailyMeals(meals);
                    console.log('✅ Meals save result:', mealSaveResult);
                    
                    // Save user profile with current targets and settings
                    const userInfo = localStorage.getItem('user_info');
                    const userName = userInfo ? JSON.parse(userInfo).name : '';
                    
                    const profileSaveResult = await saveUserProfile({
                        name: userName,
                        unitSystem: currentUnitSystem,
                        dailyTargets: dailyTargets
                    });
                    console.log('✅ Profile save result:', profileSaveResult);
                    
                    console.log('🎉 Data saved to permanent storage successfully');
                } catch (error) {
                    console.error('❌ Database save failed:', error);
                    console.log('💽 Data saved locally only:', error.message);
                }
            }, 100);
        }

        async function loadBasicStoredData() {
            console.log('Loading basic stored data (localStorage only)...');
            
            // Always try localStorage first to ensure app works
            const savedTargets = localStorage.getItem('dailyTargets');
            const savedMeals = localStorage.getItem('meals');
            const savedIntake = localStorage.getItem('currentIntake');
            const lastSaved = localStorage.getItem('lastSaved');

            // Reset if it's a new day
            const today = new Date().toDateString();
            console.log('📅 Day check:', { lastSaved, today, isNewDay: lastSaved && lastSaved !== today });
            
            if (lastSaved && lastSaved !== today) {
                console.log('🗑️ New day detected - clearing yesterday\'s meal data');
                localStorage.removeItem('meals');
                localStorage.removeItem('currentIntake');
                console.log('✅ Cleared old day data from localStorage');
            } else {
                console.log('📱 Same day or no previous date - loading existing meal data');
                if (savedTargets) {
                    dailyTargets = JSON.parse(savedTargets);
                    const caloriesEl = document.getElementById('dailyCalories');
                    const proteinEl = document.getElementById('proteinAmount');
                    const carbsEl = document.getElementById('carbsAmount');
                    const fatEl = document.getElementById('fatAmount');
                    
                    if (caloriesEl) caloriesEl.textContent = dailyTargets.calories.toLocaleString();
                    if (proteinEl) proteinEl.textContent = dailyTargets.protein + 'g';
                    if (carbsEl) carbsEl.textContent = dailyTargets.carbs + 'g';
                    if (fatEl) fatEl.textContent = dailyTargets.fat + 'g';
                    
                    console.log('Loaded daily targets from localStorage:', dailyTargets);
                }

                if (savedMeals) {
                    meals = JSON.parse(savedMeals);
                    console.log('Loaded meals from localStorage:', meals.length, 'meals');
                    
                    // Recalculate current intake from loaded meals (in case localStorage is out of sync)
                    currentIntake = { protein: 0, carbs: 0, fat: 0 };
                    meals.forEach(meal => {
                        currentIntake.protein += meal.protein || 0;
                        currentIntake.carbs += meal.carbs || 0;
                        currentIntake.fat += meal.fat || 0;
                    });
                    
                    // Update all displays
                    updateMealsList();
                    console.log('Recalculated current intake from meals:', currentIntake);
                } else if (savedIntake) {
                    currentIntake = JSON.parse(savedIntake);
                    console.log('Loaded current intake from localStorage:', currentIntake);
                } else {
                    // Initialize empty intake if nothing saved
                    currentIntake = { protein: 0, carbs: 0, fat: 0 };
                }
            }
            
            console.log('Basic data loading complete - database loading will happen after authentication');
        }

        async function loadStoredData() {
            console.log('Loading stored data...');
            
            // Always try localStorage first to ensure app works
            const savedTargets = localStorage.getItem('dailyTargets');
            const savedMeals = localStorage.getItem('meals');
            const savedIntake = localStorage.getItem('currentIntake');
            const lastSaved = localStorage.getItem('lastSaved');

            // Reset if it's a new day
            const today = new Date().toDateString();
            if (lastSaved && lastSaved !== today) {
                localStorage.removeItem('meals');
                localStorage.removeItem('currentIntake');
            } else {
                if (savedTargets) {
                    dailyTargets = JSON.parse(savedTargets);
                    const caloriesEl = document.getElementById('dailyCalories');
                    const proteinEl = document.getElementById('proteinAmount');
                    const carbsEl = document.getElementById('carbsAmount');
                    const fatEl = document.getElementById('fatAmount');
                    
                    if (caloriesEl) caloriesEl.textContent = dailyTargets.calories.toLocaleString();
                    if (proteinEl) proteinEl.textContent = dailyTargets.protein + 'g';
                    if (carbsEl) carbsEl.textContent = dailyTargets.carbs + 'g';
                    if (fatEl) fatEl.textContent = dailyTargets.fat + 'g';
                }

                if (savedMeals) {
                    meals = JSON.parse(savedMeals);
                    updateMealsList();
                }

                if (savedIntake) {
                    currentIntake = JSON.parse(savedIntake);
                }
            }
            
            // Try to load from database in background (non-blocking)
            setTimeout(async () => {
                try {
                    console.log('Attempting to load from permanent storage...');
                    
                    // Load user profile (targets and settings) 
                    const profile = await loadUserProfile();
                    if (profile) {
                        console.log('Profile loaded from database');
                        
                        // Update daily targets if available
                        if (profile.dailyTargets && Object.keys(profile.dailyTargets).length > 0) {
                            dailyTargets = profile.dailyTargets;
                            const caloriesEl = document.getElementById('dailyCalories');
                            const proteinEl = document.getElementById('proteinAmount');
                            const carbsEl = document.getElementById('carbsAmount');
                            const fatEl = document.getElementById('fatAmount');
                            
                            if (caloriesEl) caloriesEl.textContent = dailyTargets.calories.toLocaleString();
                            if (proteinEl) proteinEl.textContent = dailyTargets.protein + 'g';
                            if (carbsEl) carbsEl.textContent = dailyTargets.carbs + 'g';
                            if (fatEl) fatEl.textContent = dailyTargets.fat + 'g';
                        }
                        
                        // Update unit system
                        if (profile.unitSystem) {
                            currentUnitSystem = profile.unitSystem;
                            const desktopSelect = document.getElementById('unitSystem');
                            const mobileSelect = document.getElementById('unitSystemMobile');
                            if (desktopSelect) desktopSelect.value = profile.unitSystem;
                            if (mobileSelect) mobileSelect.value = profile.unitSystem;
                            updateUnitLabels();
                        }
                        
                        console.log('Database connected - data is permanently stored and synced');
                    }
                    
                    // Load today's meals
                    const todayMeals = await loadDailyMeals();
                    if (todayMeals && todayMeals.length > 0) {
                        meals = todayMeals;
                        
                        // Recalculate current intake
                        currentIntake = { protein: 0, carbs: 0, fat: 0 };
                        meals.forEach(meal => {
                            currentIntake.protein += meal.protein || 0;
                            currentIntake.carbs += meal.carbs || 0;
                            currentIntake.fat += meal.fat || 0;
                        });
                        
                        updateMealsList();
                        updateProgress();
                    }
                    
                    // Load custom recipes
                    const customRecipesFromDB = await loadCustomRecipes();
                    if (customRecipesFromDB && customRecipesFromDB.length > 0) {
                        customRecipes = customRecipesFromDB;
                        displayRecipes();
                    }
                    
                } catch (error) {
                    console.log('Database not available, using localStorage only:', error.message);
                    // App continues to work with localStorage
                }
            }, 1000); // Delay to ensure UI is ready
            
            // Load meal plan data
            loadMealPlan().catch(error => console.warn('Meal plan load error:', error));
        }

        // Meal Planning Functions
        let mealPlan = {
            monday: { breakfast: [], lunch: [], dinner: [] },
            tuesday: { breakfast: [], lunch: [], dinner: [] },
            wednesday: { breakfast: [], lunch: [], dinner: [] },
            thursday: { breakfast: [], lunch: [], dinner: [] },
            friday: { breakfast: [], lunch: [], dinner: [] },
            saturday: { breakfast: [], lunch: [], dinner: [] },
            sunday: { breakfast: [], lunch: [], dinner: [] }
        };

        let currentSelectedDay = 'monday';

        function selectDay(day) {
            currentSelectedDay = day;
            
            // Update button states
            document.querySelectorAll('.day-btn').forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-blue-100', 'text-blue-800');
            });
            
            document.getElementById(`btn-${day}`).classList.remove('bg-blue-100', 'text-blue-800');
            document.getElementById(`btn-${day}`).classList.add('bg-blue-500', 'text-white');
            
            // Update current day display
            document.getElementById('currentDay').textContent = day.charAt(0).toUpperCase() + day.slice(1);
            
            // Refresh meal displays
            updateMealPlanDisplay();
        }

        function addPlannedMeal(mealType) {
            const mealName = document.getElementById(`${mealType}-meal`).value.trim();
            const calories = parseFloat(document.getElementById(`${mealType}-calories`).value) || 0;
            const protein = parseFloat(document.getElementById(`${mealType}-protein`).value) || 0;
            const carbs = parseFloat(document.getElementById(`${mealType}-carbs`).value) || 0;
            const fat = parseFloat(document.getElementById(`${mealType}-fat`).value) || 0;

            if (!mealName) {
                showNotification('Missing Information', 'Please enter a meal name', 'warning');
                return;
            }

            const plannedMeal = {
                id: Date.now(),
                name: mealName,
                calories: calories,
                protein: protein,
                carbs: carbs,
                fat: fat
            };

            mealPlan[currentSelectedDay][mealType].push(plannedMeal);

            // Clear form
            document.getElementById(`${mealType}-meal`).value = '';
            document.getElementById(`${mealType}-calories`).value = '';
            document.getElementById(`${mealType}-protein`).value = '';
            document.getElementById(`${mealType}-carbs`).value = '';
            document.getElementById(`${mealType}-fat`).value = '';

            updateMealPlanDisplay();
            saveMealPlan().catch(error => console.warn('Meal plan save error:', error));
        }

        function deletePlannedMeal(mealType, mealId) {
            mealPlan[currentSelectedDay][mealType] = mealPlan[currentSelectedDay][mealType].filter(meal => meal.id !== mealId);
            updateMealPlanDisplay();
            saveMealPlan().catch(error => console.warn('Meal plan save error:', error));
        }

        function updateMealPlanDisplay() {
            const dayPlan = mealPlan[currentSelectedDay];
            
            // Update meal lists (including custom section if enabled)
            const mealTypes = ['breakfast', 'lunch', 'dinner'];
            if (customSectionEnabled) {
                mealTypes.push('custom');
            }
            
            mealTypes.forEach(mealType => {
                const listElement = document.getElementById(`${mealType}-list`);
                if (!listElement) return; // Skip if element doesn't exist
                
                listElement.innerHTML = '';
                
                // Ensure the meal type exists in the day plan
                if (!dayPlan[mealType]) {
                    dayPlan[mealType] = [];
                }
                
                dayPlan[mealType].forEach(meal => {
                    const mealDiv = document.createElement('div');
                    mealDiv.className = 'bg-gray-50 p-2 rounded text-xs flex justify-between items-center';
                    mealDiv.innerHTML = `
                        <div>
                            <div class="font-medium">${meal.name}</div>
                            <div class="text-gray-600">${meal.calories} cal • ${meal.protein}g P • ${meal.carbs || 0}g C • ${meal.fat || 0}g F</div>
                        </div>
                        <button onclick="deletePlannedMeal('${mealType}', ${meal.id})" class="text-red-500 hover:text-red-700 text-xs">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    listElement.appendChild(mealDiv);
                });
            });

            // Update daily summary
            let totalCalories = 0;
            let totalProtein = 0;
            let totalCarbs = 0;
            let totalFat = 0;
            let totalMeals = 0;

            Object.values(dayPlan).forEach(meals => {
                meals.forEach(meal => {
                    totalCalories += meal.calories || 0;
                    totalProtein += meal.protein || 0;
                    totalCarbs += meal.carbs || 0;
                    totalFat += meal.fat || 0;
                    totalMeals++;
                });
            });

            document.getElementById('planned-calories').textContent = totalCalories;
            document.getElementById('planned-protein').textContent = Math.round(totalProtein) + 'g';
            document.getElementById('planned-carbs').textContent = Math.round(totalCarbs) + 'g';
            document.getElementById('planned-fat').textContent = Math.round(totalFat) + 'g';
            document.getElementById('planned-meals').textContent = totalMeals;
        }



        function copyToTracker() {
            const dayPlan = mealPlan[currentSelectedDay];
            let copiedCount = 0;

            Object.values(dayPlan).forEach(mealsList => {
                mealsList.forEach(meal => {
                    // Add to current day's tracking
                    const trackingMeal = {
                        id: Date.now() + Math.random(),
                        name: meal.name,
                        protein: meal.protein || 0,
                        carbs: meal.carbs || 0,
                        fat: meal.fat || 0,
                        calories: meal.calories || 0
                    };

                    // Add to the global meals array (not the local forEach variable)
                    meals.push(trackingMeal);
                    
                    // Update ALL macros in currentIntake
                    currentIntake.protein += trackingMeal.protein;
                    currentIntake.carbs += trackingMeal.carbs;
                    currentIntake.fat += trackingMeal.fat;
                    
                    copiedCount++;
                });
            });

            if (copiedCount > 0) {
                updateMealsList();
                updateProgress();
                saveData();
                saveDailyMacros().catch(error => console.error('Error saving daily macros:', error)); // Also save to macro history
                showNotification('Meals Copied', `${copiedCount} meals successfully copied to today's tracker!`, 'success');
            } else {
                showNotification('No Meals Found', 'No meals to copy from the selected day', 'info');
            }
        }

        function clearMealPlan() {
            showConfirmDialog(
                'Clear Meal Plan',
                'Are you sure you want to clear the entire meal plan? This will remove all planned meals for all days and cannot be undone.',
                () => {
                    mealPlan = {
                        monday: { breakfast: [], lunch: [], dinner: [] },
                        tuesday: { breakfast: [], lunch: [], dinner: [] },
                        wednesday: { breakfast: [], lunch: [], dinner: [] },
                        thursday: { breakfast: [], lunch: [], dinner: [] },
                        friday: { breakfast: [], lunch: [], dinner: [] },
                        saturday: { breakfast: [], lunch: [], dinner: [] },
                        sunday: { breakfast: [], lunch: [], dinner: [] }
                    };
                    updateMealPlanDisplay();
                    saveMealPlan().catch(error => console.warn('Meal plan save error:', error));
                    showNotification('Meal Plan Cleared', 'All planned meals have been successfully removed', 'success');
                }
            );
        }

        async function saveMealPlan() {
            // Always save to localStorage first (immediate backup)
            localStorage.setItem('mealPlan', JSON.stringify(mealPlan));
            localStorage.setItem('customSections', JSON.stringify(customSections));
            
            // Save to Supabase database for cross-device sync
            try {
                await saveMealPlanToDatabase();
            } catch (error) {
                console.warn('⚠️ Failed to sync meal plan to database:', error.message);
            }
        }

        async function saveMealPlanToDatabase() {
            if (!window.supabaseClient && !window.apiCall) {
                console.log('ℹ️ No database connection available for meal plan sync');
                return;
            }

            console.log('💾 Syncing meal plan to database (New Schema)...');

            try {
                // Get current user context for new schema
                const userContext = await getCurrentUserContext();
                
                // Prepare meal plan data for new schema
                const mealPlanData = {
                    user_id: userContext.user_id,
                    anon_profile_id: userContext.anon_profile_id,
                    week_data: mealPlan, // Store as JSONB directly (not stringified)
                    updated_at: new Date().toISOString()
                };

                let supabaseSuccess = false;

                // Try Supabase first (if available)
                if (window.supabaseClient) {
                    try {
                        // Build where clause based on user type
                        let whereClause = {};
                        if (userContext.type === 'authenticated') {
                            whereClause.user_id = userContext.user_id;
                        } else {
                            whereClause.anon_profile_id = userContext.anon_profile_id;
                        }
                        
                        // Check if meal plan exists for this user
                        const { data: existing, error: selectError } = await window.supabaseClient
                            .from('meal_plans')
                            .select('*')
                            .match(whereClause)
                            .maybeSingle();

                        if (existing && !selectError) {
                            // Update existing meal plan
                            const { data, error } = await window.supabaseClient
                                .from('meal_plans')
                                .update(mealPlanData)
                                .match(whereClause)
                                .select();
                            
                            if (error) {
                                console.warn('⚠️ Supabase meal plan update failed:', error.message);
                                throw error;
                            }
                            console.log('✅ Meal plan updated in Supabase (New Schema):', data);
                            supabaseSuccess = true;
                        } else {
                            // Create new meal plan
                            const { data, error } = await window.supabaseClient
                                .from('meal_plans')
                                .insert(mealPlanData)
                                .select();
                            
                            if (error) {
                                console.warn('⚠️ Supabase meal plan insert failed:', error.message);
                                throw error;
                            }
                            console.log('✅ Meal plan created in Supabase (New Schema):', data);
                            supabaseSuccess = true;
                        }
                    } catch (supabaseError) {
                        console.error('❌ Supabase meal plan operation failed:', supabaseError.message);
                        
                        // Check if it's a schema-related error
                        if (supabaseError.message && (
                            supabaseError.message.includes('week_data') || 
                            supabaseError.message.includes('column') ||
                            supabaseError.message.includes('PGRST')
                        )) {
                            console.log('🔄 Schema mismatch detected, falling back to RESTful API...');
                        }
                        // Continue to RESTful API fallback
                    }
                }

                // Fallback to RESTful API (if Supabase not available or failed)
                if (!supabaseSuccess && window.apiCall) {
                    console.log('📡 Using RESTful API for meal plan save (New Schema)...');
                    
                    // For RESTful API, we need to convert JSONB back to string
                    const apiMealPlanData = {
                        ...mealPlanData,
                        week_data: JSON.stringify(mealPlan) // Convert back to string for RESTful API
                    };
                    
                    // Check if meal plan exists using UUID-based search
                    const searchField = userContext.type === 'authenticated' ? 'user_id' : 'anon_profile_id';
                    const searchValue = userContext.type === 'authenticated' ? userContext.user_id : userContext.anon_profile_id;
                    
                    // Use direct Supabase query to avoid PGRST100 errors
                    console.log('🔍 Loading existing meal plans with safe query for:', searchValue);
                    let query = window.supabaseClient.from('meal_plans').select('*');
                    if (window.SupabaseQueryHelper) {
                        query = window.SupabaseQueryHelper.applySearchFilter(query, searchValue, 'meal_plans');
                    } else {
                        // Determine field based on searchValue type (UUID vs email)
                        const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(searchValue);
                        const field = isUUID ? 'user_id' : 'user_email';
                        query = query.eq(field, searchValue);
                    }
                    const { data: existingData, error: existingError } = await query;
                    if (existingError) throw existingError;
                    
                    const existingResponse = { data: existingData };
                    
                    if (existingResponse.data && existingResponse.data.length > 0) {
                        // Find the correct user's meal plan
                        const userMealPlan = existingResponse.data.find(plan => plan[searchField] === searchValue);
                        
                        if (userMealPlan) {
                            // Update existing
                            await apiCall(`tables/meal_plans/${userMealPlan.id}`, 'PUT', apiMealPlanData);
                            console.log('✅ Meal plan updated via RESTful API (New Schema)');
                        } else {
                            // Create new - no existing meal plan found for this user
                            await apiCall('tables/meal_plans', 'POST', apiMealPlanData);
                            console.log('✅ Meal plan created via RESTful API (New Schema)');
                        }
                    } else {
                        // Create new - no meal plans exist at all
                        await apiCall('tables/meal_plans', 'POST', apiMealPlanData);
                        console.log('✅ Meal plan created via RESTful API (New Schema)');
                    }
                }

            } catch (error) {
                console.error('❌ Failed to save meal plan to database:', error);
                throw error;
            }
        }

        async function loadMealPlan() {
            console.log('📡 Loading meal plan data...');
            
            try {
                // First try to load from database
                const databaseData = await loadMealPlanFromDatabase();
                
                if (databaseData) {
                    console.log('✅ Meal plan loaded from database');
                    mealPlan = databaseData.mealPlan;
                    customSections = databaseData.customSections || [];
                } else {
                    // Fallback to localStorage
                    console.log('📱 Loading meal plan from localStorage...');
                    const savedMealPlan = localStorage.getItem('mealPlan');
                    if (savedMealPlan) {
                        mealPlan = JSON.parse(savedMealPlan);
                    }
                    
                    // Load custom sections from localStorage
                    const savedCustomSections = localStorage.getItem('customSections');
                    if (savedCustomSections) {
                        customSections = JSON.parse(savedCustomSections);
                    } else {
                        // Migration: Convert old single custom section to new format
                        const savedCustomEnabled = localStorage.getItem('customSectionEnabled');
                        const savedCustomName = localStorage.getItem('customSectionName');
                        
                        if (savedCustomEnabled === 'true' && savedCustomName) {
                            customSectionCounter = 1;
                            customSections = [{
                                id: 'custom_1',
                                name: savedCustomName,
                                meals: {}
                            }];
                            // Clean up old localStorage items
                            localStorage.removeItem('customSectionEnabled');
                            localStorage.removeItem('customSectionName');
                        }
                    }
                }
                
                // Restore UI state for custom sections
                if (customSections && customSections.length > 0) {
                    // Set counter to highest existing ID + 1
                    const maxId = Math.max(...customSections.map(s => parseInt(s.id.split('_')[1]) || 0));
                    customSectionCounter = maxId;
                    
                    // Enable custom sections flag
                    customSectionEnabled = true;
                    
                    // Recreate HTML for each custom section
                    customSections.forEach(section => {
                        createCustomSectionHTML(section);
                    });
                    
                    console.log(`🔄 Restored ${customSections.length} custom sections`);
                } else {
                    customSectionEnabled = false;
                }
                
            } catch (error) {
                console.warn('⚠️ Error loading meal plan:', error.message);
                // Continue with localStorage data as fallback
                const savedMealPlan = localStorage.getItem('mealPlan');
                if (savedMealPlan) {
                    mealPlan = JSON.parse(savedMealPlan);
                }
            }
            
            selectDay('monday'); // Initialize with Monday selected
        }

        async function loadMealPlanFromDatabase() {
            if (!window.supabaseClient && !window.apiCall) {
                return null;
            }

            console.log('📡 Loading meal plan from database (New Schema)...');
            
            try {
                // Get current user context for new schema
                const userContext = await getCurrentUserContext();
                
                // Try Supabase first
                if (window.supabaseClient) {
                    // Build where clause based on user type
                    let whereClause = {};
                    if (userContext.type === 'authenticated') {
                        whereClause.user_id = userContext.user_id;
                    } else {
                        whereClause.anon_profile_id = userContext.anon_profile_id;
                    }
                    
                    const { data, error } = await window.supabaseClient
                        .from('meal_plans')
                        .select('*')
                        .match(whereClause)
                        .order('updated_at', { ascending: false })
                        .limit(1)
                        .maybeSingle();

                    if (error) {
                        console.warn('⚠️ Supabase meal plan load error:', error.message);
                        throw error; // Fall through to RESTful API
                    }

                    if (data) {
                        console.log('✅ Meal plan loaded from Supabase (New Schema)');
                        return {
                            mealPlan: data.week_data, // Already JSONB, no need to parse
                            customSectionEnabled: false,
                            customSectionName: ''
                        };
                    }
                }

                // Fallback to RESTful API
                if (window.apiCall) {
                    console.log('📡 Using RESTful API for meal plan load (New Schema)...');
                    
                    // Use UUID-based search instead of email
                    const searchField = userContext.type === 'authenticated' ? 'user_id' : 'anon_profile_id';
                    const searchValue = userContext.type === 'authenticated' ? userContext.user_id : userContext.anon_profile_id;
                    
                    // Use direct Supabase query to avoid PGRST100 errors
                    console.log('🔍 Loading meal plans with safe query for:', searchValue);
                    let query = window.supabaseClient.from('meal_plans').select('*');
                    if (window.SupabaseQueryHelper) {
                        query = window.SupabaseQueryHelper.applySearchFilter(query, searchValue, 'meal_plans');
                    } else {
                        // Determine field based on searchValue type (UUID vs email)
                        const isUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(searchValue);
                        const field = isUUID ? 'user_id' : 'user_email';
                        query = query.eq(field, searchValue);
                    }
                    query = query.order('updated_at', { ascending: false });
                    const { data: responseData, error: responseError } = await query;
                    if (responseError) throw responseError;
                    
                    const response = { data: responseData };
                    
                    if (response.data && response.data.length > 0) {
                        // Filter to ensure we get the right user's data
                        const userMealPlan = response.data.find(plan => plan[searchField] === searchValue);
                        
                        if (userMealPlan) {
                            console.log('✅ Meal plan loaded from RESTful API (New Schema)');
                            return {
                                mealPlan: JSON.parse(userMealPlan.week_data), // RESTful API still uses JSON string
                                customSectionEnabled: false,
                                customSectionName: ''
                            };
                        }
                    }
                }

                return null;

            } catch (error) {
                console.error('❌ Database meal plan load failed:', error);
                return null;
            }
        }

        // Recipe Database Functions
        let recipes = [
            {
                id: 1,
                name: "Veggie Omelet Wrap",
                category: "breakfast",
                calories: 310,
                protein: 26,
                carbs: 28,
                fat: 12,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "7 min",
                ingredients: ["Egg whites", "spinach", "mushrooms", "whole wheat tortilla", "feta"],
                instructions: "Whisk egg whites and cook in a pan. Add spinach and mushrooms. Place filling in tortilla with feta and wrap.",
                source: "default"
            },
            {
                id: 2,
                name: "Quinoa & Black Bean Bowl",
                category: "lunch",
                calories: 420,
                protein: 19,
                carbs: 60,
                fat: 12,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "15 min",
                ingredients: ["Quinoa", "black beans", "corn", "bell peppers", "avocado"],
                instructions: "Cook quinoa according to package directions. Mix with black beans, corn, bell peppers. Top with avocado.",
                source: "default"
            },
            {
                id: 3,
                name: "Honey Garlic Shrimp Stir-Fry",
                category: "dinner",
                calories: 380,
                protein: 32,
                carbs: 45,
                fat: 8,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "10 min",
                ingredients: ["Shrimp", "broccoli", "snap peas", "soy sauce", "honey"],
                instructions: "Heat oil in pan, cook shrimp until pink. Add vegetables and stir-fry. Mix in honey and soy sauce.",
                source: "default"
            },
            {
                id: 4,
                name: "Greek Yogurt Berry Bowl",
                category: "snack",
                calories: 250,
                protein: 20,
                carbs: 32,
                fat: 5,
                servings: "1 serving",
                prepTime: "3 min",
                cookTime: "0 min",
                ingredients: ["Greek yogurt", "mixed berries", "honey", "chia seeds"],
                instructions: "Layer Greek yogurt in bowl. Top with mixed berries, drizzle with honey, and sprinkle chia seeds.",
                source: "default"
            },
            {
                id: 5,
                name: "Beef & Brown Rice Stuffed Peppers",
                category: "dinner",
                calories: 460,
                protein: 34,
                carbs: 48,
                fat: 14,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "30 min",
                ingredients: ["Lean ground beef", "bell peppers", "brown rice", "tomato sauce", "mozzarella"],
                instructions: "Cook beef and rice. Hollow out peppers. Mix beef, rice, and sauce. Stuff peppers, top with cheese, bake 30 min.",
                source: "default"
            },
            {
                id: 6,
                name: "Avocado Toast with Poached Egg",
                category: "breakfast",
                calories: 330,
                protein: 16,
                carbs: 30,
                fat: 18,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "5 min",
                ingredients: ["Whole grain bread", "avocado", "egg", "olive oil", "lemon juice"],
                instructions: "Toast bread. Mash avocado with lemon juice. Poach egg. Top toast with avocado and egg. Drizzle with olive oil.",
                source: "default"
            },
            {
                id: 7,
                name: "Chicken Caesar Wrap",
                category: "lunch",
                calories: 410,
                protein: 32,
                carbs: 36,
                fat: 14,
                servings: "1 serving",
                prepTime: "8 min",
                cookTime: "0 min",
                ingredients: ["Grilled chicken", "whole wheat tortilla", "romaine", "parmesan", "Caesar dressing"],
                instructions: "Place grilled chicken on tortilla with romaine lettuce. Add parmesan and Caesar dressing. Wrap tightly.",
                source: "default"
            },
            {
                id: 8,
                name: "Baked Salmon with Veggies",
                category: "dinner",
                calories: 480,
                protein: 40,
                carbs: 20,
                fat: 28,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "20 min",
                ingredients: ["Salmon fillet", "zucchini", "asparagus", "olive oil", "lemon"],
                instructions: "Season salmon with lemon and olive oil. Arrange with vegetables on baking sheet. Bake at 400°F for 20 minutes.",
                source: "default"
            },
            {
                id: 9,
                name: "Cottage Cheese & Pineapple Cup",
                category: "snack",
                calories: 220,
                protein: 18,
                carbs: 24,
                fat: 6,
                servings: "1 serving",
                prepTime: "2 min",
                cookTime: "0 min",
                ingredients: ["Cottage cheese", "pineapple", "walnuts"],
                instructions: "Scoop cottage cheese into bowl. Top with pineapple chunks and chopped walnuts.",
                source: "default"
            },
            {
                id: 10,
                name: "Lentil & Spinach Soup",
                category: "dinner",
                calories: 290,
                protein: 18,
                carbs: 42,
                fat: 6,
                servings: "3 servings",
                prepTime: "10 min",
                cookTime: "25 min",
                ingredients: ["Lentils", "spinach", "carrots", "onions", "vegetable broth"],
                instructions: "Sauté onions and carrots. Add lentils and broth. Simmer 20 min. Add spinach and cook until wilted.",
                source: "default"
            },
            {
                id: 11,
                name: "Turkey & Avocado Sandwich",
                category: "lunch",
                calories: 350,
                protein: 28,
                carbs: 34,
                fat: 12,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "0 min",
                ingredients: ["Whole grain bread", "turkey breast", "avocado", "tomato", "lettuce"],
                instructions: "Toast bread if desired. Layer turkey, sliced avocado, tomato, and lettuce between bread slices.",
                source: "default"
            },
            {
                id: 12,
                name: "Banana Protein Smoothie",
                category: "breakfast",
                calories: 280,
                protein: 25,
                carbs: 36,
                fat: 5,
                servings: "1 serving",
                prepTime: "3 min",
                cookTime: "0 min",
                ingredients: ["Banana", "whey protein powder", "almond milk", "oats"],
                instructions: "Blend banana, protein powder, almond milk, and oats until smooth. Add ice if desired.",
                source: "default"
            },
            {
                id: 13,
                name: "Chickpea & Veggie Curry",
                category: "dinner",
                calories: 400,
                protein: 16,
                carbs: 58,
                fat: 12,
                servings: "3 servings",
                prepTime: "12 min",
                cookTime: "20 min",
                ingredients: ["Chickpeas", "coconut milk", "curry paste", "spinach", "basmati rice"],
                instructions: "Cook rice. Sauté curry paste, add chickpeas and coconut milk. Simmer 15 min. Add spinach. Serve over rice.",
                source: "default"
            },
            {
                id: 14,
                name: "Apple Cinnamon Overnight Oats",
                category: "breakfast",
                calories: 310,
                protein: 18,
                carbs: 44,
                fat: 8,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "0 min",
                ingredients: ["Oats", "almond milk", "apple", "cinnamon", "protein powder"],
                instructions: "Mix oats, protein powder, and cinnamon. Add almond milk and diced apple. Refrigerate overnight.",
                source: "default"
            },
            {
                id: 15,
                name: "Hummus & Veggie Plate",
                category: "snack",
                calories: 240,
                protein: 10,
                carbs: 28,
                fat: 10,
                servings: "2 servings",
                prepTime: "5 min",
                cookTime: "0 min",
                ingredients: ["Hummus", "carrots", "cucumbers", "cherry tomatoes", "pita bread"],
                instructions: "Cut vegetables into sticks or slices. Serve with hummus and pita bread for dipping.",
                source: "default"
            },
            {
                id: 16,
                name: "Teriyaki Chicken Rice Bowl",
                category: "lunch",
                calories: 450,
                protein: 34,
                carbs: 56,
                fat: 10,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "15 min",
                ingredients: ["Chicken breast", "jasmine rice", "broccoli", "teriyaki sauce", "sesame seeds"],
                instructions: "Cook rice and steam broccoli. Grill chicken with teriyaki sauce. Serve over rice with broccoli and sesame seeds.",
                source: "default"
            },
            {
                id: 17,
                name: "Spinach & Feta Egg Muffins",
                category: "breakfast",
                calories: 150,
                protein: 12,
                carbs: 6,
                fat: 9,
                servings: "4 servings",
                prepTime: "10 min",
                cookTime: "20 min",
                ingredients: ["Eggs", "spinach", "feta", "onions", "bell peppers"],
                instructions: "Whisk eggs, add chopped vegetables and feta. Pour into muffin tins. Bake at 350°F for 20 minutes.",
                source: "default"
            },
            {
                id: 18,
                name: "Grilled Tofu & Veggie Skewers",
                category: "dinner",
                calories: 310,
                protein: 20,
                carbs: 22,
                fat: 15,
                servings: "2 servings",
                prepTime: "12 min",
                cookTime: "12 min",
                ingredients: ["Firm tofu", "zucchini", "bell peppers", "soy sauce", "olive oil"],
                instructions: "Cut tofu and vegetables into chunks. Thread onto skewers. Brush with soy sauce and oil. Grill 12 minutes.",
                source: "default"
            },
            {
                id: 19,
                name: "Tuna Salad Lettuce Wraps",
                category: "lunch",
                calories: 280,
                protein: 26,
                carbs: 10,
                fat: 15,
                servings: "2 servings",
                prepTime: "7 min",
                cookTime: "0 min",
                ingredients: ["Canned tuna", "Greek yogurt", "celery", "lettuce", "mustard"],
                instructions: "Mix tuna with Greek yogurt, diced celery, and mustard. Serve in large lettuce leaves as wraps.",
                source: "default"
            },
            {
                id: 20,
                name: "Dark Chocolate Protein Bites",
                category: "snack",
                calories: 120,
                protein: 6,
                carbs: 12,
                fat: 6,
                servings: "10 servings",
                prepTime: "10 min",
                cookTime: "0 min",
                ingredients: ["Oats", "whey protein", "dark chocolate", "peanut butter", "honey"],
                instructions: "Mix all ingredients in bowl. Roll into small balls. Refrigerate for 30 minutes to set.",
                source: "default"
            },
            {
                id: 21,
                name: "Chicken & Veggie Stir-Fry with Noodles",
                category: "dinner",
                calories: 420,
                protein: 32,
                carbs: 50,
                fat: 10,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "12 min",
                ingredients: ["Chicken", "noodles", "bell peppers", "carrots", "soy sauce"],
                instructions: "Cook noodles. Stir-fry chicken until cooked. Add vegetables and cook 5 min. Toss with noodles and soy sauce.",
                source: "default"
            },
            {
                id: 22,
                name: "Peanut Butter Banana Toast",
                category: "breakfast",
                calories: 290,
                protein: 11,
                carbs: 38,
                fat: 12,
                servings: "1 serving",
                prepTime: "3 min",
                cookTime: "0 min",
                ingredients: ["Whole grain bread", "peanut butter", "banana", "chia seeds"],
                instructions: "Toast bread. Spread peanut butter. Top with sliced banana and sprinkle with chia seeds.",
                source: "default"
            },
            {
                id: 23,
                name: "Grilled Turkey Burgers",
                category: "lunch",
                calories: 370,
                protein: 32,
                carbs: 28,
                fat: 14,
                servings: "2 servings",
                prepTime: "8 min",
                cookTime: "12 min",
                ingredients: ["Ground turkey", "whole wheat buns", "lettuce", "tomato", "onion"],
                instructions: "Form turkey into patties. Grill 6 minutes per side. Serve on buns with lettuce, tomato, and onion.",
                source: "default"
            },
            {
                id: 24,
                name: "Sweet Potato & Black Bean Tacos",
                category: "dinner",
                calories: 320,
                protein: 12,
                carbs: 46,
                fat: 10,
                servings: "3 servings",
                prepTime: "12 min",
                cookTime: "20 min",
                ingredients: ["Sweet potatoes", "black beans", "tortillas", "avocado", "lime"],
                instructions: "Roast diced sweet potatoes 20 min. Warm beans and tortillas. Fill tacos with sweet potatoes, beans, avocado, and lime.",
                source: "default"
            },
            {
                id: 25,
                name: "Protein-Rich Chia Pudding",
                category: "snack",
                calories: 250,
                protein: 15,
                carbs: 28,
                fat: 9,
                servings: "2 servings",
                prepTime: "5 min",
                cookTime: "0 min",
                ingredients: ["Chia seeds", "almond milk", "protein powder", "strawberries"],
                instructions: "Mix chia seeds, protein powder, and almond milk. Refrigerate 4 hours. Top with strawberries before serving.",
                source: "default"
            },
            {
                id: 26,
                name: "Shrimp & Quinoa Salad",
                category: "lunch",
                calories: 390,
                protein: 34,
                carbs: 38,
                fat: 11,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "10 min",
                ingredients: ["Shrimp", "quinoa", "cucumber", "cherry tomatoes", "olive oil"],
                instructions: "Cook quinoa and shrimp. Let cool. Mix with diced cucumber, cherry tomatoes, and olive oil dressing.",
                source: "default"
            },
            {
                id: 27,
                name: "Oatmeal with Berries & Almonds",
                category: "breakfast",
                calories: 310,
                protein: 12,
                carbs: 48,
                fat: 9,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "5 min",
                ingredients: ["Oats", "blueberries", "almonds", "almond milk", "honey"],
                instructions: "Cook oats with almond milk. Top with blueberries, chopped almonds, and drizzle with honey.",
                source: "default"
            },
            {
                id: 28,
                name: "Grilled Chicken & Veggie Sheet Pan",
                category: "dinner",
                calories: 440,
                protein: 38,
                carbs: 36,
                fat: 14,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "20 min",
                ingredients: ["Chicken breast", "broccoli", "carrots", "olive oil", "garlic"],
                instructions: "Toss chicken and vegetables with olive oil and garlic. Spread on sheet pan. Bake at 425°F for 20 minutes.",
                source: "default"
            },
            {
                id: 29,
                name: "Cottage Cheese & Berry Parfait",
                category: "snack",
                calories: 230,
                protein: 20,
                carbs: 26,
                fat: 6,
                servings: "1 serving",
                prepTime: "4 min",
                cookTime: "0 min",
                ingredients: ["Cottage cheese", "strawberries", "granola", "honey"],
                instructions: "Layer cottage cheese with strawberries and granola in a glass. Drizzle with honey.",
                source: "default"
            },
            {
                id: 30,
                name: "Vegetable & Lentil Stew",
                category: "dinner",
                calories: 350,
                protein: 18,
                carbs: 52,
                fat: 8,
                servings: "3 servings",
                prepTime: "12 min",
                cookTime: "25 min",
                ingredients: ["Lentils", "carrots", "celery", "tomatoes", "broth"],
                instructions: "Sauté vegetables. Add lentils, tomatoes, and broth. Simmer 25 minutes until lentils are tender.",
                source: "default"
            },
            {
                id: 31,
                name: "Mediterranean Chickpea Salad",
                category: "lunch",
                calories: 340,
                protein: 14,
                carbs: 46,
                fat: 12,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "0 min",
                ingredients: ["Chickpeas", "cucumber", "tomatoes", "olives", "feta"],
                instructions: "Combine chickpeas, diced cucumber, tomatoes, olives, and crumbled feta. Toss with olive oil and lemon.",
                source: "default"
            },
            {
                id: 32,
                name: "Egg & Turkey Breakfast Burrito",
                category: "breakfast",
                calories: 390,
                protein: 28,
                carbs: 38,
                fat: 14,
                servings: "1 serving",
                prepTime: "7 min",
                cookTime: "5 min",
                ingredients: ["Eggs", "turkey", "tortilla", "salsa", "cheddar"],
                instructions: "Scramble eggs with turkey. Place in tortilla with cheese and salsa. Roll into burrito.",
                source: "default"
            },
            {
                id: 33,
                name: "Baked Cod with Lemon & Herbs",
                category: "dinner",
                calories: 360,
                protein: 34,
                carbs: 12,
                fat: 18,
                servings: "2 servings",
                prepTime: "8 min",
                cookTime: "18 min",
                ingredients: ["Cod", "lemon", "parsley", "olive oil", "garlic"],
                instructions: "Season cod with lemon, garlic, and herbs. Drizzle with olive oil. Bake at 400°F for 18 minutes.",
                source: "default"
            },
            {
                id: 34,
                name: "Spicy Lentil Wraps",
                category: "lunch",
                calories: 410,
                protein: 20,
                carbs: 54,
                fat: 12,
                servings: "2 servings",
                prepTime: "10 min",
                cookTime: "15 min",
                ingredients: ["Lentils", "wraps", "spinach", "sriracha", "carrots"],
                instructions: "Cook lentils with spices and sriracha. Fill wraps with lentil mixture, spinach, and grated carrots.",
                source: "default"
            },
            {
                id: 35,
                name: "Protein Pancakes with Blueberries",
                category: "breakfast",
                calories: 320,
                protein: 24,
                carbs: 42,
                fat: 8,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "8 min",
                ingredients: ["Oats", "whey protein", "egg whites", "blueberries", "almond milk"],
                instructions: "Blend oats, protein powder, egg whites, and almond milk. Cook like pancakes. Top with blueberries.",
                source: "default"
            },
            {
                id: 36,
                name: "Greek Chicken Souvlaki with Pita",
                category: "dinner",
                calories: 460,
                protein: 38,
                carbs: 46,
                fat: 14,
                servings: "2 servings",
                prepTime: "12 min",
                cookTime: "15 min",
                ingredients: ["Chicken", "pita bread", "tzatziki", "cucumber", "onions"],
                instructions: "Marinate and grill chicken chunks. Serve in pita with tzatziki, cucumber, and onions.",
                source: "default"
            },
            {
                id: 37,
                name: "Spaghetti with Turkey Meatballs",
                category: "dinner",
                calories: 480,
                protein: 36,
                carbs: 52,
                fat: 14,
                servings: "3 servings",
                prepTime: "12 min",
                cookTime: "25 min",
                ingredients: ["Ground turkey", "spaghetti", "marinara", "parmesan", "basil"],
                instructions: "Form turkey into meatballs and bake. Cook spaghetti. Combine with marinara sauce, meatballs, and parmesan.",
                source: "default"
            },
            {
                id: 38,
                name: "Grilled Chicken Bowl",
                category: "dinner",
                calories: 485,
                protein: 42,
                carbs: 28,
                fat: 18,
                servings: "1 serving",
                prepTime: "15 min",
                cookTime: "20 min",
                ingredients: ["Chicken breast", "quinoa", "vegetables", "olive oil"],
                instructions: "Grill seasoned chicken breast. Serve over quinoa with roasted vegetables drizzled with olive oil.",
                source: "default"
            },
            {
                id: 39,
                name: "Protein Pancakes",
                category: "breakfast",
                calories: 320,
                protein: 28,
                carbs: 24,
                fat: 8,
                servings: "2 servings",
                prepTime: "5 min",
                cookTime: "10 min",
                ingredients: ["Eggs", "protein powder", "oats", "banana"],
                instructions: "Blend eggs, protein powder, oats, and banana. Cook as pancakes on medium heat until golden.",
                source: "default"
            },
            {
                id: 40,
                name: "Salmon & Sweet Potato",
                category: "dinner",
                calories: 520,
                protein: 38,
                carbs: 35,
                fat: 22,
                servings: "1 serving",
                prepTime: "10 min",
                cookTime: "25 min",
                ingredients: ["Salmon fillet", "sweet potato", "asparagus"],
                instructions: "Bake salmon and sweet potato at 400°F. Steam asparagus. Season with herbs and serve together.",
                source: "default"
            },
            {
                id: 41,
                name: "Greek Yogurt Parfait",
                category: "snack",
                calories: 285,
                protein: 20,
                carbs: 32,
                fat: 8,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "0 min",
                ingredients: ["Greek yogurt", "berries", "granola", "honey"],
                instructions: "Layer Greek yogurt with berries and granola in a glass. Drizzle with honey.",
                source: "default"
            },
            {
                id: 42,
                name: "Turkey Meatballs",
                category: "lunch",
                calories: 340,
                protein: 32,
                carbs: 18,
                fat: 16,
                servings: "4 servings",
                prepTime: "15 min",
                cookTime: "25 min",
                ingredients: ["Ground turkey", "zucchini noodles", "marinara"],
                instructions: "Form turkey into meatballs and bake. Serve over spiralized zucchini noodles with marinara sauce.",
                source: "default"
            },
            {
                id: 43,
                name: "Overnight Oats",
                category: "breakfast",
                calories: 295,
                protein: 15,
                carbs: 45,
                fat: 8,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "0 min",
                ingredients: ["Oats", "protein powder", "almond milk", "chia"],
                instructions: "Mix oats, protein powder, chia seeds, and almond milk. Refrigerate overnight. Enjoy cold.",
                source: "default"
            },
            {
                id: 44,
                name: "Chicken Stir Fry",
                category: "dinner",
                calories: 425,
                protein: 35,
                carbs: 28,
                fat: 18,
                servings: "2 servings",
                prepTime: "15 min",
                cookTime: "12 min",
                ingredients: ["Chicken", "mixed vegetables", "brown rice"],
                instructions: "Cook brown rice. Stir-fry chicken until cooked through. Add mixed vegetables and cook until tender.",
                source: "default"
            },
            {
                id: 45,
                name: "Tuna Salad Wrap",
                category: "lunch",
                calories: 380,
                protein: 28,
                carbs: 32,
                fat: 15,
                servings: "1 serving",
                prepTime: "8 min",
                cookTime: "0 min",
                ingredients: ["Tuna", "whole wheat tortilla", "vegetables"],
                instructions: "Mix tuna with diced vegetables and Greek yogurt. Spread on tortilla and wrap tightly.",
                source: "default"
            },
            {
                id: 46,
                name: "Egg White Scramble",
                category: "breakfast",
                calories: 220,
                protein: 22,
                carbs: 12,
                fat: 8,
                servings: "1 serving",
                prepTime: "5 min",
                cookTime: "8 min",
                ingredients: ["Egg whites", "spinach", "mushrooms", "cheese"],
                instructions: "Scramble egg whites in pan. Add spinach and mushrooms. Top with cheese when eggs are almost set.",
                source: "default"
            },
            {
                id: 47,
                name: "Beef & Veggie Skewers",
                category: "dinner",
                calories: 365,
                protein: 30,
                carbs: 15,
                fat: 20,
                servings: "3 servings",
                prepTime: "20 min",
                cookTime: "15 min",
                ingredients: ["Lean beef", "bell peppers", "onions", "zucchini"],
                instructions: "Cut beef and vegetables into chunks. Thread onto skewers. Grill for 15 minutes, turning occasionally.",
                source: "default"
            }
        ];

        let customRecipes = [];
        let filteredRecipes = [];
        let showAllRecipes = false;
        const RECIPES_INITIAL_DISPLAY = 4;

        function initializeRecipeDatabase() {
            loadCustomRecipes();
            displayRecipes();
        }

        function toggleAddRecipeForm() {
            const form = document.getElementById('addRecipeForm');
            const button = document.getElementById('addRecipeToggle');
            
            if (form.classList.contains('hidden')) {
                form.classList.remove('hidden');
                button.innerHTML = '<i class="fas fa-times mr-1"></i>Cancel';
                button.classList.remove('bg-green-500', 'hover:bg-green-600');
                button.classList.add('bg-gray-500', 'hover:bg-gray-600');
            } else {
                form.classList.add('hidden');
                button.innerHTML = '<i class="fas fa-plus mr-1"></i>Add Recipe';
                button.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                button.classList.add('bg-green-500', 'hover:bg-green-600');
                clearRecipeForm();
            }
        }

        function clearRecipeForm() {
            document.getElementById('newRecipeName').value = '';
            document.getElementById('newRecipeCategory').value = 'breakfast';
            document.getElementById('newRecipeCalories').value = '';
            document.getElementById('newRecipeProtein').value = '';
            document.getElementById('newRecipeCarbs').value = '';
            document.getElementById('newRecipeFat').value = '';
            document.getElementById('newRecipeServings').value = '';
            document.getElementById('newRecipeIngredients').value = '';
            document.getElementById('newRecipeInstructions').value = '';
        }

        function saveCustomRecipe() {
            const name = document.getElementById('newRecipeName').value.trim();
            const category = document.getElementById('newRecipeCategory').value;
            const calories = parseFloat(document.getElementById('newRecipeCalories').value) || 0;
            const protein = parseFloat(document.getElementById('newRecipeProtein').value) || 0;
            const carbs = parseFloat(document.getElementById('newRecipeCarbs').value) || 0;
            const fat = parseFloat(document.getElementById('newRecipeFat').value) || 0;
            const servings = parseInt(document.getElementById('newRecipeServings').value) || 1;
            const ingredients = document.getElementById('newRecipeIngredients').value.trim().split('\n').filter(i => i.trim());
            const instructions = document.getElementById('newRecipeInstructions').value.trim();

            if (!name || !instructions) {
                showNotification('Missing Information', 'Please fill in at least the recipe name and instructions', 'warning');
                return;
            }

            const newRecipe = {
                id: Date.now(),
                name: name,
                category: category,
                calories: calories,
                protein: protein,
                carbs: carbs,
                fat: fat,
                servings: servings || 1,
                ingredients: ingredients,
                instructions: instructions,
                source: 'custom'
            };

            // Save to database first
            saveCustomRecipeToDB(newRecipe).then(() => {
                console.log('Recipe saved to permanent storage');
            }).catch(error => {
                console.error('Error saving recipe to database:', error);
            });

            customRecipes.push(newRecipe);
            saveCustomRecipes(); // Fallback localStorage save
            displayRecipes();
            toggleAddRecipeForm();
            showNotification('Recipe Saved', 'Your custom recipe has been successfully saved!', 'success');
        }

        function deleteCustomRecipe(recipeId) {
            const recipe = customRecipes.find(r => r.id === recipeId);
            showConfirmDialog(
                'Delete Recipe',
                `Are you sure you want to delete "${recipe?.name}"? This action cannot be undone.`,
                () => {
                    customRecipes = customRecipes.filter(recipe => recipe.id !== recipeId);
                    saveCustomRecipes();
                    displayRecipes();
                    showNotification('Recipe Deleted', 'Recipe has been successfully removed', 'success');
                }
            );
        }

        function clearCustomRecipes() {
            showConfirmDialog(
                'Clear All Custom Recipes',
                'Are you sure you want to delete all your custom recipes? This action cannot be undone and will permanently remove all recipes you\'ve created.',
                () => {
                    const count = customRecipes.length;
                    customRecipes = [];
                    saveCustomRecipes();
                    displayRecipes();
                    showNotification('Custom Recipes Cleared', `${count} custom recipes have been permanently removed`, 'success');
                }
            );
        }

        function filterRecipes() {
            const searchTerm = document.getElementById('recipeSearch').value.toLowerCase();
            const categoryFilter = document.getElementById('recipeFilter').value;
            const calorieRange = document.getElementById('caloryRange').value;

            const allRecipes = [...recipes, ...customRecipes];
            
            filteredRecipes = allRecipes.filter(recipe => {
                // Search filter
                const matchesSearch = recipe.name.toLowerCase().includes(searchTerm) || 
                                    recipe.ingredients.some(ingredient => ingredient.toLowerCase().includes(searchTerm));
                
                // Category filter
                const matchesCategory = !categoryFilter || 
                                      recipe.category === categoryFilter || 
                                      (categoryFilter === 'custom' && recipe.source === 'custom');
                
                // Calorie range filter
                let matchesCalories = true;
                if (calorieRange) {
                    if (calorieRange === '0-300') matchesCalories = recipe.calories <= 300;
                    else if (calorieRange === '300-500') matchesCalories = recipe.calories > 300 && recipe.calories <= 500;
                    else if (calorieRange === '500-700') matchesCalories = recipe.calories > 500 && recipe.calories <= 700;
                    else if (calorieRange === '700+') matchesCalories = recipe.calories > 700;
                }

                return matchesSearch && matchesCategory && matchesCalories;
            });

            // Reset display state when filtering
            showAllRecipes = false;
            displayRecipes();
        }

        function displayRecipes() {
            const container = document.getElementById('recipesContainer');
            const noResults = document.getElementById('noResults');
            const showMoreContainer = document.getElementById('showMoreContainer');
            
            const recipesToShow = filteredRecipes.length > 0 ? filteredRecipes : [...recipes, ...customRecipes];

            if (recipesToShow.length === 0) {
                container.innerHTML = '';
                noResults.classList.remove('hidden');
                showMoreContainer.classList.add('hidden');
                return;
            }

            noResults.classList.add('hidden');
            container.innerHTML = '';

            // Determine how many recipes to display
            const displayCount = showAllRecipes ? recipesToShow.length : Math.min(RECIPES_INITIAL_DISPLAY, recipesToShow.length);
            const recipesToDisplay = recipesToShow.slice(0, displayCount);

            recipesToDisplay.forEach(recipe => {
                const recipeCard = document.createElement('div');
                recipeCard.className = 'bg-white border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow';
                
                const isCustom = recipe.source === 'custom';
                const categoryColor = {
                    breakfast: 'bg-orange-100 text-orange-800',
                    lunch: 'bg-green-100 text-green-800',
                    dinner: 'bg-purple-100 text-purple-800',
                    snack: 'bg-blue-100 text-blue-800'
                };

                recipeCard.innerHTML = `
                    <div class="flex justify-between items-start mb-3">
                        <h3 class="text-lg font-bold text-gray-800">${recipe.name}</h3>
                        <div class="flex items-center gap-2">
                            <span class="px-2 py-1 rounded-full text-xs font-medium ${categoryColor[recipe.category]}">${recipe.category}</span>
                            ${isCustom ? '<span class="px-2 py-1 rounded-full text-xs font-medium bg-pink-100 text-pink-800">Custom</span>' : ''}
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-4 gap-2 mb-3 text-center">
                        <div>
                            <div class="text-lg font-bold text-blue-600">${recipe.calories}</div>
                            <div class="text-xs text-gray-600">Calories</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-red-500">${recipe.protein}g</div>
                            <div class="text-xs text-gray-600">Protein</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-green-500">${recipe.carbs}g</div>
                            <div class="text-xs text-gray-600">Carbs</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-yellow-500">${recipe.fat}g</div>
                            <div class="text-xs text-gray-600">Fat</div>
                        </div>
                    </div>

                    <div class="text-sm text-gray-600 mb-3">
                        <strong>Serving:</strong> ${recipe.servings}
                    </div>

                    <div class="text-sm text-gray-700 mb-3">
                        <strong>Ingredients:</strong> ${recipe.ingredients.slice(0, 3).join(', ')}${recipe.ingredients.length > 3 ? '...' : ''}
                    </div>

                    <div class="flex flex-wrap gap-1 mb-3">
                        <button onclick="addRecipeToTracker(${recipe.id}, '${recipe.source}')" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-xs font-medium">
                            <i class="fas fa-plus mr-1"></i>Add to Tracker
                        </button>
                        <button onclick="showMealPlannerSelection(${recipe.id}, '${recipe.source}')" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-xs font-medium">
                            <i class="fas fa-calendar-plus mr-1"></i>Add to Planner
                        </button>
                        <button onclick="showRecipeDetails(${recipe.id}, '${recipe.source}')" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded text-xs font-medium">
                            <i class="fas fa-eye mr-1"></i>Details
                        </button>
                        ${isCustom ? `<button onclick="deleteCustomRecipe(${recipe.id})" class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded text-xs font-medium"><i class="fas fa-trash mr-1"></i>Delete</button>` : ''}
                    </div>
                `;
                
                container.appendChild(recipeCard);
            });

            // Update show more/less button
            updateShowMoreButton(recipesToShow.length);
        }

        function updateShowMoreButton(totalRecipes) {
            const showMoreContainer = document.getElementById('showMoreContainer');
            const showMoreBtn = document.getElementById('showMoreBtn');
            const hiddenCount = document.getElementById('hiddenCount');

            if (totalRecipes <= RECIPES_INITIAL_DISPLAY) {
                // Hide button if there are 4 or fewer recipes
                showMoreContainer.classList.add('hidden');
            } else {
                // Show button if there are more than 4 recipes
                showMoreContainer.classList.remove('hidden');
                
                if (showAllRecipes) {
                    showMoreBtn.innerHTML = '<i class="fas fa-chevron-up mr-2"></i>Show Less Recipes';
                } else {
                    const hiddenRecipes = totalRecipes - RECIPES_INITIAL_DISPLAY;
                    hiddenCount.textContent = hiddenRecipes;
                    showMoreBtn.innerHTML = `<i class="fas fa-chevron-down mr-2"></i>Show More Recipes (<span id="hiddenCount">${hiddenRecipes}</span> hidden)`;
                }
            }
        }

        function toggleRecipeDisplay() {
            showAllRecipes = !showAllRecipes;
            displayRecipes();
            
            // Scroll to recipes container when showing more
            if (showAllRecipes) {
                document.getElementById('recipesContainer').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }
        }

        function addRecipeToTracker(recipeId, source) {
            let recipe;
            if (source === 'custom') {
                recipe = customRecipes.find(r => r.id === recipeId);
            } else {
                recipe = recipes.find(r => r.id === recipeId);
            }

            if (!recipe) return;

            // Add to current day's tracking
            const trackingMeal = {
                id: Date.now() + Math.random(),
                name: recipe.name,
                protein: recipe.protein,
                carbs: recipe.carbs,
                fat: recipe.fat,
                calories: recipe.calories
            };

            meals.push(trackingMeal);
            currentIntake.protein += recipe.protein;
            currentIntake.carbs += recipe.carbs;
            currentIntake.fat += recipe.fat;

            updateMealsList();
            updateProgress();
            saveData();
            saveDailyMacros().catch(error => console.error('Error saving daily macros:', error)); // Save daily macro progress
            
            showNotification('Recipe Added', `${recipe.name} has been added to today's tracker!`, 'success');
        }

        function addRecipeToMealPlan(recipeId, source, mealType) {
            let recipe;
            if (source === 'custom') {
                recipe = customRecipes.find(r => r.id === recipeId);
            } else {
                recipe = recipes.find(r => r.id === recipeId);
            }

            if (!recipe) return;

            const plannedMeal = {
                id: Date.now() + Math.random(),
                name: recipe.name,
                calories: recipe.calories,
                protein: recipe.protein,
                carbs: recipe.carbs || 0,
                fat: recipe.fat || 0
            };

            mealPlan[currentSelectedDay][mealType].push(plannedMeal);
            updateMealPlanDisplay();
            saveMealPlan().catch(error => console.warn('Meal plan save error:', error));
            showNotification('Meal Planned', `${recipe.name} added to ${mealType} for ${currentSelectedDay.charAt(0).toUpperCase() + currentSelectedDay.slice(1)}!`, 'success');
        }

        function showMealPlannerSelection(recipeId, source) {
            let recipe;
            if (source === 'custom') {
                recipe = customRecipes.find(r => r.id === recipeId);
            } else {
                recipe = recipes.find(r => r.id === recipeId);
            }

            if (!recipe) return;

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white rounded-lg max-w-md w-full">
                    <div class="p-6">
                        <div class="flex justify-between items-start mb-4">
                            <h3 class="text-xl font-bold text-gray-800">Add to Meal Planner</h3>
                            <button onclick="this.closest('.fixed').remove()" class="text-gray-400 hover:text-gray-600">
                                <i class="fas fa-times text-xl"></i>
                            </button>
                        </div>
                        
                        <div class="mb-4">
                            <div class="bg-gray-50 p-3 rounded-lg mb-4">
                                <h4 class="font-semibold text-gray-800">${recipe.name}</h4>
                                <div class="text-sm text-gray-600 mt-1">
                                    ${recipe.calories} cal • ${recipe.protein}g protein
                                </div>
                            </div>
                            
                            <p class="text-gray-600 mb-4">Select which meal and day to add this recipe:</p>
                            
                            <!-- Day Selection -->
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Select Day:</label>
                                <select id="plannerDaySelect" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-green-500">
                                    <option value="Sunday">Sunday</option>
                                    <option value="Monday">Monday</option>
                                    <option value="Tuesday">Tuesday</option>
                                    <option value="Wednesday">Wednesday</option>
                                    <option value="Thursday">Thursday</option>
                                    <option value="Friday">Friday</option>
                                    <option value="Saturday">Saturday</option>
                                </select>
                            </div>
                            
                            <!-- Meal Type Selection -->
                            <div class="mb-6">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Select Meal:</label>
                                <div class="grid grid-cols-2 gap-2" id="mealTypeGrid">
                                    <button onclick="addRecipeToMealPlanFromSelection(${recipeId}, '${source}', 'breakfast')" class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-3 rounded-lg font-medium" style="background-color: #f97316 !important; color: white !important;">
                                        <i class="fas fa-sun mr-2"></i>Breakfast
                                    </button>
                                    <button onclick="addRecipeToMealPlanFromSelection(${recipeId}, '${source}', 'lunch')" class="bg-green-500 hover:bg-green-600 text-white px-4 py-3 rounded-lg font-medium">
                                        <i class="fas fa-leaf mr-2"></i>Lunch
                                    </button>
                                    <button onclick="addRecipeToMealPlanFromSelection(${recipeId}, '${source}', 'dinner')" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-3 rounded-lg font-medium">
                                        <i class="fas fa-moon mr-2"></i>Dinner
                                    </button>
                                    <button onclick="addRecipeToMealPlanFromSelection(${recipeId}, '${source}', 'snacks')" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-3 rounded-lg font-medium">
                                        <i class="fas fa-cookie-bite mr-2"></i>Snacks
                                    </button>
                                    ${customSectionEnabled && customSections.length > 0 ? `
                                    <button onclick="addRecipeToMealPlanFromSelection(${recipeId}, '${source}', '${customSections[0].id}')" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-3 rounded-lg font-medium col-span-2">
                                        <i class="fas fa-star mr-2"></i>${customSections[0].name}
                                    </button>` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
            
            // Set current selected day as default
            const daySelect = document.getElementById('plannerDaySelect');
            if (daySelect && currentSelectedDay) {
                daySelect.value = currentSelectedDay.charAt(0).toUpperCase() + currentSelectedDay.slice(1);
            }
        }

        function addRecipeToMealPlanFromSelection(recipeId, source, mealType) {
            const daySelect = document.getElementById('plannerDaySelect');
            const selectedDay = daySelect ? daySelect.value.toLowerCase() : currentSelectedDay;
            
            let recipe;
            if (source === 'custom') {
                recipe = customRecipes.find(r => r.id === recipeId);
            } else {
                recipe = recipes.find(r => r.id === recipeId);
            }

            if (!recipe) return;

            // Initialize meal plan structure if needed
            if (!mealPlan[selectedDay]) {
                mealPlan[selectedDay] = {
                    breakfast: [],
                    lunch: [],
                    dinner: [],
                    snacks: []
                };
                
                // Add custom sections if they exist
                customSections.forEach(section => {
                    mealPlan[selectedDay][section.id] = [];
                });
            }
            
            // Ensure the specific meal type exists (for custom sections)
            if (!mealPlan[selectedDay][mealType]) {
                mealPlan[selectedDay][mealType] = [];
            }

            const plannedMeal = {
                id: Date.now() + Math.random(),
                name: recipe.name,
                calories: recipe.calories,
                protein: recipe.protein,
                carbs: recipe.carbs || 0,
                fat: recipe.fat || 0
            };

            mealPlan[selectedDay][mealType].push(plannedMeal);
            updateMealPlanDisplay();
            saveMealPlan().catch(error => console.warn('Meal plan save error:', error));
            
            // Close modal
            const modal = document.querySelector('.fixed.inset-0');
            if (modal) modal.remove();
            
            // Show success notification
            const dayName = selectedDay.charAt(0).toUpperCase() + selectedDay.slice(1);
            const mealName = mealType.charAt(0).toUpperCase() + mealType.slice(1);
            showNotification('Recipe Added to Planner', `${recipe.name} added to ${mealName} for ${dayName}!`, 'success');
        }

        function showRecipeDetails(recipeId, source) {
            let recipe;
            if (source === 'custom') {
                recipe = customRecipes.find(r => r.id === recipeId);
            } else {
                recipe = recipes.find(r => r.id === recipeId);
            }

            if (!recipe) return;

            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white rounded-lg max-w-2xl w-full max-h-screen overflow-y-auto">
                    <div class="p-6">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-2xl font-bold text-gray-800">${recipe.name}</h2>
                            <button onclick="this.closest('.fixed').remove()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
                        </div>
                        
                        <div class="grid grid-cols-4 gap-4 mb-6 text-center">
                            <div class="bg-blue-50 p-3 rounded">
                                <div class="text-xl font-bold text-blue-600">${recipe.calories}</div>
                                <div class="text-sm text-gray-600">Calories</div>
                            </div>
                            <div class="bg-red-50 p-3 rounded">
                                <div class="text-xl font-bold text-red-500">${recipe.protein}g</div>
                                <div class="text-sm text-gray-600">Protein</div>
                            </div>
                            <div class="bg-green-50 p-3 rounded">
                                <div class="text-xl font-bold text-green-500">${recipe.carbs}g</div>
                                <div class="text-sm text-gray-600">Carbs</div>
                            </div>
                            <div class="bg-yellow-50 p-3 rounded">
                                <div class="text-xl font-bold text-yellow-500">${recipe.fat}g</div>
                                <div class="text-sm text-gray-600">Fat</div>
                            </div>
                        </div>

                        <div class="mb-4">
                            <h3 class="font-bold text-gray-800 mb-2">Serving Size</h3>
                            <p class="text-gray-700">${recipe.servings}</p>
                        </div>

                        <div class="mb-4">
                            <h3 class="font-bold text-gray-800 mb-2">Ingredients</h3>
                            <ul class="list-disc list-inside text-gray-700 space-y-1">
                                ${recipe.ingredients.map(ingredient => `<li>${ingredient}</li>`).join('')}
                            </ul>
                        </div>

                        <div class="mb-6">
                            <h3 class="font-bold text-gray-800 mb-2">Instructions</h3>
                            <p class="text-gray-700 whitespace-pre-line">${recipe.instructions}</p>
                        </div>

                        <div class="flex flex-wrap gap-2">
                            <button onclick="addRecipeToTracker(${recipe.id}, '${recipe.source}'); this.closest('.fixed').remove();" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded font-medium">
                                <i class="fas fa-plus mr-1"></i>Add to Tracker
                            </button>
                            <button onclick="addRecipeToMealPlan(${recipe.id}, '${recipe.source}', 'breakfast'); this.closest('.fixed').remove();" class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded font-medium" style="background-color: #f97316 !important; color: white !important;">
                                <i class="fas fa-sun mr-1"></i>Add to Breakfast
                            </button>
                            <button onclick="addRecipeToMealPlan(${recipe.id}, '${recipe.source}', 'lunch'); this.closest('.fixed').remove();" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded font-medium">
                                <i class="fas fa-sun mr-1"></i>Add to Lunch
                            </button>
                            <button onclick="addRecipeToMealPlan(${recipe.id}, '${recipe.source}', 'dinner'); this.closest('.fixed').remove();" class="bg-purple-500 hover:bg-purple-600 text-white px-4 py-2 rounded font-medium">
                                <i class="fas fa-moon mr-1"></i>Add to Dinner
                            </button>
                            ${customSectionEnabled && customSections.length > 0 ? `
                            <button onclick="addRecipeToMealPlan(${recipe.id}, '${recipe.source}', '${customSections[0].id}'); this.closest('.fixed').remove();" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium">
                                <i class="fas fa-star mr-1"></i>Add to ${customSections[0].name}
                            </button>` : ''}
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        function saveCustomRecipes() {
            localStorage.setItem('customRecipes', JSON.stringify(customRecipes));
        }

        function loadCustomRecipes() {
            const saved = localStorage.getItem('customRecipes');
            if (saved) {
                customRecipes = JSON.parse(saved);
            }
        }

        // Progress Tracker Functions
        let progressEntries = [];
        
        // Ensure progressEntries is always an array
        function ensureProgressEntriesInitialized() {
            if (!progressEntries || !Array.isArray(progressEntries)) {
                console.warn('Progress entries not properly initialized, creating empty array');
                progressEntries = [];
            }
            return progressEntries;
        }
        let progressGoal = null;
        let progressChart = null;

        function initializeProgressTracker() {
            console.log('Initializing progress tracker...');
            loadProgressData();
            
            // Use setTimeout to ensure DOM is fully ready
            setTimeout(() => {
                updateProgressDisplay();
                initializeProgressChart();
                
                // Set today's date as default
                const today = new Date().toISOString().split('T')[0];
                const dateField = document.getElementById('progressEntryDate');
                if (dateField) {
                    dateField.value = today;
                }
                
                console.log('Progress tracker initialized with', progressEntries.length, 'entries');
            }, 100);
        }

        function clearProgressForm() {
            const fields = ['progressEntryWeight', 'progressEntryWaist', 'progressEntryChest', 'progressEntryHips', 'progressEntryArms', 'progressEntryNotes'];
            fields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field) field.value = '';
            });
        }

        async function saveProgressEntry() {
            const date = document.getElementById('progressEntryDate')?.value;
            const weight = parseFloat(document.getElementById('progressEntryWeight')?.value);
            const waist = parseFloat(document.getElementById('progressEntryWaist')?.value) || null;
            const chest = parseFloat(document.getElementById('progressEntryChest')?.value) || null;
            const hips = parseFloat(document.getElementById('progressEntryHips')?.value) || null;
            const arms = parseFloat(document.getElementById('progressEntryArms')?.value) || null;
            const notes = document.getElementById('progressEntryNotes')?.value?.trim() || '';

            if (!date) {
                showNotification('Missing Information', 'Please select a date', 'warning');
                return;
            }

            if (!weight || weight <= 0) {
                showNotification('Missing Information', 'Please enter a valid weight', 'warning');
                return;
            }

            // Check if entry for this date already exists
            const existingIndex = progressEntries.findIndex(entry => entry.date === date);
            
            const progressEntry = {
                id: existingIndex >= 0 ? progressEntries[existingIndex].id : Date.now(),
                date: date,
                weight: weight,
                measurements: {
                    waist: waist,
                    chest: chest,
                    hips: hips,
                    arms: arms
                },
                notes: notes,
                timestamp: Date.now()
            };

            // Save to database first
            try {
                await saveProgressEntryToDB(progressEntry);
                console.log('Progress entry saved to permanent storage');
            } catch (error) {
                console.error('Error saving progress entry to database:', error);
            }

            if (existingIndex >= 0) {
                progressEntries[existingIndex] = progressEntry;
                showNotification('Entry Updated', 'Progress entry has been updated successfully', 'success');
            } else {
                progressEntries.push(progressEntry);
                showNotification('Entry Saved', 'Progress entry has been saved successfully', 'success');
            }

            // Sort by date (newest first)
            progressEntries.sort((a, b) => new Date(b.date) - new Date(a.date));

            // Fallback save to localStorage
            saveProgressData();
            
            updateProgressDisplay();
            updateProgressChart();
            clearProgressForm();
            
            console.log('Progress entry saved and displays updated');
        }

        async function setProgressGoal() {
            const targetWeight = parseFloat(document.getElementById('targetWeight')?.value);
            const targetDate = document.getElementById('targetDate')?.value;

            if (!targetWeight || targetWeight <= 0) {
                showNotification('Missing Information', 'Please enter a valid target weight', 'warning');
                return;
            }

            if (!targetDate) {
                showNotification('Missing Information', 'Please select a target date', 'warning');
                return;
            }

            const today = new Date();
            const target = new Date(targetDate);
            
            if (target <= today) {
                showNotification('Invalid Date', 'Target date must be in the future', 'warning');
                return;
            }

            progressGoal = {
                targetWeight: targetWeight,
                targetDate: targetDate,
                setDate: today.toISOString().split('T')[0]
            };

            try {
                // Save to database first
                const dbResult = await saveProgressGoalToDB(progressGoal);
                
                if (dbResult && !dbResult.fallback) {
                    console.log('✅ Progress goal saved to database:', dbResult);
                } else {
                    console.log('📱 Progress goal saved to localStorage fallback');
                }
                
                // Also save to localStorage for backwards compatibility and offline access
                saveProgressData();
                
                // Double-save for critical data
                setTimeout(() => {
                    saveProgressData();
                }, 100);
                
                updateProgressDisplay();
                showNotification('Goal Set', `Target: ${targetWeight} ${getWeightUnit()} by ${target.toLocaleDateString()}`, 'success');
                
                console.log('Progress goal saved:', progressGoal);
            } catch (error) {
                console.error('❌ Error saving progress goal:', error);
                
                // Fallback to localStorage only
                saveProgressData();
                setTimeout(() => {
                    saveProgressData();
                }, 100);
                
                updateProgressDisplay();
                showNotification('Goal Set', `Target: ${targetWeight} ${getWeightUnit()} by ${target.toLocaleDateString()}`, 'success');
                console.log('Progress goal saved to localStorage fallback:', progressGoal);
            }
        }

        function updateProgressDisplay() {
            // Update quick stats
            if (progressEntries.length > 0) {
                const latest = progressEntries[0];
                const oldest = progressEntries[progressEntries.length - 1];
                
                // Current weight with proper unit
                const currentWeightEl = document.getElementById('currentWeight');
                if (currentWeightEl) {
                    const weightUnit = getWeightUnit();
                    let displayWeight = latest.weight;
                    // Convert weight if needed for display
                    if (currentUnitSystem === 'metric' && latest.weight > 50) {
                        // Assume stored weight is in lbs, convert to kg for display
                        displayWeight = lbsToKg(latest.weight);
                    }
                    currentWeightEl.textContent = displayWeight.toFixed(1) + ' ' + weightUnit;
                }
                
                // Weight change
                const weightChangeEl = document.getElementById('weightChange');
                if (weightChangeEl && progressEntries.length > 1) {
                    let change = latest.weight - oldest.weight;
                    const weightUnit = getWeightUnit();
                    // Convert change if needed for display
                    if (currentUnitSystem === 'metric' && Math.abs(change) > 1) {
                        change = lbsToKg(latest.weight) - lbsToKg(oldest.weight);
                    }
                    const changeText = change >= 0 ? `+${change.toFixed(1)} ${weightUnit}` : `${change.toFixed(1)} ${weightUnit}`;
                    weightChangeEl.textContent = changeText;
                    weightChangeEl.className = `text-xs mt-1 ${change >= 0 ? 'text-red-600' : 'text-green-600'}`;
                } else if (weightChangeEl) {
                    weightChangeEl.textContent = 'First entry';
                    weightChangeEl.className = 'text-xs mt-1 text-blue-600';
                }
                
                // Days tracked
                const daysSinceEl = document.getElementById('daysSinceStart');
                if (daysSinceEl) {
                    const daysDiff = Math.max(0, Math.ceil((new Date(latest.date) - new Date(oldest.date)) / (1000 * 60 * 60 * 24)));
                    daysSinceEl.textContent = `${daysDiff} days`;
                }
                
                // Latest measurements with proper units
                const measurements = latest.measurements || {};
                const waistEl = document.getElementById('latestWaist');
                const chestEl = document.getElementById('latestChest');
                const hipsEl = document.getElementById('latestHips');
                const armsEl = document.getElementById('latestArms');
                
                const heightUnit = getHeightUnit();
                
                if (waistEl) {
                    if (measurements.waist) {
                        let displayWaist = measurements.waist;
                        if (currentUnitSystem === 'metric' && measurements.waist < 50) {
                            displayWaist = inToCm(measurements.waist);
                        }
                        waistEl.textContent = displayWaist.toFixed(1);
                    } else {
                        waistEl.textContent = '--';
                    }
                }
                
                if (chestEl) {
                    if (measurements.chest) {
                        let displayChest = measurements.chest;
                        if (currentUnitSystem === 'metric' && measurements.chest < 50) {
                            displayChest = inToCm(measurements.chest);
                        }
                        chestEl.textContent = displayChest.toFixed(1);
                    } else {
                        chestEl.textContent = '--';
                    }
                }
                
                if (hipsEl) {
                    if (measurements.hips) {
                        let displayHips = measurements.hips;
                        if (currentUnitSystem === 'metric' && measurements.hips < 50) {
                            displayHips = inToCm(measurements.hips);
                        }
                        hipsEl.textContent = displayHips.toFixed(1);
                    } else {
                        hipsEl.textContent = '--';
                    }
                }
                
                if (armsEl) {
                    if (measurements.arms) {
                        let displayArms = measurements.arms;
                        if (currentUnitSystem === 'metric' && measurements.arms < 50) {
                            displayArms = inToCm(measurements.arms);
                        }
                        armsEl.textContent = displayArms.toFixed(1);
                    } else {
                        armsEl.textContent = '--';
                    }
                }
                
                // Weekly average
                const weeklyAvgEl = document.getElementById('weeklyAverage');
                if (weeklyAvgEl && progressEntries.length >= 2) {
                    const recentEntries = progressEntries.slice(0, Math.min(7, progressEntries.length));
                    if (recentEntries.length >= 2) {
                        const weekChange = recentEntries[0].weight - recentEntries[recentEntries.length - 1].weight;
                        const days = Math.max(1, (new Date(recentEntries[0].date) - new Date(recentEntries[recentEntries.length - 1].date)) / (1000 * 60 * 60 * 24));
                        let weekAvg = weekChange / (days / 7);
                        
                        // Convert for display if needed
                        if (currentUnitSystem === 'metric' && Math.abs(weekAvg) > 1) {
                            weekAvg = weekAvg * 0.453592; // Convert lbs to kg
                        }
                        
                        weeklyAvgEl.textContent = (weekAvg >= 0 ? '+' : '') + weekAvg.toFixed(1);
                    } else {
                        weeklyAvgEl.textContent = '--';
                    }
                } else if (weeklyAvgEl) {
                    weeklyAvgEl.textContent = '--';
                }
            } else {
                // No data available - reset all displays
                const currentWeightEl = document.getElementById('currentWeight');
                const weightChangeEl = document.getElementById('weightChange');
                const daysSinceEl = document.getElementById('daysSinceStart');
                const weeklyAvgEl = document.getElementById('weeklyAverage');
                const waistEl = document.getElementById('latestWaist');
                const chestEl = document.getElementById('latestChest');
                const hipsEl = document.getElementById('latestHips');
                const armsEl = document.getElementById('latestArms');
                
                if (currentWeightEl) currentWeightEl.textContent = '--';
                if (weightChangeEl) {
                    weightChangeEl.textContent = 'No data';
                    weightChangeEl.className = 'text-xs mt-1 text-gray-600';
                }
                if (daysSinceEl) daysSinceEl.textContent = '0 days';
                if (weeklyAvgEl) weeklyAvgEl.textContent = '--';
                if (waistEl) waistEl.textContent = '--';
                if (chestEl) chestEl.textContent = '--';
                if (hipsEl) hipsEl.textContent = '--';
                if (armsEl) armsEl.textContent = '--';
            }

            // Total entries
            const totalEntriesEl = document.getElementById('totalProgressEntries');
            if (totalEntriesEl) totalEntriesEl.textContent = progressEntries.length;

            // Goal progress
            const goalProgressEl = document.getElementById('goalProgressPercent');
            const goalStatusEl = document.getElementById('goalStatusText');
            
            if (progressGoal && progressEntries.length > 0) {
                const currentWeight = progressEntries[0].weight;
                const startWeight = progressEntries[progressEntries.length - 1].weight;
                const targetWeight = progressGoal.targetWeight;
                
                const totalChange = Math.abs(targetWeight - startWeight);
                const currentChange = Math.abs(currentWeight - startWeight);
                const progress = totalChange > 0 ? Math.min(100, (currentChange / totalChange) * 100) : 0;
                
                if (goalProgressEl) goalProgressEl.textContent = Math.round(progress) + '%';
                if (goalStatusEl) goalStatusEl.textContent = `${Math.abs(targetWeight - currentWeight).toFixed(1)} ${getWeightUnit()} to go`;
            } else {
                if (goalProgressEl) goalProgressEl.textContent = '0%';
                if (goalStatusEl) goalStatusEl.textContent = 'Set goal';
            }

            updateProgressTimeline();
        }

        function updateProgressTimeline() {
            const timeline = document.getElementById('progressTimeline');
            if (!timeline) return;
            
            if (progressEntries.length === 0) {
                timeline.innerHTML = `
                    <div class="text-center text-gray-500 py-8">
                        <i class="fas fa-chart-line text-4xl mb-4"></i>
                        <p>No progress entries yet. Add your first entry to start tracking!</p>
                    </div>
                `;
                return;
            }

            timeline.innerHTML = '';
            
            // Show last 5 entries
            const recentEntries = progressEntries.slice(0, 5);
            const weightUnit = getWeightUnit();
            
            recentEntries.forEach((entry, index) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'flex items-start space-x-3 pb-3 mb-3 border-b border-gray-200 last:border-b-0';
                
                const weightChange = index < progressEntries.length - 1 ? 
                    entry.weight - progressEntries[index + 1].weight : 0;
                
                const changeColor = weightChange > 0 ? 'text-red-500' : weightChange < 0 ? 'text-green-500' : 'text-gray-500';
                const changeIcon = weightChange > 0 ? 'fa-arrow-up' : weightChange < 0 ? 'fa-arrow-down' : 'fa-minus';
                
                // Handle weight display with proper units
                let displayWeight = entry.weight;
                if (currentUnitSystem === 'metric' && entry.weight > 50) {
                    displayWeight = lbsToKg(entry.weight);
                }
                
                // Handle change display with proper units
                let displayChange = weightChange;
                if (currentUnitSystem === 'metric' && Math.abs(weightChange) > 1) {
                    displayChange = displayChange * 0.453592;
                }
                
                entryDiv.innerHTML = `
                    <div class="flex-shrink-0 w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
                        <i class="fas fa-weight text-blue-600 text-xs"></i>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="flex items-center justify-between">
                            <div class="text-sm font-medium text-gray-900">
                                ${new Date(entry.date).toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric',
                                    year: 'numeric'
                                })}
                            </div>
                            <div class="text-sm font-bold text-gray-900">
                                ${displayWeight.toFixed(1)} ${weightUnit}
                                ${Math.abs(displayChange) > 0.1 ? `<span class="${changeColor}"><i class="fas ${changeIcon} ml-1"></i></span>` : ''}
                            </div>
                        </div>
                        ${entry.notes ? `<div class="text-xs text-gray-600 mt-1">"${entry.notes}"</div>` : ''}
                        ${entry.measurements && (entry.measurements.waist || entry.measurements.chest || entry.measurements.hips || entry.measurements.arms) ? 
                            `<div class="text-xs text-gray-500 mt-1">
                                ${entry.measurements.waist ? `W: ${entry.measurements.waist}" ` : ''}
                                ${entry.measurements.chest ? `C: ${entry.measurements.chest}" ` : ''}
                                ${entry.measurements.hips ? `H: ${entry.measurements.hips}" ` : ''}
                                ${entry.measurements.arms ? `A: ${entry.measurements.arms}"` : ''}
                            </div>` : ''}
                    </div>
                `;
                
                timeline.appendChild(entryDiv);
            });
        }

        function initializeProgressChart() {
            const ctx = document.getElementById('progressWeightChart');
            if (!ctx) {
                console.error('Progress chart canvas not found');
                return;
            }

            // Destroy existing chart first to prevent canvas reuse errors
            if (progressChart) {
                progressChart.destroy();
                progressChart = null;
                console.log('🗑️ Destroyed existing progress chart before reinitializing');
            }

            try {
                progressChart = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Weight (' + getWeightUnit() + ')',
                            data: [],
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#3b82f6',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 6
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false
                            }
                        },
                        interaction: {
                            mode: 'nearest',
                            axis: 'x',
                            intersect: false
                        },
                        scales: {
                            y: {
                                beginAtZero: false,
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                },
                                ticks: {
                                    callback: function(value) {
                                        return value.toFixed(1) + ' ' + getWeightUnit();
                                    }
                                }
                            },
                            x: {
                                grid: {
                                    color: 'rgba(0,0,0,0.1)'
                                }
                            }
                        }
                    }
                });
                
                console.log('Progress chart initialized successfully');
                updateProgressChart();
            } catch (error) {
                console.error('Error initializing progress chart:', error);
            }
        }

        function updateProgressChart() {
            if (!progressChart) {
                console.warn('Progress chart not initialized');
                return;
            }
            
            if (progressEntries.length === 0) {
                // Show empty chart with message
                progressChart.data.labels = ['No Data'];
                progressChart.data.datasets[0].data = [];
                progressChart.update();
                return;
            }

            try {
                // Reverse data for chronological order in chart
                const chronologicalData = [...progressEntries].reverse();
                
                const labels = chronologicalData.map(entry => 
                    new Date(entry.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
                );
                
                // Convert weights for display if needed
                const data = chronologicalData.map(entry => {
                    let displayWeight = entry.weight;
                    if (currentUnitSystem === 'metric' && entry.weight > 50) {
                        displayWeight = lbsToKg(entry.weight);
                    }
                    return parseFloat(displayWeight.toFixed(1));
                });
                
                progressChart.data.labels = labels;
                progressChart.data.datasets[0].data = data;
                progressChart.data.datasets[0].label = 'Weight (' + getWeightUnit() + ')';
                progressChart.update('none'); // Use 'none' for immediate update
                
                console.log('Progress chart updated with', data.length, 'data points');
            } catch (error) {
                console.error('Error updating progress chart:', error);
            }
        }

        // Toggle progress export dropdown
        // Simple PDF Export Function
        function exportProgressPDF() {
            try {
                console.log('🔄 Starting PDF export...');
                
                // Get progress entries safely
                const entries = getProgressEntries();
                if (!entries || entries.length === 0) {
                    showNotification('No Data', 'No progress data to export. Please add some progress entries first.', 'info');
                    return;
                }
                
                // Generate PDF
                generateSimplePDF(entries);
                showNotification('Success', 'PDF report exported successfully!', 'success');
                
            } catch (error) {
                console.error('❌ PDF export failed:', error);
                showNotification('Export Failed', 'Unable to export PDF: ' + error.message, 'error');
            }
        }

        // Simple CSV Export Function  
        function exportProgressCSV() {
            try {
                console.log('🔄 Starting CSV export...');
                
                // Get progress entries safely
                const entries = getProgressEntries();
                if (!entries || entries.length === 0) {
                    showNotification('No Data', 'No progress data to export. Please add some progress entries first.', 'info');
                    return;
                }
                
                // Generate CSV
                const csvContent = generateSimpleCSV(entries);
                const dateStr = new Date().toISOString().split('T')[0];
                downloadFile(csvContent, `Progress-Data-${dateStr}.csv`, 'text/csv;charset=utf-8;');
                showNotification('Success', 'CSV data exported successfully!', 'success');
                
            } catch (error) {
                console.error('❌ CSV export failed:', error);
                showNotification('Export Failed', 'Unable to export CSV: ' + error.message, 'error');
            }
        }

        // Safe function to get progress entries
        function getProgressEntries() {
            try {
                // Ensure progressEntries exists and is an array
                if (typeof progressEntries === 'undefined' || !progressEntries) {
                    console.log('⚠️ progressEntries not found, trying to load from localStorage');
                    const stored = localStorage.getItem('progressEntries');
                    if (stored) {
                        return JSON.parse(stored);
                    }
                    return [];
                }
                
                if (!Array.isArray(progressEntries)) {
                    console.warn('⚠️ progressEntries is not an array, converting');
                    return [];
                }
                
                // Filter for valid entries only
                return progressEntries.filter(entry => entry && typeof entry === 'object' && entry.date);
                
            } catch (error) {
                console.error('❌ Error getting progress entries:', error);
                return [];
            }
        }

        function exportProgressData(format = 'pdf') {
            try {
                // Ensure progressEntries is properly initialized
                ensureProgressEntriesInitialized();
                
                // Debug log to check progressEntries state
                console.log('Export called - progressEntries:', progressEntries);
                
                // Check if progressEntries exists and has data
                if (!progressEntries || !Array.isArray(progressEntries) || progressEntries.length === 0) {
                    console.warn('No progress entries available for export');
                    showNotification('No Data', 'No progress data to export. Please add some progress entries first.', 'info');
                    return;
                }
                
                console.log(`Exporting ${progressEntries.length} progress entries in ${format} format`);

            // Close dropdown
            document.getElementById('progressExportDropdown').classList.add('hidden');
            
            const dateStr = new Date().toISOString().split('T')[0];
            const totalEntries = progressEntries.length;
            
            // Calculate progress statistics
            console.log('🔍 About to calculate progress statistics...');
            const stats = calculateProgressStatistics();
            console.log('🔍 Calculated stats result:', stats);
            
            switch (format.toLowerCase()) {
                case 'pdf':
                    generateProgressReportPDF(stats, dateStr);
                    showNotification('Success', `Professional progress report (PDF) exported! ${totalEntries} entries with charts included.`, 'success');
                    break;
                    
                case 'csv':
                    const csvContent = generateProgressCSV(stats);
                    if (csvContent) {
                        downloadFile(csvContent, `NutriTracker-ProgressData-${dateStr}.csv`, 'text/csv;charset=utf-8;');
                        const entriesText = totalEntries > 0 ? `${totalEntries} entries` : 'empty template';
                        showNotification('Success', `Progress data exported to CSV! ${entriesText} ready for spreadsheet analysis.`, 'success');
                    } else {
                        showNotification('Export Failed', 'Unable to generate CSV file. Please try again.', 'error');
                    }
                    break;
                    
                case 'xlsx':
                    generateProgressExcel(stats, dateStr);
                    const excelEntriesText = totalEntries > 0 ? `${totalEntries} entries with multiple sheets and charts` : 'empty template with instructions';
                    showNotification('Success', `Excel workbook exported! ${excelEntriesText}.`, 'success');
                    break;
                    
                default:
                    showNotification('Error', 'Invalid export format selected.', 'error');
            }
            } catch (error) {
                console.error('Error in exportProgressData:', error);
                showNotification('Export Failed', 'An error occurred while exporting progress data: ' + error.message, 'error');
            }
        }

        // Calculate comprehensive progress statistics
        function calculateProgressStatistics() {
            console.log('Calculating progress statistics - progressEntries:', progressEntries);
            console.log('🔍 progressEntries type:', typeof progressEntries, 'isArray:', Array.isArray(progressEntries));
            
            // Ensure progressEntries is initialized
            if (!progressEntries || !Array.isArray(progressEntries)) {
                console.warn('progressEntries not properly initialized, creating empty array');
                progressEntries = [];
            }
            
            if (progressEntries.length === 0) {
                console.warn('No progress entries available for statistics');
                return {
                    entries: [],
                    goal: progressGoal,
                    totalEntries: 0,
                    dateRange: null,
                    weight: null,
                    bodyFat: null,
                    muscleMass: null,
                    measurements: null
                };
            }
            
            // Filter out invalid entries and sort by date
            const validEntries = progressEntries.filter(entry => entry && entry.date);
            
            if (validEntries.length === 0) {
                console.warn('No valid progress entries found for statistics');
                return {
                    entries: [],
                    goal: progressGoal,
                    totalEntries: 0,
                    dateRange: null,
                    weight: null,
                    bodyFat: null,
                    muscleMass: null,
                    measurements: null
                };
            }
            
            const sortedEntries = [...validEntries].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            const stats = {
                entries: sortedEntries,
                goal: progressGoal,
                totalEntries: sortedEntries.length,
                dateRange: {
                    start: sortedEntries[0].date,
                    end: sortedEntries[sortedEntries.length - 1].date
                }
            };
            
            // Calculate weight statistics
            const weightEntries = sortedEntries.filter(entry => entry && entry.weight && !isNaN(parseFloat(entry.weight)));
            if (weightEntries.length > 0) {
                const weights = weightEntries.map(entry => parseFloat(entry.weight));
                const weightTrendData = weightEntries.map(entry => ({ 
                    date: entry.date, 
                    value: parseFloat(entry.weight) 
                })).filter(item => item.date && !isNaN(item.value));
                
                stats.weight = {
                    current: weights[weights.length - 1],
                    initial: weights[0],
                    min: Math.min(...weights),
                    max: Math.max(...weights),
                    average: weights.reduce((a, b) => a + b, 0) / weights.length,
                    change: weights[weights.length - 1] - weights[0],
                    trend: calculateTrend(weightTrendData)
                };
            }
            
            // Calculate body fat statistics  
            const bodyFatEntries = sortedEntries.filter(entry => entry && entry.bodyFat && !isNaN(parseFloat(entry.bodyFat)));
            if (bodyFatEntries.length > 0) {
                const bodyFats = bodyFatEntries.map(entry => parseFloat(entry.bodyFat));
                const bodyFatTrendData = bodyFatEntries.map(entry => ({ 
                    date: entry.date, 
                    value: parseFloat(entry.bodyFat) 
                })).filter(item => item.date && !isNaN(item.value));
                
                stats.bodyFat = {
                    current: bodyFats[bodyFats.length - 1],
                    initial: bodyFats[0],
                    min: Math.min(...bodyFats),
                    max: Math.max(...bodyFats),
                    average: bodyFats.reduce((a, b) => a + b, 0) / bodyFats.length,
                    change: bodyFats[bodyFats.length - 1] - bodyFats[0],
                    trend: calculateTrend(bodyFatTrendData)
                };
            }
            
            // Calculate muscle mass statistics
            // Calculate muscle mass statistics
            const muscleMassEntries = sortedEntries.filter(entry => entry && entry.muscleMass && !isNaN(parseFloat(entry.muscleMass)));
            if (muscleMassEntries.length > 0) {
                const muscleMasses = muscleMassEntries.map(entry => parseFloat(entry.muscleMass));
                const muscleMassTrendData = muscleMassEntries.map(entry => ({ 
                    date: entry.date, 
                    value: parseFloat(entry.muscleMass) 
                })).filter(item => item.date && !isNaN(item.value));
                
                stats.muscleMass = {
                    current: muscleMasses[muscleMasses.length - 1],
                    initial: muscleMasses[0],
                    min: Math.min(...muscleMasses),
                    max: Math.max(...muscleMasses),
                    average: muscleMasses.reduce((a, b) => a + b, 0) / muscleMasses.length,
                    change: muscleMasses[muscleMasses.length - 1] - muscleMasses[0],
                    trend: calculateTrend(muscleMassTrendData)
                };
            }
            
            return stats;
        }

        // Calculate trend (positive = increasing, negative = decreasing)
        function calculateTrend(dataPoints) {
            if (!dataPoints || !Array.isArray(dataPoints) || dataPoints.length < 2) {
                console.warn('Invalid dataPoints for trend calculation:', dataPoints);
                return 0;
            }
            
            const n = dataPoints.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            
            dataPoints.forEach((point, index) => {
                sumX += index;
                sumY += point.value;
                sumXY += index * point.value;
                sumX2 += index * index;
            });
            
            // Calculate slope (trend)
            return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        }

        // Generate professional PDF report with charts
        // Simple, reliable PDF generation
        function generateSimplePDF(entries) {
            console.log('📄 Generating PDF with', entries.length, 'entries');
            
            // Check if jsPDF is available - look for it in different locations
            let jsPDF;
            if (window.jspdf && window.jspdf.jsPDF) {
                jsPDF = window.jspdf.jsPDF;
            } else if (window.jsPDF) {
                jsPDF = window.jsPDF;
            } else {
                console.error('❌ jsPDF library not found');
                showNotification('Error', 'PDF library not available. Please refresh the page and try again.', 'error');
                return;
            }
            
            console.log('🔧 Creating jsPDF instance...');
            const doc = new jsPDF();
            
            // Colors
            const primaryColor = [16, 185, 129]; // Green
            const secondaryColor = [107, 114, 128]; // Gray
            const textColor = [0, 0, 0]; // Black
            
            let yPos = 30;
            
            // Header
            doc.setFontSize(24);
            doc.setTextColor(...primaryColor);
            doc.text('NutriTracker Progress Report', 20, yPos);
            
            // Subtitle
            yPos += 15;
            doc.setFontSize(14);
            doc.setTextColor(...secondaryColor);
            doc.text(`Generated on ${new Date().toLocaleDateString()}`, 20, yPos);
            
            // Summary
            yPos += 20;
            doc.setFontSize(16);
            doc.setTextColor(...textColor);
            doc.text('Progress Summary', 20, yPos);
            
            yPos += 15;
            doc.setFontSize(12);
            doc.setTextColor(...secondaryColor);
            doc.text(`Total Entries: ${entries.length}`, 25, yPos);
            
            if (entries.length > 0) {
                yPos += 8;
                const startDate = new Date(entries[0].date).toLocaleDateString();
                const endDate = new Date(entries[entries.length - 1].date).toLocaleDateString();
                doc.text(`Period: ${startDate} - ${endDate}`, 25, yPos);
            }
            
            // Data Table
            yPos += 25;
            doc.setFontSize(14);
            doc.setTextColor(...textColor);
            doc.text('Progress Entries', 20, yPos);
            
            // Table headers
            yPos += 15;
            doc.setFontSize(10);
            doc.setTextColor(...textColor);
            doc.text('Date', 25, yPos);
            doc.text('Weight', 65, yPos);
            doc.text('Waist', 95, yPos);
            doc.text('Chest', 125, yPos);
            doc.text('Hips', 155, yPos);
            doc.text('Arms', 180, yPos);
            
            // Table data
            entries.forEach((entry, index) => {
                yPos += 12;
                
                // Check if we need a new page
                if (yPos > 270) {
                    doc.addPage();
                    yPos = 30;
                }
                
                doc.setTextColor(...secondaryColor);
                doc.text(new Date(entry.date).toLocaleDateString(), 25, yPos);
                doc.text(entry.weight ? `${entry.weight} kg` : '--', 65, yPos);
                doc.text(entry.waist ? `${entry.waist} cm` : '--', 95, yPos);
                doc.text(entry.chest ? `${entry.chest} cm` : '--', 125, yPos);
                doc.text(entry.hips ? `${entry.hips} cm` : '--', 155, yPos);
                doc.text(entry.arms ? `${entry.arms} cm` : '--', 180, yPos);
            });
            
            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(...secondaryColor);
                doc.text(`Page ${i} of ${pageCount}`, 170, 285);
                doc.text('Generated by NutriTracker Pro', 20, 285);
            }
            
            // Save
            const dateStr = new Date().toISOString().split('T')[0];
            const filename = `Progress-Report-${dateStr}.pdf`;
            console.log('💾 Attempting to download PDF:', filename);
            
            try {
                doc.save(filename);
                console.log('✅ PDF download initiated successfully');
            } catch (error) {
                console.error('❌ PDF save failed:', error);
                showNotification('Download Failed', 'Failed to download PDF: ' + error.message, 'error');
            }
        }

        function generateProgressReportPDF(stats, dateStr) {
            // Check if stats exists
            if (!stats) {
                console.error('No stats object provided for PDF generation');
                showNotification('Export Failed', 'Unable to generate PDF report. Please try again.', 'error');
                return;
            }
            
            // Handle case with no entries - create a report showing empty state
            const hasEntries = stats.entries && stats.entries.length > 0;
            
            // Check if jsPDF is available
            if (typeof window.jsPDF === 'undefined') {
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
                script.onload = () => generateProgressReportPDF(stats, dateStr);
                document.head.appendChild(script);
                return;
            }

            const { jsPDF } = window;
            const doc = new jsPDF();
            
            // Set up fonts and colors
            doc.setFont('helvetica');
            const primaryColor = [16, 185, 129]; // Green
            const secondaryColor = [107, 114, 128]; // Gray
            
            let yPos = 30;
            
            // Header Section
            doc.setFontSize(22);
            doc.setTextColor(...primaryColor);
            doc.text('NutriTracker Pro', 20, yPos);
            
            doc.setFontSize(18);
            doc.setTextColor(0, 0, 0);
            yPos += 15;
            doc.text('Progress Tracking Report', 20, yPos);
            
            // Report Info
            doc.setFontSize(11);
            doc.setTextColor(...secondaryColor);
            yPos += 20;
            doc.text(`Generated: ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}`, 20, yPos);
            yPos += 8;
            
            if (hasEntries && stats.dateRange && stats.dateRange.start && stats.dateRange.end) {
                doc.text(`Tracking Period: ${new Date(stats.dateRange.start).toLocaleDateString()} - ${new Date(stats.dateRange.end).toLocaleDateString()}`, 20, yPos);
                yPos += 8;
            } else if (!hasEntries) {
                doc.text('Tracking Period: No data recorded yet', 20, yPos);
                yPos += 8;
            }
            
            doc.text(`Total Entries: ${stats.totalEntries || 0}`, 20, yPos);
            
            // Goal Information
            yPos += 20;
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0);
            doc.text('FITNESS GOALS', 20, yPos);
            
            doc.setFontSize(10);
            doc.setTextColor(...secondaryColor);
            yPos += 15;
            if (stats.goal && stats.goal.targetWeight) {
                doc.text(`Target Weight: ${stats.goal.targetWeight} ${stats.goal.weightUnit || 'lbs'}`, 25, yPos);
                yPos += 8;
            }
            if (stats.goal && stats.goal.targetDate) {
                doc.text(`Target Date: ${new Date(stats.goal.targetDate).toLocaleDateString()}`, 25, yPos);
                yPos += 8;
            }
            
            // Progress Summary
            yPos += 15;
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0);
            doc.text('PROGRESS SUMMARY', 20, yPos);
            
            yPos += 15;
            doc.setFontSize(10);
            
            if (!hasEntries) {
                // Show empty state message
                doc.setTextColor(...secondaryColor);
                doc.text('No progress entries recorded yet.', 25, yPos);
                yPos += 8;
                doc.text('Start tracking your progress by adding entries in the app!', 25, yPos);
                yPos += 20;
            } else {
                // Weight Progress
                if (stats.weight) {
                const weightChange = stats.weight.change;
                const changeColor = weightChange >= 0 ? [34, 197, 94] : [239, 68, 68]; // Green for gain, Red for loss
                
                doc.setTextColor(0, 0, 0);
                doc.text('Weight Progress:', 25, yPos);
                yPos += 8;
                
                doc.text(`• Initial: ${stats.weight.initial.toFixed(1)} lbs`, 30, yPos);
                yPos += 6;
                doc.text(`• Current: ${stats.weight.current.toFixed(1)} lbs`, 30, yPos);
                yPos += 6;
                
                doc.setTextColor(...changeColor);
                doc.text(`• Change: ${weightChange > 0 ? '+' : ''}${weightChange.toFixed(1)} lbs`, 30, yPos);
                yPos += 6;
                
                doc.setTextColor(...secondaryColor);
                doc.text(`• Trend: ${stats.weight.trend > 0 ? 'Increasing' : stats.weight.trend < 0 ? 'Decreasing' : 'Stable'}`, 30, yPos);
                yPos += 10;
            }
            
            // Body Fat Progress
            if (stats.bodyFat) {
                doc.setTextColor(0, 0, 0);
                doc.text('Body Fat Progress:', 25, yPos);
                yPos += 8;
                
                doc.setTextColor(...secondaryColor);
                doc.text(`• Initial: ${stats.bodyFat.initial.toFixed(1)}%`, 30, yPos);
                yPos += 6;
                doc.text(`• Current: ${stats.bodyFat.current.toFixed(1)}%`, 30, yPos);
                yPos += 6;
                doc.text(`• Change: ${stats.bodyFat.change > 0 ? '+' : ''}${stats.bodyFat.change.toFixed(1)}%`, 30, yPos);
                yPos += 10;
            }
            
            // Muscle Mass Progress
            if (stats.muscleMass) {
                doc.setTextColor(0, 0, 0);
                doc.text('Muscle Mass Progress:', 25, yPos);
                yPos += 8;
                
                doc.setTextColor(...secondaryColor);
                doc.text(`• Initial: ${stats.muscleMass.initial.toFixed(1)} lbs`, 30, yPos);
                yPos += 6;
                doc.text(`• Current: ${stats.muscleMass.current.toFixed(1)} lbs`, 30, yPos);
                yPos += 6;
                doc.text(`• Change: ${stats.muscleMass.change > 0 ? '+' : ''}${stats.muscleMass.change.toFixed(1)} lbs`, 30, yPos);
                yPos += 10;
            }
            
            // Add new page for data table
            doc.addPage();
            yPos = 30;
            
            // Data Table Header
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0);
            doc.text('DETAILED PROGRESS DATA', 20, yPos);
            
            yPos += 20;
            doc.setFontSize(9);
            
            // Table Headers
            doc.setTextColor(...primaryColor);
            doc.text('Date', 25, yPos);
            doc.text('Weight', 55, yPos);
            doc.text('Body Fat %', 85, yPos);
            doc.text('Muscle Mass', 120, yPos);
            doc.text('Notes', 155, yPos);
            
            yPos += 8;
            
            // Table Data
            doc.setTextColor(0, 0, 0);
            stats.entries.forEach(entry => {
                if (yPos > 270) {
                    doc.addPage();
                    yPos = 30;
                }
                
                doc.text(new Date(entry.date).toLocaleDateString(), 25, yPos);
                doc.text(entry.weight ? `${entry.weight} lbs` : '-', 55, yPos);
                doc.text(entry.bodyFat ? `${entry.bodyFat}%` : '-', 85, yPos);
                doc.text(entry.muscleMass ? `${entry.muscleMass} lbs` : '-', 120, yPos);
                doc.text(entry.notes ? entry.notes.substring(0, 20) + '...' : '-', 155, yPos);
                
                yPos += 7;
            });
            
            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFontSize(8);
                doc.setTextColor(...secondaryColor);
                doc.text(`Page ${i} of ${pageCount}`, 170, 285);
                doc.text('Generated by NutriTracker Pro - Transform your nutrition, transform your life!', 20, 285);
            }
            
            } // Close the else block for hasEntries
            
            // Save PDF
            doc.save(`NutriTracker-ProgressReport-${dateStr}.pdf`);
        }

        // Simple, reliable CSV generation
        function generateSimpleCSV(entries) {
            try {
                let csv = 'Date,Weight (kg),Waist (cm),Chest (cm),Hips (cm),Arms (cm),Notes\n';
                
                entries.forEach(entry => {
                    const date = entry.date ? new Date(entry.date).toLocaleDateString() : '';
                    const weight = entry.weight || '';
                    const waist = entry.waist || '';
                    const chest = entry.chest || '';
                    const hips = entry.hips || '';
                    const arms = entry.arms || '';
                    const notes = entry.notes ? `"${entry.notes.replace(/"/g, '""')}"` : '';
                    
                    csv += `${date},${weight},${waist},${chest},${hips},${arms},${notes}\n`;
                });
                
                return csv;
                
            } catch (error) {
                console.error('❌ CSV generation error:', error);
                return 'Date,Weight (kg),Waist (cm),Chest (cm),Hips (cm),Arms (cm),Notes\n# Error generating CSV data\n';
            }
        }

        // Generate CSV format
        function generateProgressCSV(stats) {
            try {
                if (!stats || !stats.entries || !Array.isArray(stats.entries) || stats.entries.length === 0) {
                    console.warn('No progress data available for CSV generation');
                    // Return CSV with headers only
                    return 'Date,Weight (lbs),Body Fat (%),Muscle Mass (lbs),Notes\n# No progress entries recorded yet\n# Start tracking your progress in the app!';
                }
                
                let csv = 'Date,Weight (lbs),Body Fat (%),Muscle Mass (lbs),Notes\\n';
                
                stats.entries.forEach(entry => {
                    if (entry && entry.date) {
                        const date = new Date(entry.date).toLocaleDateString();
                        const weight = entry.weight || '';
                        const bodyFat = entry.bodyFat || '';
                        const muscleMass = entry.muscleMass || '';
                        const notes = entry.notes ? `"${entry.notes.replace(/"/g, '""')}"` : '';
                        
                        csv += `${date},${weight},${bodyFat},${muscleMass},${notes}\\n`;
                    }
                });
                
                return csv;
            } catch (error) {
                console.error('Error generating CSV:', error);
                return null;
            }
        }

        // Generate Excel format
        function generateProgressExcel(stats, dateStr) {
            try {
                if (!stats) {
                    console.error('No stats object provided for Excel generation');
                    showNotification('Error', 'Cannot generate Excel file - no data available', 'error');
                    return;
                }
                
                const hasEntries = stats.entries && Array.isArray(stats.entries) && stats.entries.length > 0;
                
                // Generate enhanced CSV with additional statistics
                let content = 'NutriTracker Pro - Progress Report\\n';
                content += `Generated: ${new Date().toLocaleDateString()}\\n`;
                
                if (hasEntries && stats.dateRange && stats.dateRange.start && stats.dateRange.end) {
                    content += `Period: ${new Date(stats.dateRange.start).toLocaleDateString()} - ${new Date(stats.dateRange.end).toLocaleDateString()}\\n\\n`;
                } else {
                    content += 'Period: No data recorded yet\\n\\n';
                }
                
                if (!hasEntries) {
                    content += 'No progress entries recorded yet.\\n';
                    content += 'Start tracking your progress in the app!\\n\\n';
                    content += `Total Entries: ${stats.totalEntries || 0}\\n\\n`;
                }
                
                // Summary statistics
                content += 'SUMMARY STATISTICS\\n';
                if (stats.weight) {
                    content += `Weight Change: ${stats.weight.change ? stats.weight.change.toFixed(1) : 'N/A'} lbs\\n`;
                    content += `Weight Average: ${stats.weight.average ? stats.weight.average.toFixed(1) : 'N/A'} lbs\\n`;
                }
                if (stats.bodyFat) {
                    content += `Body Fat Change: ${stats.bodyFat.change ? stats.bodyFat.change.toFixed(1) : 'N/A'}%\\n`;
                }
                if (stats.muscleMass) {
                    content += `Muscle Mass Change: ${stats.muscleMass.change ? stats.muscleMass.change.toFixed(1) : 'N/A'} lbs\\n`;
                }
                content += '\\n';
                
                // Data table
                content += 'DETAILED DATA\\n';
                const csvData = generateProgressCSV(stats);
                if (csvData) {
                    content += csvData;
                } else {
                    content += 'No detailed data available\\n';
                }
                
                downloadFile(content, `NutriTracker-ProgressData-${dateStr}.xlsx`, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            } catch (error) {
                console.error('Error generating Excel file:', error);
                showNotification('Error', 'Failed to generate Excel file: ' + error.message, 'error');
            }
        }

        // Helper function to download files
        function downloadFile(content, filename, mimeType) {
            try {
                if (!content) {
                    throw new Error('No content provided for download');
                }
                
                const blob = new Blob([content], { type: mimeType });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up the URL object
                setTimeout(() => URL.revokeObjectURL(url), 100);
            } catch (error) {
                console.error('Error downloading file:', error);
                showNotification('Error', 'Failed to download file: ' + error.message, 'error');
            }
        }

        function clearAllProgressData() {
            showConfirmDialog(
                'Clear All Progress Data',
                'Are you sure you want to delete all progress entries and goals? This action cannot be undone.',
                () => {
                    const count = progressEntries.length;
                    progressEntries = [];
                    progressGoal = null;
                    
                    // Clear goal form
                    const targetWeightEl = document.getElementById('targetWeight');
                    const targetDateEl = document.getElementById('targetDate');
                    if (targetWeightEl) targetWeightEl.value = '';
                    if (targetDateEl) targetDateEl.value = '';
                    
                    saveProgressData();
                    updateProgressDisplay();
                    updateProgressChart();
                    showNotification('All Progress Data Cleared', `${count} progress entries, recent timeline, and latest measurements have been cleared`, 'success');
                }
            );
        }

        function saveProgressData() {
            try {
                // Primary storage
                localStorage.setItem('progressEntries', JSON.stringify(progressEntries));
                localStorage.setItem('progressGoal', JSON.stringify(progressGoal));
                
                // Backup storage with timestamp
                const backupData = {
                    entries: progressEntries,
                    goal: progressGoal,
                    timestamp: Date.now(),
                    version: '1.0'
                };
                localStorage.setItem('progressData_backup', JSON.stringify(backupData));
                
                // Multiple storage keys for redundancy
                localStorage.setItem('progress_entries_v2', JSON.stringify(progressEntries));
                localStorage.setItem('progress_goal_v2', JSON.stringify(progressGoal));
                
                console.log('Progress data saved successfully:', {
                    entries: progressEntries.length,
                    goal: progressGoal ? 'Set' : 'None',
                    timestamp: new Date().toISOString()
                });
            } catch (error) {
                console.error('Error saving progress data:', error);
                showNotification('Save Error', 'Failed to save progress data. Please try again.', 'error');
            }
        }

        async function loadProgressData() {
            console.log('Loading progress data...');
            
            try {
                // Try multiple storage sources in order of preference
                let loadedEntries = false;
                let loadedGoal = false;
                
                // 0. Try database first (highest priority)
                try {
                    console.log('🔄 Loading progress data from database...');
                    
                    // Load progress entries from database
                    const dbEntries = await loadProgressEntries();
                    if (dbEntries && dbEntries.length > 0) {
                        progressEntries = dbEntries;
                        loadedEntries = true;
                        console.log('✅ Loaded from database:', progressEntries.length, 'entries');
                    }
                    
                    // Load progress goal from database
                    const dbGoal = await loadProgressGoalFromDB();
                    if (dbGoal) {
                        progressGoal = dbGoal;
                        loadedGoal = true;
                        console.log('✅ Loaded goal from database');
                    }
                } catch (dbError) {
                    console.warn('⚠️ Database loading failed, using localStorage fallback:', dbError.message);
                }
                
                // 1. Try primary storage
                const savedEntries = localStorage.getItem('progressEntries');
                const savedGoal = localStorage.getItem('progressGoal');
                
                if (savedEntries && savedEntries !== 'null') {
                    const parsed = JSON.parse(savedEntries);
                    if (Array.isArray(parsed) && parsed.length > 0) {
                        progressEntries = parsed;
                        loadedEntries = true;
                        console.log('Loaded from primary storage:', progressEntries.length, 'entries');
                    }
                }
                
                // 2. Try backup storage if primary failed
                if (!loadedEntries) {
                    const backupData = localStorage.getItem('progressData_backup');
                    if (backupData) {
                        const backup = JSON.parse(backupData);
                        if (backup.entries && Array.isArray(backup.entries)) {
                            progressEntries = backup.entries;
                            loadedEntries = true;
                            console.log('Loaded from backup storage:', progressEntries.length, 'entries');
                        }
                        if (backup.goal && !loadedGoal) {
                            progressGoal = backup.goal;
                            loadedGoal = true;
                        }
                    }
                }
                
                // 3. Try v2 storage if others failed
                if (!loadedEntries) {
                    const v2Entries = localStorage.getItem('progress_entries_v2');
                    if (v2Entries) {
                        const parsed = JSON.parse(v2Entries);
                        if (Array.isArray(parsed)) {
                            progressEntries = parsed;
                            loadedEntries = true;
                            console.log('Loaded from v2 storage:', progressEntries.length, 'entries');
                        }
                    }
                }
                
                // Load goal if not loaded from backup
                if (!loadedGoal && savedGoal && savedGoal !== 'null') {
                    const parsed = JSON.parse(savedGoal);
                    if (parsed && typeof parsed === 'object') {
                        progressGoal = parsed;
                        loadedGoal = true;
                        console.log('Loaded goal from primary storage');
                    }
                }
                
                // Try v2 goal storage
                if (!loadedGoal) {
                    const v2Goal = localStorage.getItem('progress_goal_v2');
                    if (v2Goal && v2Goal !== 'null') {
                        const parsed = JSON.parse(v2Goal);
                        if (parsed && typeof parsed === 'object') {
                            progressGoal = parsed;
                            loadedGoal = true;
                            console.log('Loaded goal from v2 storage');
                        }
                    }
                }
                
                // Ensure data integrity
                if (progressEntries && progressEntries.length > 0) {
                    // Ensure data is sorted by date (newest first)
                    progressEntries.sort((a, b) => new Date(b.date) - new Date(a.date));
                    
                    // Validate data structure
                    progressEntries = progressEntries.filter(entry => {
                        return entry && entry.date && entry.weight && !isNaN(entry.weight);
                    });
                    
                    console.log('Progress entries validated:', progressEntries.length, 'valid entries');
                }
                
                // Populate goal form fields after DOM is ready
                setTimeout(() => {
                    if (progressGoal) {
                        const targetWeightEl = document.getElementById('targetWeight');
                        const targetDateEl = document.getElementById('targetDate');
                        if (targetWeightEl && progressGoal.targetWeight) {
                            targetWeightEl.value = progressGoal.targetWeight;
                            console.log('Populated target weight:', progressGoal.targetWeight);
                        }
                        if (targetDateEl && progressGoal.targetDate) {
                            targetDateEl.value = progressGoal.targetDate;
                            console.log('Populated target date:', progressGoal.targetDate);
                        }
                    }
                }, 200);
                
                console.log('Progress data loading complete:', {
                    entries: progressEntries.length,
                    goal: progressGoal ? 'Loaded' : 'None'
                });
                
            } catch (error) {
                console.error('Error loading progress data:', error);
                progressEntries = [];
                progressGoal = null;
                showNotification('Load Error', 'Some progress data may not have loaded correctly', 'warning');
            }
        }

        // Helper function to update elements safely
        function updateElement(id, value) {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = value;
            }
        }
        
        // Helper function to refresh progress display
        function refreshProgressDisplay() {
            if (progressEntries && progressEntries.length > 0) {
                updateProgressDisplay();
                if (progressChart) {
                    updateProgressChart();
                }
            }
        }
        
        // Auto-save mechanism
        function setupAutoSave() {
            // Save all data every 30 seconds as backup
            setInterval(() => {
                // Save progress data
                if (progressEntries.length > 0 || progressGoal) {
                    saveProgressData();
                }
                
                // Save macro tracking data
                if (meals.length > 0 || currentIntake.protein > 0 || currentIntake.carbs > 0 || currentIntake.fat > 0) {
                    saveData();
                    saveDailyMacros().catch(error => console.error('Error saving daily macros:', error));
                }
                
                // Save meal plan data
                saveMealPlan().catch(error => console.warn('Meal plan save error:', error));
                
                console.log('Auto-save completed at', new Date().toLocaleTimeString());
            }, 30000); // 30 seconds
        }
        
        // Data verification function
        function verifyDataIntegrity() {
            console.log('Verifying data integrity...');
            
            const checks = {
                progressEntries: progressEntries && Array.isArray(progressEntries) && progressEntries.length >= 0,
                progressGoal: progressGoal === null || (progressGoal && typeof progressGoal === 'object'),
                localStorage: typeof localStorage !== 'undefined'
            };
            
            console.log('Data integrity check:', checks);
            
            if (!checks.localStorage) {
                showNotification('Storage Warning', 'Local storage not available. Data may not persist.', 'warning');
                return false;
            }
            
            // Verify macro tracking data integrity
            verifyMacroDataIntegrity();
            
            return Object.values(checks).every(Boolean);
        }
        
        function verifyMacroDataIntegrity() {
            console.log('Verifying macro data integrity...', {
                meals: meals.length,
                currentIntake: currentIntake,
                dailyTargets: dailyTargets
            });
            
            // Recalculate currentIntake from meals to ensure consistency
            if (meals && meals.length > 0) {
                const recalculatedIntake = {
                    protein: meals.reduce((sum, meal) => sum + (meal.protein || 0), 0),
                    carbs: meals.reduce((sum, meal) => sum + (meal.carbs || 0), 0),
                    fat: meals.reduce((sum, meal) => sum + (meal.fat || 0), 0)
                };
                
                // If there's a mismatch, fix it
                if (Math.abs(currentIntake.protein - recalculatedIntake.protein) > 0.1 ||
                    Math.abs(currentIntake.carbs - recalculatedIntake.carbs) > 0.1 ||
                    Math.abs(currentIntake.fat - recalculatedIntake.fat) > 0.1) {
                    console.warn('Macro data integrity issue detected - fixing currentIntake', {
                        stored: currentIntake,
                        calculated: recalculatedIntake
                    });
                    currentIntake = recalculatedIntake;
                    localStorage.setItem('currentIntake', JSON.stringify(currentIntake));
                    
                    // Update displays to reflect correct data
                    updateProgress();
                }
            }
        }
        
        // Enhanced data export for backup
        function createDataBackup() {
            const backup = {
                progressEntries: progressEntries,
                progressGoal: progressGoal,
                timestamp: Date.now(),
                date: new Date().toISOString(),
                version: '2.0',
                entryCount: progressEntries.length
            };
            
            const dataStr = JSON.stringify(backup, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `progress-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            showNotification('Backup Created', 'Progress data backup downloaded successfully', 'success');
        }
        
        // Restore from final backup if available
        function checkForFinalBackup() {
            try {
                const finalBackup = localStorage.getItem('progress_final_backup');
                if (finalBackup) {
                    const backup = JSON.parse(finalBackup);
                    if (backup.finalSave && backup.progressEntries) {
                        console.log('Found final backup from previous session');
                        
                        if (progressEntries.length === 0 && backup.progressEntries.length > 0) {
                            console.log('Restoring from final backup:', backup.progressEntries.length, 'entries');
                            progressEntries = backup.progressEntries;
                            if (backup.progressGoal) {
                                progressGoal = backup.progressGoal;
                            }
                            saveProgressData(); // Save restored data to primary storage
                            updateProgressDisplay();
                            showNotification('Data Restored', 'Progress data restored from previous session', 'info');
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking final backup:', error);
            }
        }
        
        // Helper function to refresh macro progress display
        function refreshMacroProgress() {
            console.log('Refreshing macro progress...');
            // Save current day's data first
            if (meals.length > 0 || (currentIntake.protein + currentIntake.carbs + currentIntake.fat) > 0) {
                saveDailyMacros().catch(error => console.error('Error saving daily macros:', error));
            }
            // Force refresh of displays
            setTimeout(() => {
                updateMacroProgressDisplay();
                updateMacroCharts();
                showNotification('Macro Progress Updated', 'Latest data has been refreshed', 'success');
            }, 100);
        }
        
        // Clear all macro progress data
        function clearMacroProgress() {
            showConfirmDialog(
                'Clear Macro Progress Data',
                'Are you sure you want to clear ALL macro progress data? This will permanently delete all daily macro history, progress charts data, and trend statistics. This action cannot be undone.',
                () => {
                    try {
                        // Clear the macroHistory array
                        macroHistory = [];
                        
                        // Remove from localStorage
                        localStorage.removeItem('macroHistory');
                        
                        // Reset all macro progress displays
                        updateMacroProgressDisplay();
                        updateMacroCharts();
                        
                        // Clear the progress table
                        const tableBody = document.getElementById('macroHistoryTable');
                        if (tableBody) {
                            tableBody.innerHTML = `
                                <tr>
                                    <td colspan="6" class="text-center py-8 text-gray-500">
                                        <i class="fas fa-chart-line text-2xl mb-2"></i>
                                        <p>Start tracking daily macros to see your progress here!</p>
                                    </td>
                                </tr>
                            `;
                        }
                        
                        // Reset macro stats overview
                        document.getElementById('avgProtein').textContent = '0g';
                        document.getElementById('avgCarbs').textContent = '0g';
                        document.getElementById('avgFat').textContent = '0g';
                        document.getElementById('proteinTrend').textContent = 'No trend';
                        document.getElementById('carbsTrend').textContent = 'No trend';
                        document.getElementById('fatTrend').textContent = 'No trend';
                        
                        console.log('Macro progress data cleared successfully');
                        showNotification('Progress Data Cleared', 'All macro progress data has been permanently deleted', 'success');
                        
                    } catch (error) {
                        console.error('Error clearing macro progress:', error);
                        showNotification('Clear Failed', 'There was an error clearing the progress data. Please try again.', 'error');
                    }
                }
            );
        }
        


            

            











        // Macro Progress Tracking Functions
        let macroHistory = [];
        let macroTotalsChart = null;
        let macroGoalsChart = null;

        async function initializeMacroTracking() {
            console.log('Initializing macro tracking...');
            await loadMacroHistory();
            
            // Use timeout to ensure DOM is ready
            setTimeout(() => {
                updateMacroProgressDisplay();
                initializeMacroCharts();
                
                // Save current day's data if we have any meals
                if (meals.length > 0 || (currentIntake.protein + currentIntake.carbs + currentIntake.fat) > 0) {
                    saveDailyMacros().catch(error => console.error('Error saving daily macros:', error));
                }
                
                console.log('Macro tracking initialized');
            }, 200);
        }

        async function saveDailyMacros() {
            const today = new Date().toISOString().split('T')[0];
            
            // Get current macro totals from the daily tracker
            const currentProtein = Math.round(currentIntake.protein || 0);
            const currentCarbs = Math.round(currentIntake.carbs || 0);
            const currentFat = Math.round(currentIntake.fat || 0);
            const currentCalories = Math.round(meals.reduce((sum, meal) => sum + meal.calories, 0));

            // Get macro goals
            const proteinGoal = dailyTargets.protein || 0;
            const carbsGoal = dailyTargets.carbs || 0;
            const fatGoal = dailyTargets.fat || 0;
            const caloriesGoal = dailyTargets.calories || 0;

            // Only save if we have meaningful data (calories > 0 or goals set)
            if (currentCalories === 0 && proteinGoal === 0) {
                return; // Don't save empty entries
            }

            // Check if entry for today already exists
            const existingIndex = macroHistory.findIndex(entry => entry.date === today);
            
            const macroEntry = {
                date: today,
                calories: currentCalories,
                protein: currentProtein,
                carbs: currentCarbs,
                fat: currentFat,
                caloriesGoal: caloriesGoal,
                proteinGoal: proteinGoal,
                carbsGoal: carbsGoal,
                fatGoal: fatGoal,
                proteinPercent: proteinGoal > 0 ? Math.round((currentProtein / proteinGoal) * 100) : 0,
                carbsPercent: carbsGoal > 0 ? Math.round((currentCarbs / carbsGoal) * 100) : 0,
                fatPercent: fatGoal > 0 ? Math.round((currentFat / fatGoal) * 100) : 0,
                goalsMet: (currentProtein >= proteinGoal * 0.9 && currentCarbs >= carbsGoal * 0.9 && currentFat >= fatGoal * 0.9)
            };

            if (existingIndex >= 0) {
                macroHistory[existingIndex] = macroEntry;
            } else {
                macroHistory.push(macroEntry);
            }

            // Keep only last 30 days of data
            macroHistory = macroHistory
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 30);

            try {
                // Save to database first
                const dbResult = await saveMacroHistoryToDB(macroEntry);
                
                if (dbResult && !dbResult.fallback) {
                    console.log('✅ Macro history saved to database:', dbResult);
                } else {
                    console.log('📱 Macro history saved to localStorage fallback');
                }
            } catch (error) {
                console.error('❌ Error saving macro history to database:', error);
            }
            
            // Also save to localStorage for backwards compatibility and offline access
            localStorage.setItem('macroHistory', JSON.stringify(macroHistory));
            
            // Force immediate update of macro progress display
            setTimeout(() => {
                updateMacroProgressDisplay();
                updateMacroCharts();
            }, 100);
            
            console.log('Saved daily macros:', macroEntry);
        }

        async function loadMacroHistory() {
            console.log('📡 Loading macro history data...');
            
            try {
                // Try database first (highest priority)
                const dbHistory = await loadMacroHistoryFromDB();
                
                if (dbHistory && dbHistory.length > 0) {
                    macroHistory = dbHistory;
                    console.log('✅ Loaded macro history from database:', macroHistory.length, 'entries');
                    
                    // Also save to localStorage for offline access
                    localStorage.setItem('macroHistory', JSON.stringify(macroHistory));
                    return;
                }
                
                // Fallback to localStorage
                console.log('📱 Loading macro history from localStorage fallback...');
                const saved = localStorage.getItem('macroHistory');
                if (saved && saved !== 'null') {
                    const parsed = JSON.parse(saved);
                    if (Array.isArray(parsed)) {
                        macroHistory = parsed;
                        console.log('Loaded macro history from localStorage:', macroHistory.length, 'entries');
                    } else {
                        macroHistory = [];
                    }
                } else {
                    macroHistory = [];
                }
            } catch (error) {
                console.error('❌ Error loading macro history:', error);
                
                // Final fallback to localStorage
                try {
                    const saved = localStorage.getItem('macroHistory');
                    if (saved && saved !== 'null') {
                        const parsed = JSON.parse(saved);
                        if (Array.isArray(parsed)) {
                            macroHistory = parsed;
                        } else {
                            macroHistory = [];
                        }
                    } else {
                        macroHistory = [];
                    }
                } catch (localStorageError) {
                    console.error('❌ Even localStorage fallback failed:', localStorageError);
                    macroHistory = [];
                }
            }
        }

        function updateMacroProgressDisplay() {
            const last7Days = macroHistory
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 7);

            if (last7Days.length > 0) {
                // Calculate averages
                const avgProtein = Math.round(last7Days.reduce((sum, entry) => sum + entry.protein, 0) / last7Days.length);
                const avgCarbs = Math.round(last7Days.reduce((sum, entry) => sum + entry.carbs, 0) / last7Days.length);
                const avgFat = Math.round(last7Days.reduce((sum, entry) => sum + entry.fat, 0) / last7Days.length);

                // Calculate trends (compare first 3 days vs last 3 days)
                const firstHalf = last7Days.slice(-3);
                const secondHalf = last7Days.slice(0, 3);
                
                const proteinTrend = calculateTrend(firstHalf, secondHalf, 'protein');
                const carbsTrend = calculateTrend(firstHalf, secondHalf, 'carbs');
                const fatTrend = calculateTrend(firstHalf, secondHalf, 'fat');

                updateElement('avgProtein', avgProtein + 'g');
                updateElement('avgCarbs', avgCarbs + 'g');
                updateElement('avgFat', avgFat + 'g');
                updateElement('proteinTrend', proteinTrend);
                updateElement('carbsTrend', carbsTrend);
                updateElement('fatTrend', fatTrend);
            }

            updateMacroHistoryTable();
        }

        function calculateTrend(firstHalf, secondHalf, macro) {
            if (firstHalf.length === 0 || secondHalf.length === 0) return 'No trend';
            
            const firstAvg = firstHalf.reduce((sum, entry) => sum + entry[macro], 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((sum, entry) => sum + entry[macro], 0) / secondHalf.length;
            
            const change = secondAvg - firstAvg;
            const changePercent = Math.abs(change / firstAvg * 100);
            
            if (changePercent < 5) return 'Stable';
            return change > 0 ? `↗ +${Math.round(change)}g` : `↘ ${Math.round(change)}g`;
        }

        function updateMacroHistoryTable() {
            const tableBody = document.getElementById('macroHistoryTable');
            if (!tableBody) return;

            const last7Days = macroHistory
                .sort((a, b) => new Date(b.date) - new Date(a.date))
                .slice(0, 7);

            if (last7Days.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="6" class="text-center py-8 text-gray-500">
                            <i class="fas fa-chart-line text-2xl mb-2"></i>
                            <p>Start tracking daily macros to see your progress here!</p>
                        </td>
                    </tr>
                `;
                return;
            }

            tableBody.innerHTML = last7Days.map(entry => {
                const date = new Date(entry.date).toLocaleDateString();
                const goalBadge = entry.goalsMet 
                    ? '<span class="px-2 py-1 bg-green-100 text-green-800 rounded-full text-xs">✓ Met</span>'
                    : '<span class="px-2 py-1 bg-red-100 text-red-800 rounded-full text-xs">✗ Missed</span>';
                
                return `
                    <tr class="border-b border-gray-100 hover:bg-gray-50">
                        <td class="p-3 font-medium">${date}</td>
                        <td class="p-3 text-center">${entry.calories}</td>
                        <td class="p-3 text-center text-red-600">${entry.protein}g (${entry.proteinPercent}%)</td>
                        <td class="p-3 text-center text-yellow-600">${entry.carbs}g (${entry.carbsPercent}%)</td>
                        <td class="p-3 text-center text-green-600">${entry.fat}g (${entry.fatPercent}%)</td>
                        <td class="p-3 text-center">${goalBadge}</td>
                    </tr>
                `;
            }).join('');
        }

        function initializeMacroCharts() {
            console.log('Initializing macro charts...');
            // Destroy existing macro charts first to prevent canvas conflicts
            macroTotalsChart = destroyChart(macroTotalsChart);
            macroGoalsChart = destroyChart(macroGoalsChart);
            
            // Initialize Macro Totals Chart
            const totalsCtx = document.getElementById('macroTotalsChart');
            if (totalsCtx) {
                try {
                    macroTotalsChart = new Chart(totalsCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Protein (g)',
                                    data: [],
                                    borderColor: '#ef4444',
                                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3,
                                    pointRadius: 4,
                                    pointHoverRadius: 6
                                },
                                {
                                    label: 'Carbs (g)',
                                    data: [],
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3,
                                    pointRadius: 4,
                                    pointHoverRadius: 6
                                },
                                {
                                    label: 'Fat (g)',
                                    data: [],
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3,
                                    pointRadius: 4,
                                    pointHoverRadius: 6
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Grams'
                                    },
                                    grid: {
                                        color: 'rgba(0,0,0,0.1)'
                                    }
                                },
                                x: {
                                    grid: {
                                        color: 'rgba(0,0,0,0.1)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'top'
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false
                                }
                            }
                        }
                    });
                    console.log('Macro totals chart initialized');
                } catch (error) {
                    console.error('Error initializing macro totals chart:', error);
                }
            } else {
                console.error('Macro totals chart canvas not found');
            }

            // Initialize Macro Goals Chart
            const goalsCtx = document.getElementById('macroGoalsChart');
            if (goalsCtx) {
                try {
                    macroGoalsChart = new Chart(goalsCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Protein %',
                                    data: [],
                                    borderColor: '#ef4444',
                                    backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3,
                                    pointRadius: 4,
                                    pointHoverRadius: 6
                                },
                                {
                                    label: 'Carbs %',
                                    data: [],
                                    borderColor: '#f59e0b',
                                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3,
                                    pointRadius: 4,
                                    pointHoverRadius: 6
                                },
                                {
                                    label: 'Fat %',
                                    data: [],
                                    borderColor: '#10b981',
                                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                    borderWidth: 2,
                                    fill: false,
                                    tension: 0.3,
                                    pointRadius: 4,
                                    pointHoverRadius: 6
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                mode: 'index',
                                intersect: false
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 150,
                                    title: {
                                        display: true,
                                        text: 'Goal Achievement %'
                                    },
                                    grid: {
                                        color: 'rgba(0,0,0,0.1)'
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return value + '%';
                                        }
                                    }
                                },
                                x: {
                                    grid: {
                                        color: 'rgba(0,0,0,0.1)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'top'
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            return context.dataset.label + ': ' + context.parsed.y + '%';
                                        }
                                    }
                                }
                            }
                        }
                    });
                    console.log('Macro goals chart initialized');
                } catch (error) {
                    console.error('Error initializing macro goals chart:', error);
                }
            } else {
                console.error('Macro goals chart canvas not found');
            }

            // Initial update with current data
            setTimeout(() => {
                updateMacroCharts();
            }, 100);
        }

        function updateMacroCharts() {
            try {
                const last7Days = macroHistory
                    .sort((a, b) => new Date(a.date) - new Date(b.date))
                    .slice(-7);

                if (last7Days.length === 0) {
                    // Show empty state for charts
                    if (macroTotalsChart) {
                        macroTotalsChart.data.labels = ['No Data'];
                        macroTotalsChart.data.datasets[0].data = [];
                        macroTotalsChart.data.datasets[1].data = [];
                        macroTotalsChart.data.datasets[2].data = [];
                        macroTotalsChart.update('none');
                    }
                    
                    if (macroGoalsChart) {
                        macroGoalsChart.data.labels = ['No Data'];
                        macroGoalsChart.data.datasets[0].data = [];
                        macroGoalsChart.data.datasets[1].data = [];
                        macroGoalsChart.data.datasets[2].data = [];
                        macroGoalsChart.update('none');
                    }
                    
                    console.log('No macro data available for charts');
                    return;
                }

                const labels = last7Days.map(entry => {
                    const date = new Date(entry.date);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                });

                // Update Totals Chart
                if (macroTotalsChart) {
                    macroTotalsChart.data.labels = labels;
                    macroTotalsChart.data.datasets[0].data = last7Days.map(entry => entry.protein || 0);
                    macroTotalsChart.data.datasets[1].data = last7Days.map(entry => entry.carbs || 0);
                    macroTotalsChart.data.datasets[2].data = last7Days.map(entry => entry.fat || 0);
                    macroTotalsChart.update('none');
                    console.log('Updated macro totals chart with', last7Days.length, 'days of data');
                } else {
                    console.warn('Macro totals chart not available');
                }

                // Update Goals Chart
                if (macroGoalsChart) {
                    macroGoalsChart.data.labels = labels;
                    macroGoalsChart.data.datasets[0].data = last7Days.map(entry => entry.proteinPercent || 0);
                    macroGoalsChart.data.datasets[1].data = last7Days.map(entry => entry.carbsPercent || 0);
                    macroGoalsChart.data.datasets[2].data = last7Days.map(entry => entry.fatPercent || 0);
                    macroGoalsChart.update('none');
                    console.log('Updated macro goals chart with', last7Days.length, 'days of data');
                } else {
                    console.warn('Macro goals chart not available');
                }
            } catch (error) {
                console.error('Error updating macro charts:', error);
            }
        }

        // Export Functions for Weekly Meal Planner
        function exportMealPlanPDF() {
            try {
                // First check if jsPDF is available
                if (typeof window.jspdf === 'undefined') {
                    // Load jsPDF library if not already loaded
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
                    script.onload = () => {
                        exportMealPlanPDF(); // Retry after loading
                    };
                    document.head.appendChild(script);
                    showNotification('Loading PDF library...', 'Please wait', 'info');
                    return;
                }
                
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                // Get current date
                const currentDate = new Date();
                const weekStart = new Date(currentDate.setDate(currentDate.getDate() - currentDate.getDay()));
                
                // Title
                doc.setFontSize(20);
                doc.text('Weekly Meal Plan', 20, 30);
                
                doc.setFontSize(12);
                doc.text(`Week of: ${weekStart.toLocaleDateString()}`, 20, 45);
                
                // Get meal plan data from the correct location
                const savedMealPlan = window.JSON?.safeParse ? 
            window.JSON.safeParse(localStorage.getItem('mealPlan') || '{}', {}) :
            (() => {
                try {
                    return JSON.parse(localStorage.getItem('mealPlan') || '{}');
                } catch (error) {
                    console.warn('Error parsing meal plan:', error);
                    return {};
                }
            })();
                const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                const dayLabels = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                let yPosition = 60;
                let hasContent = false;
                
                days.forEach((day, index) => {
                    const dayData = savedMealPlan[day] || { breakfast: [], lunch: [], dinner: [] };
                    const hasDataForDay = dayData.breakfast.length > 0 || dayData.lunch.length > 0 || dayData.dinner.length > 0;
                    
                    if (hasDataForDay) {
                        hasContent = true;
                        
                        // Day header
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.text(dayLabels[index], 20, yPosition);
                        yPosition += 10;
                        
                        doc.setFont(undefined, 'normal');
                        doc.setFontSize(10);
                        
                        // Breakfast
                        if (dayData.breakfast && dayData.breakfast.length > 0) {
                            doc.text('  Breakfast:', 25, yPosition);
                            yPosition += 5;
                            dayData.breakfast.forEach(item => {
                                const macros = `${item.calories || 0} cal, ${item.protein || 0}g P, ${item.carbs || 0}g C, ${item.fat || 0}g F`;
                                doc.text(`    • ${item.name} (${macros})`, 30, yPosition);
                                yPosition += 5;
                            });
                        }
                        
                        // Lunch
                        if (dayData.lunch && dayData.lunch.length > 0) {
                            doc.text('  Lunch:', 25, yPosition);
                            yPosition += 5;
                            dayData.lunch.forEach(item => {
                                const macros = `${item.calories || 0} cal, ${item.protein || 0}g P, ${item.carbs || 0}g C, ${item.fat || 0}g F`;
                                doc.text(`    • ${item.name} (${macros})`, 30, yPosition);
                                yPosition += 5;
                            });
                        }
                        
                        // Dinner
                        if (dayData.dinner && dayData.dinner.length > 0) {
                            doc.text('  Dinner:', 25, yPosition);
                            yPosition += 5;
                            dayData.dinner.forEach(item => {
                                const macros = `${item.calories || 0} cal, ${item.protein || 0}g P, ${item.carbs || 0}g C, ${item.fat || 0}g F`;
                                doc.text(`    • ${item.name} (${macros})`, 30, yPosition);
                                yPosition += 5;
                            });
                        }
                        
                        yPosition += 10;
                        
                        // Check if we need a new page
                        if (yPosition > 250) {
                            doc.addPage();
                            yPosition = 20;
                        }
                    }
                });
                
                if (!hasContent) {
                    doc.text('No meals planned yet. Add some meals to your planner!', 20, yPosition);
                }
                
                // Download the PDF
                doc.save(`meal-plan-${weekStart.toISOString().split('T')[0]}.pdf`);
                showNotification('Success', 'Meal plan PDF exported successfully!', 'success');
                
            } catch (error) {
                console.error('Error exporting PDF:', error);
                showNotification('Export Error', 'Error exporting PDF. Please try again.', 'error');
            }
        }
        
        function exportMealPlanCSV() {
            try {
                // Get meal plan data from the correct location
                const savedMealPlan = window.JSON?.safeParse ? 
            window.JSON.safeParse(localStorage.getItem('mealPlan') || '{}', {}) :
            (() => {
                try {
                    return JSON.parse(localStorage.getItem('mealPlan') || '{}');
                } catch (error) {
                    console.warn('Error parsing meal plan:', error);
                    return {};
                }
            })();
                const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                const dayLabels = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                
                let csvContent = 'Day,Meal,Item,Calories,Protein (g),Carbs (g),Fat (g)\n';
                let hasContent = false;
                
                // Calculate totals
                let totalCalories = 0;
                let totalProtein = 0;
                let totalCarbs = 0;
                let totalFat = 0;
                
                days.forEach((day, index) => {
                    const dayData = savedMealPlan[day] || { breakfast: [], lunch: [], dinner: [] };
                    
                    // Process breakfast
                    if (dayData.breakfast && dayData.breakfast.length > 0) {
                        hasContent = true;
                        dayData.breakfast.forEach(item => {
                            csvContent += `${dayLabels[index]},Breakfast,"${item.name}",${item.calories || 0},${item.protein || 0},${item.carbs || 0},${item.fat || 0}\n`;
                            totalCalories += item.calories || 0;
                            totalProtein += item.protein || 0;
                            totalCarbs += item.carbs || 0;
                            totalFat += item.fat || 0;
                        });
                    }
                    
                    // Process lunch
                    if (dayData.lunch && dayData.lunch.length > 0) {
                        hasContent = true;
                        dayData.lunch.forEach(item => {
                            csvContent += `${dayLabels[index]},Lunch,"${item.name}",${item.calories || 0},${item.protein || 0},${item.carbs || 0},${item.fat || 0}\n`;
                            totalCalories += item.calories || 0;
                            totalProtein += item.protein || 0;
                            totalCarbs += item.carbs || 0;
                            totalFat += item.fat || 0;
                        });
                    }
                    
                    // Process dinner
                    if (dayData.dinner && dayData.dinner.length > 0) {
                        hasContent = true;
                        dayData.dinner.forEach(item => {
                            csvContent += `${dayLabels[index]},Dinner,"${item.name}",${item.calories || 0},${item.protein || 0},${item.carbs || 0},${item.fat || 0}\n`;
                            totalCalories += item.calories || 0;
                            totalProtein += item.protein || 0;
                            totalCarbs += item.carbs || 0;
                            totalFat += item.fat || 0;
                        });
                    }
                });
                
                if (hasContent) {
                    // Add totals row
                    csvContent += `\n,,TOTALS,${totalCalories},${Math.round(totalProtein)},${Math.round(totalCarbs)},${Math.round(totalFat)}\n`;
                } else {
                    csvContent += 'No meals planned,,,,,,';
                }
                
                // Create and download the CSV file
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `meal-plan-${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification('Success', `Meal plan CSV exported successfully! ${hasContent ? `Total: ${totalCalories} calories` : ''}`, 'success');
                
            } catch (error) {
                console.error('Error exporting CSV:', error);
                showNotification('Export Error', 'Error exporting CSV. Please try again.', 'error');
            }
        }
        
        // Toggle grocery list format dropdown
        function toggleGroceryDropdown() {
            const dropdown = document.getElementById('groceryDropdown');
            
            if (!dropdown) {
                console.error('Grocery dropdown element not found');
                return;
            }
            
            const isHidden = dropdown.classList.contains('hidden');
            
            if (isHidden) {
                // Show dropdown
                dropdown.classList.remove('hidden');
                console.log('Grocery dropdown shown');
                
                // Ensure it's visible on mobile
                if (window.innerWidth <= 480) {
                    dropdown.style.position = 'absolute';
                    dropdown.style.top = '100%';
                    dropdown.style.right = '0';
                    dropdown.style.zIndex = '9999';
                    console.log('Mobile dropdown positioning applied');
                }
            } else {
                // Hide dropdown
                dropdown.classList.add('hidden');
                console.log('Grocery dropdown hidden');
            }
            
            // Close dropdown when clicking outside
            if (isHidden) {
                setTimeout(() => {
                    document.addEventListener('click', function closeDropdown(e) {
                        if (!e.target.closest('.relative')) {
                            dropdown.classList.add('hidden');
                            document.removeEventListener('click', closeDropdown);
                            console.log('Dropdown closed by outside click');
                        }
                    });
                }, 100);
            }
        }

        function exportGroceryList(format = 'txt') {
            try {
                // Get meal plan data from the correct location
                const savedMealPlan = window.JSON?.safeParse ? 
                    window.JSON.safeParse(localStorage.getItem('mealPlan') || '{}', {}) :
                    (() => {
                        try {
                            return JSON.parse(localStorage.getItem('mealPlan') || '{}');
                        } catch (error) {
                            console.warn('Error parsing meal plan:', error);
                            return {};
                        }
                    })();
                
                const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
                
                // Collect all ingredients with enhanced parsing
                const ingredientsList = {};
                const mealsByDay = {};
                let totalMeals = 0;
                let totalCalories = 0;
                
                days.forEach(day => {
                    const dayData = savedMealPlan[day] || { breakfast: [], lunch: [], dinner: [] };
                    mealsByDay[day] = { breakfast: [], lunch: [], dinner: [] };
                    
                    ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                        if (dayData[mealType] && dayData[mealType].length > 0) {
                            dayData[mealType].forEach(item => {
                                totalMeals++;
                                mealsByDay[day][mealType].push(item.name);
                                
                                // Calculate calories if available
                                if (item.calories) {
                                    totalCalories += parseFloat(item.calories) || 0;
                                }
                                
                                // Try to find the recipe in the recipes database
                                let recipe = recipes.find(r => r.name === item.name);
                                if (!recipe) {
                                    recipe = customRecipes.find(r => r.name === item.name);
                                }
                                
                                if (recipe && recipe.ingredients) {
                                    // Parse ingredients based on the data structure
                                    let ingredientsArray = [];
                                    
                                    if (typeof recipe.ingredients === 'string') {
                                        ingredientsArray = recipe.ingredients.split(',').map(i => i.trim());
                                    } else if (Array.isArray(recipe.ingredients)) {
                                        ingredientsArray = recipe.ingredients;
                                    }
                                    
                                    ingredientsArray.forEach(ingredient => {
                                        const cleanIngredient = ingredient.trim();
                                        if (cleanIngredient) {
                                            // Extract quantity and unit if possible
                                            const parsed = parseIngredient(cleanIngredient);
                                            const key = parsed.name;
                                            
                                            if (!ingredientsList[key]) {
                                                ingredientsList[key] = {
                                                    name: parsed.name,
                                                    quantity: 0,
                                                    unit: parsed.unit,
                                                    count: 0
                                                };
                                            }
                                            
                                            ingredientsList[key].quantity += parsed.quantity;
                                            ingredientsList[key].count += 1;
                                        }
                                    });
                                } else {
                                    // If no recipe found, add the meal name as a basic item
                                    if (!ingredientsList[item.name]) {
                                        ingredientsList[item.name] = {
                                            name: item.name,
                                            quantity: 1,
                                            unit: 'serving',
                                            count: 0
                                        };
                                    }
                                    ingredientsList[item.name].count += 1;
                                }
                            });
                        }
                    });
                });
                
                // Generate content based on format
                const dateStr = new Date().toISOString().split('T')[0];
                let fileContent, mimeType, fileName, successMessage;
                const itemCount = Object.keys(ingredientsList).length;
                
                // Close dropdown
                document.getElementById('groceryDropdown').classList.add('hidden');
                
                switch (format.toLowerCase()) {
                    case 'pdf':
                        // Generate PDF using jsPDF
                        generateGroceryListPDF(ingredientsList, mealsByDay, totalMeals, totalCalories, dateStr);
                        showNotification('Success', `Professional PDF grocery list exported! ${itemCount} unique items with enhanced formatting.`, 'success');
                        return;
                        
                    case 'html':
                        fileContent = generateGroceryListHTML(ingredientsList, mealsByDay, totalMeals, totalCalories);
                        mimeType = 'text/html;charset=utf-8;';
                        fileName = `NutriTracker-GroceryList-${dateStr}.html`;
                        successMessage = `Interactive HTML grocery list exported! ${itemCount} unique items with web styling.`;
                        break;
                        
                    case 'csv':
                        fileContent = generateGroceryListCSV(ingredientsList, mealsByDay, totalMeals, totalCalories);
                        mimeType = 'text/csv;charset=utf-8;';
                        fileName = `NutriTracker-GroceryList-${dateStr}.csv`;
                        successMessage = `CSV grocery list exported! ${itemCount} unique items ready for spreadsheet apps.`;
                        break;
                        
                    case 'txt':
                    default:
                        fileContent = generateProfessionalGroceryList(ingredientsList, mealsByDay, totalMeals, totalCalories);
                        mimeType = 'text/plain;charset=utf-8;';
                        fileName = `NutriTracker-GroceryList-${dateStr}.txt`;
                        successMessage = `Smart text grocery list exported! ${itemCount} unique items organized by store sections.`;
                        break;
                }
                
                // Create and download the file
                const blob = new Blob([fileContent], { type: mimeType });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', fileName);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification('Success', successMessage, 'success');
                
            } catch (error) {
                console.error('Error exporting grocery list:', error);
                showNotification('Export Error', 'Error exporting grocery list. Please try again.', 'error');
            }
        }

        // Helper function to parse ingredient strings
        function parseIngredient(ingredientStr) {
            // Extract quantity, unit, and name from ingredient string
            const match = ingredientStr.match(/^(\d+(?:\.\d+)?)\s*(\w+)?\s+(.+)/) || 
                         ingredientStr.match(/^(\d+(?:\.\d+)?)\s+(.+)/) ||
                         [null, 1, '', ingredientStr];
            
            return {
                quantity: parseFloat(match[1]) || 1,
                unit: match[2] || '',
                name: (match[3] || match[2] || ingredientStr).trim()
            };
        }

        // Generate professional grocery list with proper formatting
        function generateProfessionalGroceryList(ingredientsList, mealsByDay, totalMeals, totalCalories) {
            const now = new Date();
            const weekStart = new Date(now);
            weekStart.setDate(now.getDate() - now.getDay());
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);
            
            let content = '';
            
            // Header
            content += '┌─────────────────────────────────────────────────────────┐\n';
            content += '│                    NUTRITRACKER PRO                    │\n';
            content += '│                 SMART GROCERY LIST                     │\n';
            content += '└─────────────────────────────────────────────────────────┘\n\n';
            
            // Week info
            content += `📅 Week of: ${weekStart.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}\n`;
            content += `📋 Generated: ${now.toLocaleDateString()} at ${now.toLocaleTimeString()}\n`;
            content += `🍽️ Total Meals Planned: ${totalMeals}\n`;
            if (totalCalories > 0) {
                content += `🔥 Estimated Total Calories: ${totalCalories.toFixed(0)}\n`;
            }
            content += '\n';
            
            // Meal plan overview
            content += '═══════════════════════════════════════════════════════════\n';
            content += '                     MEAL PLAN OVERVIEW                    \n';
            content += '═══════════════════════════════════════════════════════════\n\n';
            
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayKeys = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            
            dayKeys.forEach((dayKey, index) => {
                const dayMeals = mealsByDay[dayKey];
                if (dayMeals && (dayMeals.breakfast.length || dayMeals.lunch.length || dayMeals.dinner.length)) {
                    content += `${dayNames[index].toUpperCase()}:\n`;
                    if (dayMeals.breakfast.length) content += `  🌅 Breakfast: ${dayMeals.breakfast.join(', ')}\n`;
                    if (dayMeals.lunch.length) content += `  ☀️ Lunch: ${dayMeals.lunch.join(', ')}\n`;
                    if (dayMeals.dinner.length) content += `  🌙 Dinner: ${dayMeals.dinner.join(', ')}\n`;
                    content += '\n';
                }
            });
            
            // Shopping list by store sections
            content += '═══════════════════════════════════════════════════════════\n';
            content += '                    SHOPPING LIST BY AISLE                \n';
            content += '═══════════════════════════════════════════════════════════\n\n';
            
            // Enhanced categorization with store layout
            const storeCategories = {
                '🥩 MEAT & SEAFOOD': {
                    keywords: ['chicken', 'beef', 'fish', 'turkey', 'pork', 'salmon', 'tuna', 'shrimp', 'lamb', 'ground beef', 'steak'],
                    items: []
                },
                '🥬 FRESH PRODUCE': {
                    keywords: ['lettuce', 'tomato', 'onion', 'pepper', 'broccoli', 'spinach', 'carrot', 'cucumber', 'avocado', 'garlic', 'ginger', 'herb', 'vegetable', 'apple', 'banana', 'berry', 'fruit', 'orange', 'lemon', 'lime'],
                    items: []
                },
                '🥛 DAIRY & EGGS': {
                    keywords: ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'egg', 'dairy'],
                    items: []
                },
                '🍞 BAKERY & BREAD': {
                    keywords: ['bread', 'bagel', 'roll', 'bun', 'croissant', 'muffin', 'pastry'],
                    items: []
                },
                '🌾 GRAINS & PASTA': {
                    keywords: ['rice', 'pasta', 'noodle', 'quinoa', 'oat', 'cereal', 'flour', 'grain'],
                    items: []
                },
                '🥫 CANNED GOODS': {
                    keywords: ['canned', 'jar', 'sauce', 'soup', 'broth', 'stock'],
                    items: []
                },
                '❄️ FROZEN FOODS': {
                    keywords: ['frozen', 'ice cream'],
                    items: []
                },
                '🧂 SPICES & CONDIMENTS': {
                    keywords: ['salt', 'pepper', 'spice', 'seasoning', 'oil', 'vinegar', 'mayo', 'mustard', 'ketchup'],
                    items: []
                },
                '🥤 BEVERAGES': {
                    keywords: ['juice', 'soda', 'water', 'tea', 'coffee', 'drink'],
                    items: []
                },
                '🛒 OTHER ITEMS': {
                    keywords: [],
                    items: []
                }
            };
            
            // Categorize ingredients
            Object.values(ingredientsList).forEach(ingredient => {
                const lower = ingredient.name.toLowerCase();
                let categorized = false;
                
                // Find matching category
                for (const [categoryName, category] of Object.entries(storeCategories)) {
                    if (categoryName === '🛒 OTHER ITEMS') continue;
                    
                    if (category.keywords.some(keyword => lower.includes(keyword))) {
                        category.items.push(ingredient);
                        categorized = true;
                        break;
                    }
                }
                
                // If not categorized, add to OTHER ITEMS
                if (!categorized) {
                    storeCategories['🛒 OTHER ITEMS'].items.push(ingredient);
                }
            });
            
            // Output organized shopping list
            Object.entries(storeCategories).forEach(([categoryName, category]) => {
                if (category.items.length > 0) {
                    content += `${categoryName}:\n`;
                    content += '─'.repeat(50) + '\n';
                    
                    // Sort items alphabetically
                    category.items.sort((a, b) => a.name.localeCompare(b.name));
                    
                    category.items.forEach(item => {
                        let itemLine = `  ☐ ${item.name}`;
                        
                        // Add quantity information
                        if (item.quantity > 1) {
                            if (item.unit) {
                                itemLine += ` (${item.quantity} ${item.unit})`;
                            } else {
                                itemLine += ` (×${item.quantity})`;
                            }
                        }
                        
                        // Add usage count if multiple meals use it
                        if (item.count > 1) {
                            itemLine += ` [Used in ${item.count} meals]`;
                        }
                        
                        content += itemLine + '\n';
                    });
                    content += '\n';
                }
            });
            
            // Quick summary
            content += '═══════════════════════════════════════════════════════════\n';
            content += '                       SHOPPING SUMMARY                    \n';
            content += '═══════════════════════════════════════════════════════════\n\n';
            
            const totalItems = Object.keys(ingredientsList).length;
            content += `📊 Total Unique Items: ${totalItems}\n`;
            content += `📋 Items per Category:\n`;
            Object.entries(storeCategories).forEach(([categoryName, category]) => {
                if (category.items.length > 0) {
                    content += `   ${categoryName}: ${category.items.length} items\n`;
                }
            });
            
            content += '\n';
            content += '💡 SHOPPING TIPS:\n';
            content += '   • Check your pantry before shopping\n';
            content += '   • Buy perishables closer to cooking dates\n';
            content += '   • Consider bulk buying for frequently used items\n';
            content += '   • Stick to your list to maintain your nutrition goals\n\n';
            
            content += '─'.repeat(59) + '\n';
            content += '           Generated by NutriTracker Pro 🥗\n';
            content += '        Transform your nutrition, transform your life!\n';
            content += '─'.repeat(59) + '\n';
            
            return content;
        }

        // Generate PDF grocery list using jsPDF
        function generateGroceryListPDF(ingredientsList, mealsByDay, totalMeals, totalCalories, dateStr) {
            try {
                // Check if jsPDF is available - try multiple access patterns
                let jsPDF;
                if (window.jspdf && window.jspdf.jsPDF) {
                    jsPDF = window.jspdf.jsPDF;
                } else if (window.jsPDF) {
                    jsPDF = window.jsPDF;
                } else if (typeof window.jspdf !== 'undefined') {
                    jsPDF = window.jspdf.jsPDF;
                } else {
                    // Load jsPDF dynamically if not available
                    console.log('Loading jsPDF dynamically for grocery list...');
                    const script = document.createElement('script');
                    script.src = 'https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js';
                    script.onload = () => {
                        console.log('jsPDF loaded, retrying PDF generation...');
                        setTimeout(() => generateGroceryListPDF(ingredientsList, mealsByDay, totalMeals, totalCalories, dateStr), 100);
                    };
                    script.onerror = () => {
                        console.error('Failed to load jsPDF');
                        showNotification('Error', 'Failed to load PDF library. Please try again.', 'error');
                    };
                    document.head.appendChild(script);
                    return;
                }

                console.log('Creating PDF with jsPDF...');
                const doc = new jsPDF();
            
            // Set fonts and colors
            doc.setFont('helvetica');
            
            // Header
            doc.setFontSize(20);
            doc.setTextColor(16, 185, 129); // Green color
            doc.text('NutriTracker Pro - Smart Grocery List', 105, 25, { align: 'center' });
            
            doc.setFontSize(12);
            doc.setTextColor(0, 0, 0);
            const now = new Date();
            doc.text(`Generated: ${now.toLocaleDateString()} at ${now.toLocaleTimeString()}`, 20, 40);
            doc.text(`Total Meals Planned: ${totalMeals}`, 20, 50);
            if (totalCalories > 0) {
                doc.text(`Estimated Calories: ${totalCalories.toFixed(0)}`, 20, 60);
            }
            
            let yPosition = 80;
            
            // Organize items by categories
            const storeCategories = getStoreCategories(ingredientsList);
            
            Object.entries(storeCategories).forEach(([categoryName, category]) => {
                if (category.items.length > 0) {
                    // Check if we need a new page
                    if (yPosition > 250) {
                        doc.addPage();
                        yPosition = 30;
                    }
                    
                    // Category header
                    doc.setFontSize(14);
                    doc.setTextColor(16, 185, 129);
                    doc.text(categoryName.replace(/🥩|🥬|🥛|🍞|🌾|🥫|❄️|🧂|🥤|🛒/g, ''), 20, yPosition);
                    yPosition += 10;
                    
                    // Category items
                    doc.setFontSize(10);
                    doc.setTextColor(0, 0, 0);
                    category.items.sort((a, b) => a.name.localeCompare(b.name));
                    
                    category.items.forEach(item => {
                        if (yPosition > 270) {
                            doc.addPage();
                            yPosition = 30;
                        }
                        
                        let itemText = `☐ ${item.name}`;
                        if (item.quantity > 1) {
                            if (item.unit) {
                                itemText += ` (${item.quantity} ${item.unit})`;
                            } else {
                                itemText += ` (×${item.quantity})`;
                            }
                        }
                        
                        doc.text(itemText, 25, yPosition);
                        yPosition += 8;
                    });
                    
                    yPosition += 5;
                }
            });
            
            // Footer
            if (yPosition > 250) {
                doc.addPage();
                yPosition = 30;
            }
            doc.setFontSize(10);
            doc.setTextColor(100, 100, 100);
            doc.text('Transform your nutrition, transform your life!', 105, 280, { align: 'center' });
            
            // Save the PDF
            console.log('Attempting to save PDF:', `NutriTracker-GroceryList-${dateStr}.pdf`);
            doc.save(`NutriTracker-GroceryList-${dateStr}.pdf`);
            console.log('PDF save command completed');
            
            } catch (error) {
                console.error('Error generating grocery list PDF:', error);
                showNotification('PDF Error', 'Failed to generate PDF. Error: ' + error.message, 'error');
            }
        }

        // Generate HTML grocery list
        function generateGroceryListHTML(ingredientsList, mealsByDay, totalMeals, totalCalories) {
            const now = new Date();
            const storeCategories = getStoreCategories(ingredientsList);
            
            let html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NutriTracker Pro - Grocery List</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f8fafc; }
        .container { max-width: 800px; margin: 0 auto; background: white; border-radius: 12px; padding: 30px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .header { text-align: center; border-bottom: 3px solid #10B981; padding-bottom: 20px; margin-bottom: 30px; }
        .header h1 { color: #10B981; margin: 0; font-size: 28px; }
        .header p { color: #6b7280; margin: 5px 0; }
        .category { margin-bottom: 30px; }
        .category h2 { color: #1f2937; background: #f3f4f6; padding: 10px 15px; border-radius: 8px; margin: 0 0 15px 0; font-size: 16px; }
        .item { display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #e5e7eb; }
        .item:last-child { border-bottom: none; }
        .checkbox { margin-right: 15px; width: 18px; height: 18px; }
        .item-text { flex: 1; font-size: 14px; color: #374151; }
        .quantity { color: #6b7280; font-size: 12px; }
        .footer { text-align: center; margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; }
        @media print { body { background: white; } .container { box-shadow: none; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🥗 NutriTracker Pro</h1>
            <p><strong>Smart Grocery List</strong></p>
            <p>Generated: ${now.toLocaleDateString()} at ${now.toLocaleTimeString()}</p>
            <p>Total Meals Planned: ${totalMeals}`;
            
            if (totalCalories > 0) {
                html += ` | Estimated Calories: ${totalCalories.toFixed(0)}`;
            }
            
            html += `</p>
        </div>`;
            
            Object.entries(storeCategories).forEach(([categoryName, category]) => {
                if (category.items.length > 0) {
                    html += `<div class="category">
            <h2>${categoryName}</h2>`;
                    
                    category.items.sort((a, b) => a.name.localeCompare(b.name));
                    category.items.forEach(item => {
                        let itemText = item.name;
                        let quantityText = '';
                        
                        if (item.quantity > 1) {
                            if (item.unit) {
                                quantityText = ` (${item.quantity} ${item.unit})`;
                            } else {
                                quantityText = ` (×${item.quantity})`;
                            }
                        }
                        
                        html += `<div class="item">
                <input type="checkbox" class="checkbox">
                <span class="item-text">${itemText}<span class="quantity">${quantityText}</span></span>
            </div>`;
                    });
                    
                    html += `</div>`;
                }
            });
            
            html += `<div class="footer">
            <p>Transform your nutrition, transform your life! 💪</p>
        </div>
    </div>
<!-- ==========================================================
     ✅ Fixed Script Order (Supabase-first, No Duplicates)
     ========================================================== -->
<!-- 1. Core Supabase SDK + Unified Config -->
<script defer src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>
<script defer src="supabase-config.js"></script>

<!-- 2. Supabase Initialization and Session Setup -->
<script defer src="supabase-init.js"></script>
<script defer src="initialization-manager.js"></script>

<!-- 3. Core Middleware and Logic -->
<script defer src="security-middleware.js"></script>
<script defer src="subscription-manager.js"></script>
<script defer src="subscription-middleware.js"></script>

</body>
</html>`;
            
            return html;
        }

        // Generate CSV grocery list
        function generateGroceryListCSV(ingredientsList, mealsByDay, totalMeals, totalCalories) {
            let csv = 'Category,Item,Quantity,Unit,Usage Count\\n';
            
            const storeCategories = getStoreCategories(ingredientsList);
            
            Object.entries(storeCategories).forEach(([categoryName, category]) => {
                if (category.items.length > 0) {
                    const cleanCategoryName = categoryName.replace(/🥩|🥬|🥛|🍞|🌾|🥫|❄️|🧂|🥤|🛒/g, '').trim();
                    
                    category.items.sort((a, b) => a.name.localeCompare(b.name));
                    category.items.forEach(item => {
                        csv += `"${cleanCategoryName}","${item.name}","${item.quantity}","${item.unit}","${item.count}"\\n`;
                    });
                }
            });
            
            return csv;
        }

        // Helper function to organize ingredients by store categories
        function getStoreCategories(ingredientsList) {
            const storeCategories = {
                '🥩 MEAT & SEAFOOD': {
                    keywords: ['chicken', 'beef', 'fish', 'turkey', 'pork', 'salmon', 'tuna', 'shrimp', 'lamb', 'ground beef', 'steak'],
                    items: []
                },
                '🥬 FRESH PRODUCE': {
                    keywords: ['lettuce', 'tomato', 'onion', 'pepper', 'broccoli', 'spinach', 'carrot', 'cucumber', 'avocado', 'garlic', 'ginger', 'herb', 'vegetable', 'apple', 'banana', 'berry', 'fruit', 'orange', 'lemon', 'lime'],
                    items: []
                },
                '🥛 DAIRY & EGGS': {
                    keywords: ['milk', 'cheese', 'yogurt', 'butter', 'cream', 'egg', 'dairy'],
                    items: []
                },
                '🍞 BAKERY & BREAD': {
                    keywords: ['bread', 'bagel', 'roll', 'bun', 'croissant', 'muffin', 'pastry'],
                    items: []
                },
                '🌾 GRAINS & PASTA': {
                    keywords: ['rice', 'pasta', 'noodle', 'quinoa', 'oat', 'cereal', 'flour', 'grain'],
                    items: []
                },
                '🥫 CANNED GOODS': {
                    keywords: ['canned', 'jar', 'sauce', 'soup', 'broth', 'stock'],
                    items: []
                },
                '❄️ FROZEN FOODS': {
                    keywords: ['frozen', 'ice cream'],
                    items: []
                },
                '🧂 SPICES & CONDIMENTS': {
                    keywords: ['salt', 'pepper', 'spice', 'seasoning', 'oil', 'vinegar', 'mayo', 'mustard', 'ketchup'],
                    items: []
                },
                '🥤 BEVERAGES': {
                    keywords: ['juice', 'soda', 'water', 'tea', 'coffee', 'drink'],
                    items: []
                },
                '🛒 OTHER ITEMS': {
                    keywords: [],
                    items: []
                }
            };
            
            // Categorize ingredients
            Object.values(ingredientsList).forEach(ingredient => {
                const lower = ingredient.name.toLowerCase();
                let categorized = false;
                
                for (const [categoryName, category] of Object.entries(storeCategories)) {
                    if (categoryName === '🛒 OTHER ITEMS') continue;
                    
                    if (category.keywords.some(keyword => lower.includes(keyword))) {
                        category.items.push(ingredient);
                        categorized = true;
                        break;
                    }
                }
                
                if (!categorized) {
                    storeCategories['🛒 OTHER ITEMS'].items.push(ingredient);
                }
            });
            
            return storeCategories;
        }

        // Global chart variables
        let allChartsInitialized = false;

        // Destroy existing chart if it exists
        function destroyChart(chartVariable) {
            if (chartVariable && typeof chartVariable.destroy === 'function') {
                try {
                    chartVariable.destroy();
                } catch (error) {
                    console.warn('Error destroying chart:', error);
                }
            }
            return null;
        }

        // Unified chart initialization function
        function initializeAllCharts() {
            console.log('Initializing all charts...');
            
            // Destroy existing charts first
            charts.calories = destroyChart(charts.calories);
            charts.protein = destroyChart(charts.protein);
            charts.carbs = destroyChart(charts.carbs);
            charts.fat = destroyChart(charts.fat);
            progressChart = destroyChart(progressChart);
            macroTotalsChart = destroyChart(macroTotalsChart);
            macroGoalsChart = destroyChart(macroGoalsChart);
            
            // Initialize macro doughnut charts
            initializeMacroDoughnutCharts();
            
            // Initialize progress chart
            initializeProgressChart();
            
            // Initialize macro line charts
            initializeMacroCharts();
        }
        
        // Application Initialization (Protected by Cloudflare Access)
        async function initializeApp() {
            console.log('Initializing Macro Calculator (Protected by Cloudflare Access)...');
            
            // Check authentication for invite-only system
            try {
                const authState = await window.authHelper.getAuthState();
                if (!authState.isAuthenticated) {
                    console.warn('User not authenticated - redirecting to login');
                    window.authHelper.redirectToLogin();
                    return; // Stop initialization
                }
                console.info('✅ User authenticated, proceeding with app initialization');
            } catch (error) {
                console.error('Authentication check failed:', error);
                window.authHelper.redirectToLogin();
                return;
            }
            
            // Clean up any old authentication session data
            localStorage.removeItem('macro_auth_session');
            
            // Check if Chart.js is loaded
            if (typeof Chart === 'undefined') {
                console.error('Chart.js is not loaded! Charts will not work.');
                showNotification('Charts Error', 'Chart.js library failed to load. Charts will not work.', 'error');
                return;
            } else {
                console.log('Chart.js version:', Chart.version);
            }
            
            // Initialize in proper order with delays
            initializeUnitSystem();
            
            setTimeout(async () => {
                // Load basic data first (without database calls)
                await loadBasicStoredData();
                initializeRecipeDatabase();
                initializeProgressTracker();
                initializeMacroTracking();
                
                // Load weekly meal planner data
                loadMealPlan().catch(error => console.warn('Meal plan load error:', error));
                
                // Check for and restore final backup if needed
                checkForFinalBackup();
            }, 100);
            
            setTimeout(() => {
                initializeAllCharts();
                updateProgress();
                allChartsInitialized = true;
                
                // Setup auto-save mechanism
                setupAutoSave();
                
                // Verify data integrity
                verifyDataIntegrity();
                
                // Ensure display is synchronized with saved/calculated values
                ensureDisplaySync();
                
                // Ensure meal displays are properly updated after initialization
                refreshMealDisplays();
                
                // Save data before page unload
                window.addEventListener('beforeunload', function(event) {
                    console.log('Page unloading - saving progress data...');
                    saveProgressData();
                    
                    // Create final backup
                    try {
                        const finalBackup = {
                            progressEntries: progressEntries,
                            progressGoal: progressGoal,
                            timestamp: Date.now(),
                            finalSave: true
                        };
                        localStorage.setItem('progress_final_backup', JSON.stringify(finalBackup));
                    } catch (error) {
                        console.error('Error creating final backup:', error);
                    }
                });
                
                console.log('All app components initialized successfully');
            }, 500);
        }
        
        // Global error handlers
        window.addEventListener('error', function(event) {
            console.error('Global error caught:', event.error);
            // Only show user-friendly notifications for critical errors
            if (event.error && event.error.message && !event.error.message.includes('Loading CSS chunk')) {
                showNotification('Application Error', 'An unexpected error occurred. Please refresh the page if issues persist.', 'error');
            }
        });
        
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            // Prevent the default behavior which would log to console
            event.preventDefault();
            // Only show notifications for non-trivial errors
            if (event.reason && event.reason.toString().includes('fetch')) {
                console.warn('Network request failed:', event.reason);
            }
        });
        
        // Initialize application on page load (Protected by Cloudflare Access)
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('DOM Content Loaded - Starting Macro Calculator (Protected by Cloudflare Access)...');
            

            
            await initializeApp();
        });
    </script>

    <!-- Stay Tuned Section -->
    <section class="bg-gradient-to-r from-blue-50 to-indigo-50 py-12 mt-12">
        <div class="max-w-4xl mx-auto px-4 text-center">
            <div class="bg-white rounded-lg shadow-lg p-8 border border-blue-100">
                <div class="flex items-center justify-center mb-4">
                    <svg class="w-8 h-8 text-blue-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <h2 class="text-2xl font-bold text-gray-800">Development in Progress</h2>
                </div>
                <p class="text-lg text-gray-600 mb-4">
                    🚀 <strong>Stay tuned for more features and recipes!</strong>
                </p>
                <p class="text-gray-500">
                    This macro calculator is continuously evolving. We're working on exciting new features, 
                    expanded recipe databases, and enhanced tracking capabilities to help you reach your nutrition goals.
                </p>
                <div class="flex items-center justify-center mt-6 space-x-2 text-sm text-blue-600">
                    <div class="animate-pulse flex space-x-1">
                        <div class="w-2 h-2 bg-blue-400 rounded-full"></div>
                        <div class="w-2 h-2 bg-blue-400 rounded-full"></div>
                        <div class="w-2 h-2 bg-blue-400 rounded-full"></div>
                    </div>
                    <span class="font-medium">More updates coming soon</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white py-8 mt-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
                <div class="md:col-span-2">
                    <h3 class="text-lg font-semibold mb-4">
                        <i class="fas fa-calculator mr-2"></i>
                        Macro Calculator
                    </h3>
                    <p class="text-gray-300 text-sm mb-4">Your AI-powered nutrition tracking companion. Track macros, monitor progress, and achieve your health goals with precision and ease.</p>
                </div>
                <div>
                    <h3 class="text-lg font-semibold mb-4">Legal</h3>
                    <ul class="space-y-2 text-sm">
                        <li><a href="disclaimer.html" class="text-blue-400 hover:text-blue-300 transition-colors flex items-center">
                            <i class="fas fa-exclamation-triangle mr-2 w-4"></i>Disclaimer
                        </a></li>
                        <li><a href="privacy-policy.html" class="text-blue-400 hover:text-blue-300 transition-colors flex items-center">
                            <i class="fas fa-shield-alt mr-2 w-4"></i>Privacy Policy
                        </a></li>
                        <li><a href="terms-of-service.html" class="text-blue-400 hover:text-blue-300 transition-colors flex items-center">
                            <i class="fas fa-file-contract mr-2 w-4"></i>Terms of Service
                        </a></li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-lg font-semibold mb-4">Quick Access</h3>
                    <ul class="space-y-2 text-sm">
                        <li><a href="coach-login.html" class="text-green-400 hover:text-green-300 transition-colors flex items-center">
                            <i class="fas fa-dumbbell mr-2 w-4"></i>Coach Portal
                        </a></li>
                        <li><button onclick="handleAuth()" class="text-red-400 hover:text-red-300 transition-colors flex items-center">
                            <i class="fas fa-sign-out-alt mr-2 w-4"></i>Logout
                        </button></li>
                        <li><span class="text-gray-300 flex items-center">
                            <i class="fas fa-user mr-2 w-4"></i><span id="footer-user-name">User</span>
                        </span></li>
                    </ul>
                </div>
            </div>
            <div class="border-t border-gray-700 mt-8 pt-8">
                <div class="flex flex-col md:flex-row justify-between items-center text-sm text-gray-400">
                    <p>&copy; 2024 Macro Calculator. All rights reserved.</p>
                    <p class="mt-2 md:mt-0">Built with precision for your health journey.</p>
                </div>
            </div>
        </div>
    </footer>

<!-- Supabase Auth Widget -->

<script>
  // Note: Supabase Auth event handlers are already configured in the main app JavaScript
  // No additional handlers needed here to avoid refresh loops
  console.log("Netlify Identity widget loaded for app.html");
</script>

<!-- ==========================================================
     ✅ Fixed Script Order (Supabase-first, No Duplicates)
     ========================================================== -->
<!-- 1. Core Supabase SDK + Unified Config -->
<script defer src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.3/dist/umd/supabase.min.js"></script>
<script defer src="supabase-config.js"></script>

<!-- 2. Supabase Initialization and Session Setup -->
<script defer src="supabase-init.js"></script>
<script defer src="initialization-manager.js"></script>

<!-- 3. Core Middleware and Logic -->
<script defer src="security-middleware.js"></script>
<script defer src="subscription-manager.js"></script>
<script defer src="subscription-middleware.js"></script>

</body>
</html>